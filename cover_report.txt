Reading database from /home/mrodrigu/perl/xmltwig2/cover_db


---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
blib/lib/XML/Twig.pm           95.7   85.4   70.6   97.5    n/a   99.5   89.9
blib/lib/XML/Twig/XPath.pm     89.9   67.9   75.0   97.0   42.2    0.5   81.2
Total                          95.6   85.2   70.6   97.5   42.2  100.0   89.6
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          t/is_field.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:08:55 2009
Finish:       Tue Jun 23 05:08:55 2009

Run:          t/pod.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:09:04 2009
Finish:       Tue Jun 23 05:09:06 2009

Run:          t/pod_coverage.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:09:07 2009
Finish:       Tue Jun 23 05:09:08 2009

Run:          t/test1.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:09:18 2009
Finish:       Tue Jun 23 05:09:18 2009

Run:          t/test2.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:09:28 2009
Finish:       Tue Jun 23 05:09:28 2009

Run:          t/test3.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:09:38 2009
Finish:       Tue Jun 23 05:09:38 2009

Run:          t/test4.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:09:48 2009
Finish:       Tue Jun 23 05:09:48 2009

Run:          t/test5.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:10:05 2009
Finish:       Tue Jun 23 05:10:06 2009

Run:          t/test_3_24.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:10:27 2009
Finish:       Tue Jun 23 05:10:27 2009

Run:          t/test_3_26.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:10:37 2009
Finish:       Tue Jun 23 05:10:37 2009

Run:          t/test_3_27.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:10:47 2009
Finish:       Tue Jun 23 05:10:47 2009

Run:          t/test_3_30.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:10:58 2009
Finish:       Tue Jun 23 05:10:58 2009

Run:          t/test_3_32.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:11:08 2009
Finish:       Tue Jun 23 05:11:08 2009

Run:          t/test_additional.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:11:18 2009
Finish:       Tue Jun 23 05:11:20 2009

Run:          t/test_attregexp_cond.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:13:49 2009
Finish:       Tue Jun 23 05:13:49 2009

Run:          t/test_autoencoding_conversion.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:14:00 2009
Finish:       Tue Jun 23 05:14:00 2009

Run:          t/test_bugs_3_15.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:14:02 2009
Finish:       Tue Jun 23 05:14:02 2009

Run:          t/test_bugs_3_18.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:14:14 2009
Finish:       Tue Jun 23 05:14:14 2009

Run:          t/test_bugs_3_19.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:14:48 2009
Finish:       Tue Jun 23 05:14:48 2009

Run:          t/test_bugs_3_21.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:14:58 2009
Finish:       Tue Jun 23 05:14:58 2009

Run:          t/test_bugs_3_22.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:15:08 2009
Finish:       Tue Jun 23 05:15:08 2009

Run:          t/test_cdata.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:15:20 2009
Finish:       Tue Jun 23 05:15:20 2009

Run:          t/test_class_methods.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:15:30 2009
Finish:       Tue Jun 23 05:15:30 2009

Run:          t/test_comment_handler.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:15:40 2009
Finish:       Tue Jun 23 05:15:40 2009

Run:          t/test_drop_comments.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:15:52 2009
Finish:       Tue Jun 23 05:15:52 2009

Run:          t/test_entities.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:16:02 2009
Finish:       Tue Jun 23 05:16:02 2009

Run:          t/test_erase.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:16:16 2009
Finish:       Tue Jun 23 05:16:16 2009

Run:          t/test_errors.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:16:25 2009
Finish:       Tue Jun 23 05:16:26 2009

Run:          t/test_even_more_coverage.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:16:35 2009
Finish:       Tue Jun 23 05:16:35 2009

Run:          t/test_expand_external_entities.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:16:45 2009
Finish:       Tue Jun 23 05:16:45 2009

Run:          t/test_ignore_elts.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:16:54 2009
Finish:       Tue Jun 23 05:16:54 2009

Run:          t/test_keep_atts_order.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:17:05 2009
Finish:       Tue Jun 23 05:17:05 2009

Run:          t/test_mark.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:17:15 2009
Finish:       Tue Jun 23 05:17:15 2009

Run:          t/test_memory.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:17:24 2009
Finish:       Tue Jun 23 05:17:30 2009

Run:          t/test_nav.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:17:40 2009
Finish:       Tue Jun 23 05:17:40 2009

Run:          t/test_need_3_args_open.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:17:50 2009
Finish:       Tue Jun 23 05:17:50 2009

Run:          t/test_need_io_scalar.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:18:01 2009
Finish:       Tue Jun 23 05:18:09 2009

Run:          t/test_need_use_bytes.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:18:29 2009
Finish:       Tue Jun 23 05:18:29 2009

Run:          t/test_new_features_3_15.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:18:38 2009
Finish:       Tue Jun 23 05:18:38 2009

Run:          t/test_new_features_3_16.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:18:48 2009
Finish:       Tue Jun 23 05:18:49 2009

Run:          t/test_new_features_3_18.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:19:00 2009
Finish:       Tue Jun 23 05:19:00 2009

Run:          t/test_new_features_3_22.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:19:11 2009
Finish:       Tue Jun 23 05:19:11 2009

Run:          t/test_pi_handler.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:19:21 2009
Finish:       Tue Jun 23 05:19:21 2009

Run:          t/test_pos.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:19:33 2009
Finish:       Tue Jun 23 05:19:33 2009

Run:          t/test_safe_encode.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:19:42 2009
Finish:       Tue Jun 23 05:19:42 2009

Run:          t/test_simplify.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:19:52 2009
Finish:       Tue Jun 23 05:19:54 2009

Run:          t/test_spaces.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:20:04 2009
Finish:       Tue Jun 23 05:20:04 2009

Run:          t/test_twig_roots.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:20:13 2009
Finish:       Tue Jun 23 05:20:13 2009

Run:          t/test_unique_xpath.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:20:24 2009
Finish:       Tue Jun 23 05:20:24 2009

Run:          t/test_variables.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:20:34 2009
Finish:       Tue Jun 23 05:20:34 2009

Run:          t/test_with_lwp.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:20:44 2009
Finish:       Tue Jun 23 05:20:44 2009

Run:          t/test_with_lwp.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:20:44 2009
Finish:       Tue Jun 23 05:21:01 2009

Run:          t/test_with_lwp.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:20:44 2009
Finish:       Tue Jun 23 05:20:44 2009

Run:          t/test_with_lwp.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:20:44 2009
Finish:       Tue Jun 23 05:20:44 2009

Run:          t/test_with_lwp.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:20:44 2009
Finish:       Tue Jun 23 05:20:44 2009

Run:          t/test_with_lwp.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:20:44 2009
Finish:       Tue Jun 23 05:21:01 2009

Run:          t/test_wrapped.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:21:13 2009
Finish:       Tue Jun 23 05:21:13 2009

Run:          t/test_xml_split.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:21:22 2009
Finish:       Tue Jun 23 05:21:26 2009

Run:          t/test_xml_split_g.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:21:27 2009
Finish:       Tue Jun 23 05:21:28 2009

Run:          t/test_xpath_cond.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:21:30 2009
Finish:       Tue Jun 23 05:21:30 2009

Run:          t/tests_3_23.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:21:40 2009
Finish:       Tue Jun 23 05:21:40 2009

Run:          t/xmlxpath_01basic.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:21:50 2009
Finish:       Tue Jun 23 05:21:50 2009

Run:          t/xmlxpath_02descendant.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:22:00 2009
Finish:       Tue Jun 23 05:22:00 2009

Run:          t/xmlxpath_03star.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:22:10 2009
Finish:       Tue Jun 23 05:22:10 2009

Run:          t/xmlxpath_04pos.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:22:21 2009
Finish:       Tue Jun 23 05:22:21 2009

Run:          t/xmlxpath_05attrib.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:22:31 2009
Finish:       Tue Jun 23 05:22:31 2009

Run:          t/xmlxpath_06attrib_val.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:22:41 2009
Finish:       Tue Jun 23 05:22:41 2009

Run:          t/xmlxpath_07count.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:22:51 2009
Finish:       Tue Jun 23 05:22:51 2009

Run:          t/xmlxpath_08name.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:23:02 2009
Finish:       Tue Jun 23 05:23:02 2009

Run:          t/xmlxpath_09a_string_length.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:23:12 2009
Finish:       Tue Jun 23 05:23:13 2009

Run:          t/xmlxpath_09string_length.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:23:23 2009
Finish:       Tue Jun 23 05:23:23 2009

Run:          t/xmlxpath_10pipe.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:23:33 2009
Finish:       Tue Jun 23 05:23:33 2009

Run:          t/xmlxpath_12axisdescendant.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:23:44 2009
Finish:       Tue Jun 23 05:23:44 2009

Run:          t/xmlxpath_13axisparent.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:23:54 2009
Finish:       Tue Jun 23 05:23:54 2009

Run:          t/xmlxpath_14axisancestor.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:24:04 2009
Finish:       Tue Jun 23 05:24:04 2009

Run:          t/xmlxpath_15axisfol_sib.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:24:15 2009
Finish:       Tue Jun 23 05:24:15 2009

Run:          t/xmlxpath_16axisprec_sib.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:24:25 2009
Finish:       Tue Jun 23 05:24:25 2009

Run:          t/xmlxpath_17axisfollowing.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:24:35 2009
Finish:       Tue Jun 23 05:24:35 2009

Run:          t/xmlxpath_18axispreceding.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:24:46 2009
Finish:       Tue Jun 23 05:24:46 2009

Run:          t/xmlxpath_19axisd_or_s.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:24:56 2009
Finish:       Tue Jun 23 05:24:56 2009

Run:          t/xmlxpath_20axisa_or_s.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:25:07 2009
Finish:       Tue Jun 23 05:25:07 2009

Run:          t/xmlxpath_21allnodes.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:25:17 2009
Finish:       Tue Jun 23 05:25:17 2009

Run:          t/xmlxpath_22name_select.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:25:28 2009
Finish:       Tue Jun 23 05:25:28 2009

Run:          t/xmlxpath_23func.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:25:38 2009
Finish:       Tue Jun 23 05:25:38 2009

Run:          t/xmlxpath_24namespaces.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:25:48 2009
Finish:       Tue Jun 23 05:25:48 2009

Run:          t/xmlxpath_25scope.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:25:59 2009
Finish:       Tue Jun 23 05:25:59 2009

Run:          t/xmlxpath_26predicate.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:26:09 2009
Finish:       Tue Jun 23 05:26:09 2009

Run:          t/xmlxpath_28ancestor2.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:26:19 2009
Finish:       Tue Jun 23 05:26:19 2009

Run:          t/xmlxpath_29desc_with_predicate.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:26:30 2009
Finish:       Tue Jun 23 05:26:30 2009

Run:          t/xmlxpath_30lang.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:26:40 2009
Finish:       Tue Jun 23 05:26:40 2009

Run:          t/xmlxpath_additional.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:26:50 2009
Finish:       Tue Jun 23 05:26:50 2009

Run:          t/xmlxpath_nav.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:27:01 2009
Finish:       Tue Jun 23 05:27:01 2009

Run:          t/xmlxpath_test1.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:27:11 2009
Finish:       Tue Jun 23 05:27:11 2009

Run:          t/xmlxpath_test_twig_roots.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:27:22 2009
Finish:       Tue Jun 23 05:27:22 2009

Run:          t/xmlxpath_test_with_handlers.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:27:33 2009
Finish:       Tue Jun 23 05:27:33 2009

Run:          t/xmlxpath_xpath_cond.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:27:44 2009
Finish:       Tue Jun 23 05:27:44 2009

Run:          t/zz_dump_config.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun 23 05:27:53 2009
Finish:       Tue Jun 23 05:27:54 2009

blib/lib/XML/Twig.pm

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     # $Id: /xmltwig/trunk/Twig_pm.slow 33 2008-04-30T08:03:41.004487Z mrodrigu  $ 
2                                                     #
3                                                     # Copyright (c) 1999-2004 Michel Rodriguez
4                                                     # All rights reserved.
5                                                     #
6                                                     # This program is free software; you can redistribute it and/or
7                                                     # modify it under the same terms as Perl itself.
8                                                     #
9                                                     
10                                                    # This is created in the caller's space
11                                                    BEGIN
12           131                  131           583   { sub ::PCDATA { '#PCDATA' } 
               6                    6           327   
13             5                    5           636     sub ::CDATA  { '#CDATA'  } 
14                                                    }
15                                                    
16           131                  129         25150   use UNIVERSAL qw(isa);
             131                                461   
             129                               1058   
17                                                    
18           129                  118           725   use strict;
             129                                407   
             118                                614   
19           118                  117           681   use warnings; # > perl 5.5
             118                                308   
             117                                740   
20                                                    
21                                                    ######################################################################
22                                                    package XML::Twig;
23                                                    ######################################################################
24                                                    
25                                                    require 5.004;
26                                                    
27           117                  115         32802   use utf8; # > perl 5.5
             117                                385   
             115                                853   
28                                                    
29           115                  114           689   use vars qw($VERSION @ISA %valid_option);
             115                               1067   
             114                                894   
30           114                  113           676   use Carp;
             114                                303   
             113                                949   
31                                                    
32           113                  112           724   use File::Spec;
             113                                281   
             112                               1447   
33           112                  112           827   use File::Basename;
             112                                316   
             112                               1121   
34                                                    
35           112                  111           685   use UNIVERSAL qw(isa);
             112                                359   
             111                                610   
36                                                    
37                                                    # constants: element types
38           111                  110           724   use constant (PCDATA  => '#PCDATA');
             111                                319   
             110                               1715   
39           110                  111           721   use constant (CDATA   => '#CDATA');
             110                                326   
             111                                711   
40           111                  110           708   use constant (PI      => '#PI');
             111                                284   
             110                                682   
41           110                  107           759   use constant (COMMENT => '#COMMENT');
             110                                334   
             107                                646   
42           107                  102           665   use constant (ENT     => '#ENT');
             107                                348   
             102                                547   
43                                                    
44                                                    # element classes
45           102                  104           721   use constant (ELT     => '#ELT');
             102                                232   
             104                                549   
46           104                  101           665   use constant (TEXT    => '#TEXT');
             104                                236   
             101                               1077   
47                                                    
48                                                    # element properties
49           101                   98           648   use constant (ASIS    => '#ASIS');
             101                                227   
              98                                494   
50            98                   99           660   use constant (EMPTY   => '#EMPTY');
              98                                255   
              99                                518   
51                                                    
52                                                    # used in parseurl to set the buffer size to the same size as in XML::Parser::Expat
53            99                   99           650   use constant (BUFSIZE => 32768);
              99                                212   
              99                                503   
54                                                    
55                                                    
56                                                    # used to store the gi's
57                                                    my %gi2index;   # gi => index
58                                                    my @index2gi;   # list of gi's
59                                                    my $SPECIAL_GI; # first non-special gi;
60                                                    #my %base_ent;   # base entity character => replacement
61                                                    
62                                                    # flag, set to true if the weaken sub is available
63            99                   95           687   use vars qw( $weakrefs);
              99                                211   
              95                                631   
64                                                    
65                                                    # flag set to true if the version of expat seems to be 1.95.2, which has annoying bugs
66                                                    # wrt doctype handling. This is global for performance reasons. 
67                                                    my $expat_1_95_2=0;
68                                                    
69                                                    # xml name (leading # allowed)
70                                                    # first line is for perl 5.005, second line for modern perl, that accept character classes
71                                                    my $REG_NAME       = q{(?:(?:[^\W\d]|[:#])(?:[\w.-]*:)?[\w.-]*)};     # does not work for leading non-ascii letters
72                                                       $REG_NAME       = q{(?:(?:[[:alpha:]:#])(?:[\w.-]*:)?[\w.-]*)};    # > perl 5.5
73                                                    
74                                                    # name or wildcard (* or '') (leading # allowed)
75                                                    my $REG_NAME_W     = q{(?:(?:[^\W\d]|[:#])(?:[\w.-]*:)?[\w.-]*|\*)}; # does not work for leading non-ascii letters
76                                                       $REG_NAME_W     = q{(?:(?:[[:alpha:]:#])(?:[\w.-]*:)?[\w.-]*|\*)}; # > perl 5.5
77                                                    
78                                                    my $REG_REGEXP     = q{(?:/(?:[^\\/]|\\.)*/[eimsox]*)};               # regexp
79                                                    my $REG_REGEXP_EXP = q{(?:(?:[^\\/]|\\.)*)};                          # content of a regexp
80                                                    my $REG_REGEXP_MOD = q{(?:[eimso]*)};                                 # regexp modifiers
81                                                    my $REG_MATCH      = q{[!=]~};                                        # match (or not)
82                                                    my $REG_STRING     = q{(?:"(?:[^\\"]|\\.)*"|'(?:[^\\']|\\.)*')};      # string (simple or double quoted)
83                                                    my $REG_NUMBER     = q{(?:\d+(?:\.\d*)?|\.\d+)};                      # number
84                                                    my $REG_VALUE      = qq{(?:$REG_STRING|$REG_NUMBER)};                 # value
85                                                    my $REG_OP         = q{==|!=|>|<|>=|<=|eq|ne|lt|gt|le|ge|=};          # op
86                                                    my $REG_FUNCTION   = q{(?:string|text)\(\s*\)};
87                                                    my $REG_STRING_ARG = qq{(?:string|text)\\(\\s*$REG_NAME_W\\s*\\)};
88                                                    my $REG_COMP       = q{(?:>=|<=|!=|<|>|=)};
89                                                    
90                                                    
91                                                    # used in the handler trigger code
92                                                    my $REG_NAKED_PREDICATE= qq{((?:"[^"]*"|'[^']*'|$REG_STRING_ARG|$REG_FUNCTION|\@$REG_NAME_W|$REG_MATCH\\s*$REG_REGEXP|[\\s\\d><=!()+.-]|(?i:and)|(?i:or))*)};
93                                                    my $REG_PREDICATE= qq{\\[$REG_NAKED_PREDICATE\\]};
94                                                    
95                                                    # not all axis, only supported ones (in get_xpath)
96                                                    my @supported_axis= ( 'ancestor', 'ancestor-or-self', 'child', 'descendant', 'descendant-or-self', 
97                                                                          'following', 'following-sibling', 'parent', 'preceding', 'preceding-sibling', 'self'
98                                                                        );
99                                                    my $REG_AXIS       = "(?:" . join( '|', @supported_axis) .")";
100                                                   
101                                                   # only used in the "xpath"engine (for get_xpath/findnodes) for now
102                                                   my $REG_PREDICATE_ALT  = qr{\[(?:(?:string\(\s*\)|\@$REG_NAME)\s*$REG_MATCH\s*$REG_REGEXP\s*|[^\]]*)\]};
103                                                   
104                                                   # used to convert XPath tests on strings to the perl equivalent 
105                                                   my %PERL_ALPHA_TEST= ( '=' => ' eq ', '!=' => ' ne ', '>' => ' gt ', '>=' => ' ge ', '<' => ' lt ', '<=' => ' le ');
106                                                   
107                                                   my $parser_version;
108                                                   my( $FB_HTMLCREF, $FB_XMLCREF);
109                                                   
110                                                   my $NO_WARNINGS= $] >= 5.006 ? 'no warnings' : 'local $^W=0';
111                                                   
112                                                   BEGIN
113                                                   { 
114           95                   95           507   $VERSION = '3.33';
115                                                   
116           95                   95          1221   use XML::Parser;
              95                                307   
              95                               1294   
117           95                                313   my $needVersion = '2.23';
118           95                                268   $parser_version= $XML::Parser::VERSION;
119   ***     95     50                         922   croak "need at least XML::Parser version $needVersion" unless $parser_version >= $needVersion;
120                                                   
121   ***     95     50                         509   if( $] >= 5.008) 
122           92                   92          1085     { eval "use Encode qw( :all)";
              92                               1321   
              92                                312   
              92                                993   
123           92                               2669       $FB_XMLCREF  = 0x0400; # Encode::FB_XMLCREF;
124           92                                387       $FB_HTMLCREF = 0x0200; # Encode::FB_HTMLCREF;
125                                                     }
126                                                   
127                                                   # test whether we can use weak references
128                                                   # set local empty signal handler to trap error messages
129           92                                258   { local $SIG{__DIE__};
              92                                701   
130   ***     92     50     33                 2823     if( eval( 'require Scalar::Util') && defined( \&Scalar::Util::weaken)) 
      ***             0                               
131           92                               1034       { import Scalar::Util( 'weaken'); $weakrefs= 1; }
              92                                753   
132                                                     elsif( eval( 'require WeakRef')) 
133   ***      0                                  0       { import WeakRef; $weakrefs= 1;                 }
      ***      0                                  0   
134                                                     else  
135   ***      0                                  0       { $weakrefs= 0;                                 } 
136                                                   }
137                                                   
138           92                                971   import XML::Twig::Elt;
139           92                                629   import XML::Twig::Entity;
140           92                                572   import XML::Twig::Entity_list;
141                                                   
142                                                   # used to store the gi's
143                                                   # should be set for each twig really, at least when there are several
144                                                   # the init ensures that special gi's are always the same
145                                                   
146                                                   # gi => index
147                                                   # do NOT use => or the constants become quoted!
148           92                                861   %XML::Twig::gi2index=( PCDATA, 0, CDATA, 1, PI, 2, COMMENT, 3, ENT, 4); 
149                                                   # list of gi's
150           92                                587   @XML::Twig::index2gi=( PCDATA, CDATA, PI, COMMENT, ENT);
151                                                   
152                                                   # gi's under this value are special 
153           92                                242   $XML::Twig::SPECIAL_GI= @XML::Twig::index2gi;
154                                                   
155           92                                777   %XML::Twig::base_ent= ( '>' => '&gt;', '<' => '&lt;', '&' => '&amp;', "'" => '&apos;', '"' => '&quot;',);
156                                                   
157                                                   # now set some aliases
158           92                                347   *find_nodes           = *get_xpath;               # same as XML::XPath
159           92                                346   *findnodes            = *get_xpath;               # same as XML::LibXML
160           92                                615   *getElementsByTagName = *descendants;
161           92                                390   *descendants_or_self  = *descendants;             # valid in XML::Twig, not in XML::Twig::Elt
162           92                                383   *find_by_tag_name     = *descendants;
163           92                                387   *getElementById       = *elt_id;
164           92                                384   *getEltById           = *elt_id;
165           92                                511   *toString             = *sprint;
166                                                   }
167                                                   
168                                                   @ISA = qw(XML::Parser);
169                                                   
170                                                   # fake gi's used in twig_handlers and start_tag_handlers
171                                                   my $ALL    = '_all_';     # the associated function is always called
172                                                   my $DEFAULT= '_default_'; # the function is called if no other handler has been
173                                                   
174                                                   # some defaults
175                                                   my $COMMENTS_DEFAULT= 'keep';
176                                                   my $PI_DEFAULT      = 'keep';
177                                                   
178                                                   
179                                                   # handlers used in regular mode
180                                                   my %twig_handlers=( Start      => \&_twig_start, 
181                                                                       End        => \&_twig_end, 
182                                                                       Char       => \&_twig_char, 
183                                                                       Entity     => \&_twig_entity, 
184                                                                       XMLDecl    => \&_twig_xmldecl, 
185                                                                       Doctype    => \&_twig_doctype, 
186                                                                       Element    => \&_twig_element, 
187                                                                       Attlist    => \&_twig_attlist, 
188                                                                       CdataStart => \&_twig_cdatastart, 
189                                                                       CdataEnd   => \&_twig_cdataend, 
190                                                                       Proc       => \&_twig_pi,
191                                                                       Comment    => \&_twig_comment,
192                                                                       Default    => \&_twig_default,
193                                                                       ExternEnt  => \&_twig_extern_ent,
194                                                         );
195                                                   
196                                                   # handlers used when twig_roots is used and we are outside of the roots
197                                                   my %twig_handlers_roots=
198                                                     ( Start      => \&_twig_start_check_roots, 
199                                                       End        => \&_twig_end_check_roots, 
200                                                       Doctype    => \&_twig_doctype, 
201                                                       Char       => undef, Entity     => undef, XMLDecl    => \&_twig_xmldecl, 
202                                                       Element    => undef, Attlist    => undef, CdataStart => undef, 
203                                                       CdataEnd   => undef, Proc       => undef, Comment    => undef, 
204                                                       Proc       => \&_twig_pi_check_roots,
205                                                       Default    =>  sub {}, # hack needed for XML::Parser 2.27
206                                                       ExternEnt  => \&_twig_extern_ent,
207                                                     );
208                                                   
209                                                   # handlers used when twig_roots and print_outside_roots are used and we are
210                                                   # outside of the roots
211                                                   my %twig_handlers_roots_print_2_30=
212                                                     ( Start      => \&_twig_start_check_roots, 
213                                                       End        => \&_twig_end_check_roots, 
214                                                       Char       => \&_twig_print, 
215                                                       Entity     => \&_twig_print_entity, 
216                                                       ExternEnt  => \&_twig_print_entity,
217                                                       DoctypeFin => \&_twig_doctype_fin_print,
218                                                       XMLDecl    => sub { _twig_xmldecl( @_); _twig_print( @_); },
219                                                       Doctype   =>  \&_twig_print_doctype, # because recognized_string is broken here
220                                                       # Element    => \&_twig_print, Attlist    => \&_twig_print, 
221                                                       CdataStart => \&_twig_print, CdataEnd   => \&_twig_print, 
222                                                       Proc       => \&_twig_pi_check_roots, Comment    => \&_twig_print, 
223                                                       Default    => \&_twig_print_check_doctype,
224                                                       ExternEnt  => \&_twig_extern_ent,
225                                                     );
226                                                   
227                                                   # handlers used when twig_roots, print_outside_roots and keep_encoding are used
228                                                   # and we are outside of the roots
229                                                   my %twig_handlers_roots_print_original_2_30=
230                                                     ( Start      => \&_twig_start_check_roots, 
231                                                       End        => \&_twig_end_check_roots, 
232                                                       Char       => \&_twig_print_original, 
233                                                       # I have no idea why I should not be using this handler!
234                                                       Entity     => \&_twig_print_entity, 
235                                                       ExternEnt  => \&_twig_print_entity,
236                                                       DoctypeFin => \&_twig_doctype_fin_print,
237                                                       XMLDecl    => sub { _twig_xmldecl( @_); _twig_print_original( @_) }, 
238                                                       Doctype    => \&_twig_print_original_doctype,  # because original_string is broken here
239                                                       Element    => \&_twig_print_original, Attlist   => \&_twig_print_original,
240                                                       CdataStart => \&_twig_print_original, CdataEnd  => \&_twig_print_original,
241                                                       Proc       => \&_twig_pi_check_roots, Comment   => \&_twig_print_original,
242                                                       Default    => \&_twig_print_original_check_doctype, 
243                                                     );
244                                                   
245                                                   # handlers used when twig_roots and print_outside_roots are used and we are
246                                                   # outside of the roots
247                                                   my %twig_handlers_roots_print_2_27=
248                                                     ( Start      => \&_twig_start_check_roots, 
249                                                       End        => \&_twig_end_check_roots, 
250                                                       Char       => \&_twig_print, 
251                                                       # if the Entity handler is set then it prints the entity declaration
252                                                       # before the entire internal subset (including the declaration!) is output
253                                                       Entity     => sub {},
254                                                       XMLDecl    => \&_twig_print, Doctype    => \&_twig_print, 
255                                                       CdataStart => \&_twig_print, CdataEnd   => \&_twig_print, 
256                                                       Proc       => \&_twig_pi_check_roots, Comment    => \&_twig_print, 
257                                                       Default    => \&_twig_print, 
258                                                       ExternEnt  => \&_twig_extern_ent,
259                                                     );
260                                                   
261                                                   # handlers used when twig_roots, print_outside_roots and keep_encoding are used
262                                                   # and we are outside of the roots
263                                                   my %twig_handlers_roots_print_original_2_27=
264                                                     ( Start      => \&_twig_start_check_roots, 
265                                                       End        => \&_twig_end_check_roots, 
266                                                       Char       => \&_twig_print_original, 
267                                                       # for some reason original_string is wrong here 
268                                                       # this can be a problem if the doctype includes non ascii characters
269                                                       XMLDecl    => \&_twig_print, Doctype    => \&_twig_print,
270                                                       # if the Entity handler is set then it prints the entity declaration
271                                                       # before the entire internal subset (including the declaration!) is output
272                                                       Entity     => sub {}, 
273                                                       #Element    => undef, Attlist   => undef,
274                                                       CdataStart => \&_twig_print_original, CdataEnd  => \&_twig_print_original,
275                                                       Proc       => \&_twig_pi_check_roots, Comment   => \&_twig_print_original,
276                                                       Default    => \&_twig_print, #  _twig_print_original does not work
277                                                       ExternEnt  => \&_twig_extern_ent,
278                                                     );
279                                                   
280                                                   
281                                                   my %twig_handlers_roots_print= $parser_version > 2.27 
282                                                                                  ? %twig_handlers_roots_print_2_30 
283                                                                                  : %twig_handlers_roots_print_2_27; 
284                                                   my %twig_handlers_roots_print_original= $parser_version > 2.27 
285                                                                                  ? %twig_handlers_roots_print_original_2_30 
286                                                                                  : %twig_handlers_roots_print_original_2_27; 
287                                                   
288                                                   
289                                                   # handlers used when the finish_print method has been called
290                                                   my %twig_handlers_finish_print=
291                                                     ( Start      => \&_twig_print, 
292                                                       End        => \&_twig_print, Char       => \&_twig_print, 
293                                                       Entity     => \&_twig_print, XMLDecl    => \&_twig_print, 
294                                                       Doctype    => \&_twig_print, Element    => \&_twig_print, 
295                                                       Attlist    => \&_twig_print, CdataStart => \&_twig_print, 
296                                                       CdataEnd   => \&_twig_print, Proc       => \&_twig_print, 
297                                                       Comment    => \&_twig_print, Default    => \&_twig_print, 
298                                                       ExternEnt  => \&_twig_extern_ent,
299                                                     );
300                                                   
301                                                   # handlers used when the finish_print method has been called and the keep_encoding
302                                                   # option is used
303                                                   my %twig_handlers_finish_print_original=
304                                                     ( Start      => \&_twig_print_original, End      => \&_twig_print_end_original, 
305                                                       Char       => \&_twig_print_original, Entity   => \&_twig_print_original, 
306                                                       XMLDecl    => \&_twig_print_original, Doctype  => \&_twig_print_original, 
307                                                       Element    => \&_twig_print_original, Attlist  => \&_twig_print_original, 
308                                                       CdataStart => \&_twig_print_original, CdataEnd => \&_twig_print_original, 
309                                                       Proc       => \&_twig_print_original, Comment  => \&_twig_print_original, 
310                                                       Default    => \&_twig_print_original, 
311                                                     );
312                                                   
313                                                   # handlers used within ignored elements
314                                                   my %twig_handlers_ignore=
315                                                     ( Start      => \&_twig_ignore_start, 
316                                                       End        => \&_twig_ignore_end, 
317                                                       Char       => undef, Entity     => undef, XMLDecl    => undef, 
318                                                       Doctype    => undef, Element    => undef, Attlist    => undef, 
319                                                       CdataStart => undef, CdataEnd   => undef, Proc       => undef, 
320                                                       Comment    => undef, Default    => undef,
321                                                       ExternEnt  => undef,
322                                                     );
323                                                   
324                                                   
325                                                   # those handlers are only used if the entities are NOT to be expanded
326                                                   my %twig_noexpand_handlers= ( ExternEnt => undef, Default => \&_twig_default );
327                                                   
328                                                   my @saved_default_handler;
329                                                   
330                                                   my $ID= 'id'; # default value, set by the Id argument
331                                                   
332                                                   # all allowed options
333                                                   %valid_option=
334                                                       ( # XML::Twig options
335                                                         TwigHandlers          => 1, Id                    => 1,
336                                                         TwigRoots             => 1, TwigPrintOutsideRoots => 1,
337                                                         StartTagHandlers      => 1, EndTagHandlers        => 1,
338                                                         ForceEndTagHandlersUsage => 1,
339                                                         DoNotChainHandlers    => 1,
340                                                         IgnoreElts            => 1,
341                                                         Index                 => 1,
342                                                         CharHandler           => 1, 
343                                                         TopDownHandlers       => 1,
344                                                         KeepEncoding          => 1, DoNotEscapeAmpInAtts  => 1,
345                                                         ParseStartTag         => 1, KeepAttsOrder         => 1,
346                                                         LoadDTD               => 1, DTDHandler            => 1,
347                                                         DoNotOutputDTD        => 1, NoProlog              => 1,
348                                                         ExpandExternalEnts    => 1,
349                                                         DiscardSpaces         => 1, KeepSpaces            => 1, 
350                                                         DiscardSpacesIn       => 1, KeepSpacesIn          => 1, 
351                                                         PrettyPrint           => 1, EmptyTags             => 1, 
352                                                         EscapeGt              => 1,
353                                                         Quote                 => 'double',
354                                                         Comments              => 1, Pi                    => 1, 
355                                                         OutputFilter          => 1, InputFilter           => 1,
356                                                         OutputTextFilter      => 1, 
357                                                         OutputEncoding        => 1, 
358                                                         RemoveCdata           => 1,
359                                                         EltClass              => 1,
360                                                         MapXmlns              => 1, KeepOriginalPrefix    => 1,
361                                                         SkipMissingEnts       => 1,
362                                                         # XML::Parser options
363                                                         ErrorContext          => 1, ProtocolEncoding      => 1,
364                                                         Namespaces            => 1, NoExpand              => 1,
365                                                         Stream_Delimiter      => 1, ParseParamEnt         => 1,
366                                                         NoLWP                 => 1, Non_Expat_Options     => 1,
367                                                         Xmlns                 => 1,
368                                                       );
369                                                   
370                                                   # predefined input and output filters
371           92                   92           758   use vars qw( %filter);
              92                                190   
              92                                863   
372                                                   %filter= ( html       => \&html_encode,
373                                                              safe       => \&safe_encode,
374                                                              safe_hex   => \&safe_encode_hex,
375                                                            );
376                                                   
377                                                   
378                                                   # trigger types (used to sort them)
379                                                   my ($XPATH_TRIGGER, $REGEXP_TRIGGER, $LEVEL_TRIGGER)=(1..3);
380                                                   
381                                                   sub new
382         2776                 2776        473582     { my ($class, %args) = @_;
383         2776                               7112       my $handlers;
384                                                   
385                                                       # change all nice_perlish_names into nicePerlishNames
386         2776                              13455       %args= _normalize_args( %args);
387                                                   
388                                                       # check options
389         2776    100                       16524       unless( $args{MoreOptions})
390         2775                              11985         { foreach my $arg (keys %args)
391         5069    100                       25213           { carp "invalid option $arg" unless $valid_option{$arg}; }
392                                                         }
393                                                        
394                                                       # a twig is really an XML::Parser
395                                                       # my $self= XML::Parser->new(%args);
396         2776                               6545       my $self;
397         2776                              20808       $self= XML::Parser->new(%args);   
398                                                   
399         2776                             292246       bless $self, $class;
400                                                   
401         2776                              13234       $self->{_twig_context_stack}= [];
402                                                   
403         2776    100                       13211       if( exists $args{TwigHandlers})
404          162                                484         { $handlers= $args{TwigHandlers};
405          162                                887           $self->setTwigHandlers( $handlers);
406          156                                673           delete $args{TwigHandlers};
407                                                         }
408                                                   
409                                                       # take care of twig-specific arguments
410         2770    100                       10191       if( exists $args{StartTagHandlers})
411           23                                139         { $self->setStartTagHandlers( $args{StartTagHandlers});
412           23                                 91           delete $args{StartTagHandlers};
413                                                         }
414                                                   
415         2770    100                        9109       if( exists $args{DoNotChainHandlers})
416            1                                  5         { $self->{twig_do_not_chain_handlers}=  $args{DoNotChainHandlers}; }
417                                                   
418         2770    100                        9110       if( exists $args{IgnoreElts})
419                                                         { # change array to hash so you can write ignore_elts => [ qw(foo bar baz)]
420   ***      4     50                          25           if( isa( $args{IgnoreElts}, 'ARRAY')) { $args{IgnoreElts}= { map { $_ => 1 } @{$args{IgnoreElts}} }; }
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
421            4                                 24           $self->setIgnoreEltsHandlers( $args{IgnoreElts});
422            4                                 17           delete $args{IgnoreElts};
423                                                         }
424                                                   
425         2770    100                        9134       if( exists $args{Index})
426            2                                  6         { my $index= $args{Index};
427                                                           # we really want a hash name => path, we turn an array into a hash if necessary
428            2    100                           9           if( ref( $index) eq 'ARRAY')
429            1                                  4             { my %index= map { $_ => $_ } @$index;
               2                                 12   
430            1                                  5               $index= \%index;
431                                                             }
432            2                                 15           while( my( $name, $exp)= each %$index)
433            3                    4            31             { $self->setTwigHandler( $exp, sub { push @{$_[0]->{_twig_index}->{$name}}, $_; 1; }); }
               4                                  7   
               4                                 25   
               4                                 21   
434                                                         }
435                                                   
436         2770           100                29797       $self->{twig_elt_class}= $args{EltClass} || 'XML::Twig::Elt';
437         2770    100                       10009       if( exists( $args{EltClass})) { delete $args{EltClass}; }
              66                                244   
438                                                   
439         2770    100                        9427       if( exists( $args{MapXmlns}))
440           15                                 73         { $self->{twig_map_xmlns}=  $args{MapXmlns};
441           15                                 51           $self->{Namespaces}=1;
442           15                                 48           delete $args{MapXmlns};
443                                                         }
444                                                   
445         2770    100                        8893       if( exists( $args{KeepOriginalPrefix}))
446            4                                 19         { $self->{twig_keep_original_prefix}= $args{KeepOriginalPrefix};
447            4                                 11           delete $args{KeepOriginalPrefix};
448                                                         }
449                                                   
450         2770                              11748       $self->{twig_dtd_handler}= $args{DTDHandler};
451         2770                               6955       delete $args{DTDHandler};
452                                                   
453         2770    100                       10825       if( $args{ExpandExternalEnts})
454            4                                 17         { $self->set_expand_external_entities( 1);
455            4                                 18           $self->{twig_expand_external_ents}= $args{ExpandExternalEnts}; 
456            4                                 15           $self->{twig_read_external_dtd}= 1; # implied by ExpandExternalEnts
457            4    100                          20           if( $args{ExpandExternalEnts} == -1) 
458            1                                  3             { $self->{twig_extern_ent_nofail}= 1;
459            1                                 22               $self->setHandlers( ExternEnt => \&_twig_extern_ent_nofail);
460                                                             }
461            4                                 53           delete $args{LoadDTD};
462            4                                 12           delete $args{ExpandExternalEnts};
463                                                         }
464                                                       else
465         2766                              11966         { $self->set_expand_external_entities( 0); }
466                                                   
467   ***   2770     50     33                20840       if( !$args{NoLWP} && ! _use( 'URI') && ! _use( 'URI::File') && ! _use( 'LWP'))
      ***                   33                        
      ***                   33                        
468   ***      0                                  0         { $self->{twig_ext_ent_handler}= \&XML::Parser::initial_ext_ent_handler }
469                                                       else
470         2770                              18465         { $self->{twig_ext_ent_handler}= \&XML::Parser::file_ext_ent_handler }
471                                                   
472         2770    100                       12800       if( $args{DoNotEscapeAmpInAtts})
473            1                                  4         { $self->set_do_not_escape_amp_in_atts( 1); 
474            1                                  4           $self->{twig_do_not_escape_amp_in_atts}=1;
475                                                         }
476                                                       else
477         2769                               9965         { $self->set_do_not_escape_amp_in_atts( 0); 
478         2769                              11158           $self->{twig_do_not_escape_amp_in_atts}=0;
479                                                         }
480                                                   
481                                                       # deal with TwigRoots argument, a hash of elements for which
482                                                       # subtrees will be built (and associated handlers)
483                                                        
484         2770    100                       10362       if( $args{TwigRoots})
485           63                                346         { $self->setTwigRoots( $args{TwigRoots});
486           61                                228           delete $args{TwigRoots}; 
487                                                         }
488                                                       
489         2768    100                        9029       if( $args{EndTagHandlers})
490           11    100    100                   95         { unless ($self->{twig_roots} || $args{ForceEndTagHandlersUsage})
491            1                                  8             { croak "you should not use EndTagHandlers without TwigRoots\n",
492                                                                     "if you want to use it anyway, normally because you have ",
493                                                                     "a start_tag_handlers that calls 'ignore' and you want to ",
494                                                                     "call an ent_tag_handlers at the end of the element, then ",
495                                                                     "pass 'force_end_tag_handlers_usage => 1' as an argument ",
496                                                                     "to new";
497                                                             }
498                                                                     
499           10                                 56           $self->setEndTagHandlers( $args{EndTagHandlers});
500           10                                 39           delete $args{EndTagHandlers};
501                                                         }
502                                                         
503         2767    100                        8926       if( $args{TwigPrintOutsideRoots})
504           34    100                         165         { croak "cannot use TwigPrintOutsideRoots without TwigRoots"
505                                                             unless( $self->{twig_roots});
506                                                           # if the arg is a filehandle then store it
507           33    100                         141           if( _is_fh( $args{TwigPrintOutsideRoots}) )
508           31                                148             { $self->{twig_output_fh}= $args{TwigPrintOutsideRoots}; }
509           33                                206           $self->{twig_default_print}= $args{TwigPrintOutsideRoots};
510                                                         }
511                                                   
512                                                       # space policy
513         2766    100                        8389       if( $args{KeepSpaces})
514           18    100                          74         { croak "cannot use both keep_spaces and discard_spaces" if( $args{DiscardSpaces});
515           17    100                          66           croak "cannot use both keep_spaces and keep_spaces_in" if( $args{KeepSpacesIn});
516           16                                 52           $self->{twig_keep_spaces}=1;
517           16                                 55           delete $args{KeepSpaces}; 
518                                                         }
519         2764    100                        9073       if( $args{DiscardSpaces})
520            2    100                          12         { croak "cannot use both discard_spaces and keep_spaces_in" if( $args{KeepSpacesIn});
521            1                                  4           $self->{twig_discard_spaces}=1; 
522            1                                  3           delete $args{DiscardSpaces}; 
523                                                         }
524         2763    100                        8704       if( $args{KeepSpacesIn})
525            8    100                          35         { croak "cannot use both keep_spaces_in and discard_spaces_in" if( $args{DiscardSpacesIn});
526            7                                 24           $self->{twig_discard_spaces}=1; 
527            7                                 30           $self->{twig_keep_spaces_in}={}; 
528            7                                 13           my @tags= @{$args{KeepSpacesIn}}; 
               7                                 40   
529            7                                 25           foreach my $tag (@tags) { $self->{twig_keep_spaces_in}->{$tag}=1; } 
               9                                 52   
530            7                                 27           delete $args{KeepSpacesIn}; 
531                                                         }
532         2762    100                        8587       if( $args{DiscardSpacesIn})
533            4                                 13         { $self->{twig_keep_spaces}=1; 
534            4                                 13           $self->{twig_discard_spaces_in}={}; 
535            4                                  8           my @tags= @{$args{DiscardSpacesIn}};
               4                                 23   
536            4                                 11           foreach my $tag (@tags) { $self->{twig_discard_spaces_in}->{$tag}=1; } 
               6                                 34   
537            4                                 16           delete $args{DiscardSpacesIn}; 
538                                                         }
539                                                       # discard spaces by default 
540         2762    100                       15588       $self->{twig_discard_spaces}= 1 unless(  $self->{twig_keep_spaces});
541                                                   
542   ***   2762            66                12210       $args{Comments}||= $COMMENTS_DEFAULT;
543         2762    100                       19108       if( $args{Comments} eq 'drop')       { $self->{twig_keep_comments}= 0;    }
               3    100                          11   
                    100                               
544         1873                               6981       elsif( $args{Comments} eq 'keep')    { $self->{twig_keep_comments}= 1;    }
545          885                               3180       elsif( $args{Comments} eq 'process') { $self->{twig_process_comments}= 1; }
546            1                                  7       else { croak "wrong value for comments argument: '$args{Comments}' (should be 'drop', 'keep' or 'process')"; }
547         2761                               8304       delete $args{Comments};
548                                                   
549   ***   2761            66                12000       $args{Pi}||= $PI_DEFAULT;
550         2761    100                       18509       if( $args{Pi} eq 'drop')       { $self->{twig_keep_pi}= 0;    }
               2    100                           6   
                    100                               
551         1875                               6768       elsif( $args{Pi} eq 'keep')    { $self->{twig_keep_pi}= 1;    }
552          883                               3097       elsif( $args{Pi} eq 'process') { $self->{twig_process_pi}= 1; }
553            1                                  7       else { croak "wrong value for pi argument: '$args{Pi}' (should be 'drop', 'keep' or 'process')"; }
554         2760                               7298       delete $args{Pi};
555                                                   
556         2760    100                        8915       if( $args{KeepEncoding})
557                                                         { 
558                                                           # set it in XML::Twig::Elt so print functions know what to do
559          968                               3487           $self->set_keep_encoding( 1); 
560          968           100                10277           $self->{parse_start_tag}= $args{ParseStartTag} || \&_parse_start_tag; 
561          968    100                        3937           delete $args{ParseStartTag} if defined( $args{ParseStartTag}) ;
562          968                               2834           delete $args{KeepEncoding};
563                                                         }
564                                                       else
565         1792                               7341         { $self->set_keep_encoding( 0);  
566         1792    100                        6480           if( $args{ParseStartTag}) 
567            2                                 10             { $self->{parse_start_tag}= $args{ParseStartTag}; }
568                                                           else
569         1790                               5030             { delete $self->{parse_start_tag}; }
570         1792                               4376           delete $args{ParseStartTag};
571                                                         }
572                                                   
573         2760    100                        8890       if( $args{OutputFilter})
574            5                                 24         { $self->set_output_filter( $args{OutputFilter}); 
575            5                                 16           delete $args{OutputFilter};
576                                                         }
577                                                       else
578         2755                              10064         { $self->set_output_filter( 0); }
579                                                   
580         2760    100                        9651       if( $args{RemoveCdata})
581            1                                  5         { $self->set_remove_cdata( $args{RemoveCdata}); 
582            1                                  3           delete $args{RemoveCdata}; 
583                                                         }
584                                                       else
585         2759                               9641         { $self->set_remove_cdata( 0); }
586                                                   
587         2760    100                        9553       if( $args{OutputTextFilter})
588            5                                 22         { $self->set_output_text_filter( $args{OutputTextFilter}); 
589            5                                 17           delete $args{OutputTextFilter};
590                                                         }
591                                                       else
592         2755                               9405         { $self->set_output_text_filter( 0); }
593                                                   
594                                                   
595         2760    100                        9355       if( exists $args{KeepAttsOrder})
596            7                                 34         { $self->{keep_atts_order}= $args{KeepAttsOrder};
597            7    100                          23           if( _use( 'Tie::IxHash'))
598            6                                 31             { $self->set_keep_atts_order(  $self->{keep_atts_order}); }
599                                                           else 
600            1                                  4             { croak "Tie::IxHash not available, option keep_atts_order not allowed"; }
601                                                         }
602                                                       else
603         2753                               9228         { $self->set_keep_atts_order( 0); }
604                                                   
605                                                   
606         2759    100                       10753       if( $args{PrettyPrint})    { $self->set_pretty_print( $args{PrettyPrint}); }
              42                                258   
607   ***   2759     50                        9008       if( $args{EscapeGt})       { $self->escape_gt( $args{EscapeGt});           }
      ***      0                                  0   
608         2759    100                        8286       if( $args{Quote})          { $self->set_quote( $args{Quote});              } 
               1                                  5   
609         2759    100                        8071       if( $args{EmptyTags})      { $self->set_empty_tag_style( $args{EmptyTags}) }
              12                                 50   
610                                                   
611         2759    100                        8151       if( exists $args{Id})      { $ID= $args{Id};                     delete $args{ID};             }
               1                                  4   
               1                                  3   
612         2759    100                        8307       if( $args{NoProlog})       { $self->{no_prolog}= 1;              delete $args{NoProlog};       }
               3                                 12   
               3                                 10   
613         2759    100                        8160       if( $args{DoNotOutputDTD}) { $self->{no_dtd_output}= 1;          delete $args{DoNotOutputDTD}; }
               2                                  9   
               2                                  7   
614         2759    100                        8619       if( $args{LoadDTD})        { $self->{twig_read_external_dtd}= 1; delete $args{LoadDTD};        }
               9                                 33   
               9                                 24   
615         2759    100                        8722       if( $args{CharHandler})    { $self->setCharHandler( $args{CharHandler}); delete $args{CharHandler}; }
               1                                  7   
               1                                  3   
616                                                   
617         2759    100                        7930       if( $args{InputFilter})    { $self->set_input_filter(  $args{InputFilter}); delete  $args{InputFilter}; }
               3                                 20   
               1                                  5   
618         2757    100                        8483       if( $args{NoExpand})       { $self->setHandlers( %twig_noexpand_handlers); $self->{twig_no_expand}=1; }
               1                                  8   
               1                                 69   
619         2757    100                        9816       if( my $output_encoding= $args{OutputEncoding}) { $self->set_output_encoding( $output_encoding); delete $args{OutputFilter}; }
               2                                 10   
               2                                  6   
620                                                   
621         2757    100                        9877       if( my $tdh= $args{TopDownHandlers}) { $self->{twig_tdh}=1; delete $args{TopDownHandlers}; }
               4                                 12   
               4                                 12   
622                                                   
623                                                       # set handlers
624         2757    100                        9158       if( $self->{twig_roots})
625           61    100                         223         { if( $self->{twig_default_print})
626           33    100                         120             { if( $self->{twig_keep_encoding})
627            7                                113                 { $self->setHandlers( %twig_handlers_roots_print_original); }
628                                                               else
629           26                                405                 { $self->setHandlers( %twig_handlers_roots_print);  }
630                                                             }
631                                                           else
632           28                                422             { $self->setHandlers( %twig_handlers_roots); }
633                                                         }
634                                                       else
635         2696                              38030         { $self->setHandlers( %twig_handlers); }
636                                                   
637                                                       # XML::Parser::Expat does not like these handler to be set. So in order to 
638                                                       # use the various sets of handlers on XML::Parser or XML::Parser::Expat
639                                                       # objects when needed, these ones have to be set only once, here, at 
640                                                       # XML::Parser level
641         2757                             933544       $self->setHandlers( Init => \&_twig_init, Final => \&_twig_final);
642                                                   
643         2757                             186696       $self->{twig_entity_list}= XML::Twig::Entity_list->new; 
644                                                   
645         2757                              12193       $self->{twig_id}= $ID; 
646         2757                               9743       $self->{twig_stored_spaces}='';
647                                                   
648         2757                              10111       $self->{twig_autoflush}= 1; # auto flush by default
649                                                   
650         2757                               8755       $self->{twig}= $self;
651         2757    100                        9966       if( $weakrefs) { weaken( $self->{twig}); }
            2756                              18383   
652                                                   
653         2757                              15833       return $self;
654                                                     }
655                                                   
656                                                   sub parse
657                                                     {
658         2815                 2815         33423       my $t= shift;
659                                                       # if called as a class method, calls nparse, which creates the twig then parses it
660   ***   2815    100     66                34629       if( !ref( $t) || !isa( $t, 'XML::Twig')) { return $t->nparse( @_); }
              35                                177   
661                                                   
662                                                       # requires 5.006 at least (or the ${^UNICODE} causes a problem)                                       # > perl 5.5
663                                                       # trap underlying bug in IO::Handle (see RT #17500)                                                   # > perl 5.5
664                                                       # croak if perl 5.8+, -CD (or PERL_UNICODE set to D) and parsing a pipe                               # > perl 5.5
665   ***   2780     50     33                36144       if( $]>=5.008 && ${^UNICODE} && (${^UNICODE} & 24) && isa( $_[0], 'GLOB') && -p $_[0] )               # > perl 5.5
      ***                   33                        
      ***                   33                        
      ***                   33                        
666   ***      0                                  0         { croak   "cannot parse the output of a pipe when perl is set to use the UTF8 perlIO layer\n"       # > perl 5.5
667                                                                 . "set the environment variable PERL_UNICODE or use the -C option (see perldoc perlrun)\n"  # > perl 5.5
668                                                                 . "not to include 'D'";                                                                     # > perl 5.5
669                                                         }                                                                                                   # > perl 5.5
670         2780                               6953       $t= eval { $t->SUPER::parse( @_); }; 
            2780                              34290   
671         2780                              93469       return _checked_parse_result( $t, $@);
672                                                     }
673                                                   
674                                                   sub parsefile
675           27                   27            96     { my $t= shift;
676           27                                 84       $t= eval { $t->SUPER::parsefile( @_); };
              27                                656   
677           27                                336       return _checked_parse_result( $t, $@);
678                                                     }
679                                                   
680                                                   sub _checked_parse_result
681         2807                 2807         12903     { my( $t, $returned)= @_;
682         2807    100                       10158       if( !$t)
683   ***     22    100     66                  197         { if( isa( $returned, 'XML::Twig') && $returned->{twig_finish_now})
684            6                                 14             { $t= $returned;
685            6                                 18               delete $t->{twig_finish_now};
686            6                                 23               return $t->_twig_final;
687                                                             }
688                                                           else
689           16                                 73             { _croak( $returned, 0); }
690                                                         }
691         2785                              16811       return $t;
692                                                     }
693                                                   
694                                                   sub finish_now
695            6                    6            51     { my $t= shift;
696            6                                 24       $t->{twig_finish_now}=1;
697            6                                  9       die $t;    
698                                                     }
699                                                   
700                                                   
701            3                    3            22   sub parsefile_inplace      { shift->_parse_inplace( parsefile      => @_); }
702            3                    3            21   sub parsefile_html_inplace { shift->_parse_inplace( parsefile_html => @_); }
703                                                   
704                                                   sub _parse_inplace
705            6                    6           126     { my( $t, $method, $file, $suffix)= @_;
706   ***      6     50                          23       _use( 'File::Temp') || croak "need File::Temp to use inplace methods\n";
707            6                                 19       _use( 'File::Basename');
708                                                   
709                                                   
710            6                                 74       my $tmpdir= dirname( $file);
711            6                               1378       my( $tmpfh, $tmpfile)= File::Temp::tempfile( DIR => $tmpdir);
712            6                                 38       my $original_fh= select $tmpfh;
713                                                   
714   ***      6     50     33                   72       unless( $t->{twig_keep_encoding} || $] < 5.006) 
715   ***      6     50                       85092         { if( grep /useperlio=define/, `$^X -V`) # we can only use binmode :utf8 if perl was compiled with useperlio
716            6                                105             { binmode( $tmpfh, ":utf8" ); }
717                                                         }
718                                                   
719            6                                116       $t->$method( $file);
720                                                   
721            6                                 55       select $original_fh;
722            6                                491       close $tmpfh;
723            6                                125       my $mode= (stat( $file))[2] & 07777;
724   ***      6     50                         100       chmod $mode, $tmpfile or croak "cannot change temp file mode to $mode: $!";
725                                                   
726            6    100                          20       if( $suffix) 
727            4                                  8         { my $backup;
728            4    100                          31           if( $suffix=~ m{\*}) { ($backup = $suffix) =~ s/\*/$file/g; }
               2                                 28   
729            2                                 12           else                 { $backup= $file . $suffix; }
730                                                             
731   ***      4     50                         126           rename( $file, $backup) or croak "cannot backup initial file ($file) to $backup: $!"; 
732                                                         }
733   ***      6     50                         232       rename( $tmpfile, $file) or croak "cannot rename temp file ($tmpfile) to initial file ($file): $!";
734                                                   
735            6                                 15       return $t;
736                                                     }
737                                                       
738                                                    
739                                                   sub parseurl
740           11                   11            33     { my $t= shift;
741           11                                 61       $t->_parseurl( 0, @_);
742                                                     }
743                                                   
744                                                   sub safe_parseurl
745            9                    9            47     { my $t= shift;
746            9                                 44       $t->_parseurl( 1, @_);
747                                                     }
748                                                   
749                                                   sub safe_parsefile_html
750            1                    1             4     { my $t= shift;
751            1                                  2       eval { $t->parsefile_html( @_); };
               1                                  5   
752   ***      1     50      0                    8       return $@ ? $t->_reset_twig &&  0 : $t;
753                                                     }
754                                                   
755                                                   sub safe_parseurl_html
756            1                    1             3     { my $t= shift;
757   ***      1     50                           5       _use( 'LWP::Simple') or croak "missing LWP::Simple"; 
758            1                                  4       eval { $t->parse_html( LWP::Simple::get( shift()), @_); } ;
               1                                  6   
759   ***      1     50      0                    9       return $@ ? $t->_reset_twig &&  0 : $t;
760                                                     }
761                                                   
762                                                   # uses eval to catch the parser's death
763                                                   sub safe_parse_html
764            1                    1             3     { my $t= shift;
765            1                                  3       eval { $t->parse_html( @_); } ;
               1                                  5   
766   ***      1     50      0                    8       return $@ ? $t->_reset_twig &&  0 : $t;
767                                                     }
768                                                   
769                                                   sub parsefile_html
770            5                    5            34     { my $t= shift;
771            5                                 34       my $file= shift;
772            5    100                          79       my $indent= $t->{ErrorContext} ? 1 : 0;
773            5                                 49       $t->set_empty_tag_style( 'html');
774            5                                 54       $t->parse( _html2xml( _slurp( $file), { indent => $indent }), @_);
775            5                                 29       return $t;
776                                                     }
777                                                   
778                                                   sub parse_html
779           15                   15            59     { my $t= shift;
780           15                                170       my $content= shift;
781   ***     15     50                          78       my $indent= $t->{ErrorContext} ? 1 : 0;
782           15                                 63       $t->set_empty_tag_style( 'html');
783           15    100                         911       $t->parse( _html2xml( isa( $content, 'GLOB') ? _slurp_fh( $content) : $content, { indent => $indent }), @_);
784           14                                 90       return $t;
785                                                     }
786                                                   
787                                                   sub xparse
788         1859                 1859          4958     { my $t= shift;
789         1859                               4290       my $to_parse= $_[0];
790         1859    100                       17724       if( isa( $to_parse, 'GLOB'))             { $t->parse( @_);                 }
               1    100                           5   
                    100                               
                    100                               
                    100                               
791         1847    100                       12000       elsif( $to_parse=~ m{^\s*<})             { $to_parse=~ m{<html}i ? $t->_parse_as_xml_or_html( @_)
792                                                                                                                        : $t->parse( @_);                 
793                                                                                                }
794            2    100                           9       elsif( $to_parse=~ m{^\w+://.*\.html?$}) { _use( 'LWP::Simple') or croak "missing LWP::Simple"; 
795            1                                  6                                                  $t->_parse_as_xml_or_html( LWP::Simple::get( shift()), @_);
796                                                                                                }
797            2    100                           7       elsif( $to_parse=~ m{^\w+://})           { _use( 'LWP::Simple') or croak "missing LWP::Simple";
798            1                                  5                                                  my $doc= LWP::Simple::get( shift);
799            1                                 12                                                  my $xml_parse_ok= $t->safe_parse( $doc, @_);
800   ***      1     50                           4                                                  if( $xml_parse_ok)
801            1                                  8                                                    { return $xml_parse_ok; }
802                                                                                                  else
803   ***      0                                  0                                                    { my $diag= $@;
804   ***      0      0                           0                                                      if( $doc=~ m{<html}i)
805   ***      0                                  0                                                        { $t->parse_html( $doc, @_); }
806                                                                                                       else
807   ***      0                                  0                                                         { croak $diag; }
808                                                                                                    }
809                                                                                                }
810            2                                 10       elsif( $to_parse=~ m{\.html?$})          { my $content= _slurp( shift);
811            2                                 11                                                  $t->_parse_as_xml_or_html( $content, @_); 
812                                                                                                }
813            5                                 25       else                                     { $t->parsefile( @_);             }
814                                                     }
815                                                   
816                                                   sub _parse_as_xml_or_html
817           10                   10            43     { my $t= shift; 
818           10    100                          43       if( _is_well_formed_xml( $_[0]))
819            2                                  9         { $t->parse( @_) }
820                                                       else
821            8                                 35         { my $html= _html2xml( $_[0]);
822            8    100                          37           if( _is_well_formed_xml( $html))
823            4                                 24             { $t->parse( $html); }
824                                                           else
825            4                                 16             { croak $@; }
826                                                         }
827                                                     }  
828                                                       
829                                                   { my $parser;
830                                                     sub _is_well_formed_xml
831   ***     18            66     18            79       { $parser ||= XML::Parser->new;
832           18                                412         eval { $parser->parse( $_[0]); };
              18                                 95   
833           18    100                         256         return $@ ? 0 : 1;
834                                                       }
835                                                   }
836                                                   
837                                                   sub nparse
838         1859                 1859         48540     { my $class= shift;
839         1859                               4760       my $to_parse= pop;
840         1859                               8023       $class->new( @_)->xparse( $to_parse);
841                                                     }
842                                                   
843            1                    1            26   sub nparse_pp   { shift()->nparse( pretty_print => 'indented', @_); }
844            5                    5          1320   sub nparse_e    { shift()->nparse( error_context => 1,         @_); }
845            1                    1            27   sub nparse_ppe  { shift()->nparse( pretty_print => 'indented', error_context => 1, @_); }
846                                                   
847                                                   
848                                                   sub _html2xml
849           28                   28           293     { my( $html, $options)= @_;
850           28    100                         223       _use( 'HTML::TreeBuilder', '3.13') or croak "cannot parse HTML: missing HTML::TreeBuilder v >= 3.13\n"; 
851           27                                268       my $tree= HTML::TreeBuilder->new;
852           27                                145       $tree->ignore_ignorable_whitespace( 0); 
853           27                                113       $tree->no_space_compacting( 1);
854           27                                107       $tree->store_comments( 1);
855           27                                121       $tree->store_pis(1); 
856           27                                126       $tree->parse( $html);
857           27                                237       $tree->eof;
858                                                   
859           27                                153       my $xml= $tree->as_XML;
860           27                                147       _fix_xml( $tree, \$xml);
861           27                                168       $tree->delete;
862                                                   
863           27    100                         130       if( $options->{indent}) { _indent_xhtml( \$xml); }
               1                                 15   
864           27                                166       $tree->delete;
865           27                               4953       $xml=~ s{\s+$}{}s; # trim end
866           27                               1144       return $xml;
867                                                     }
868                                                   
869                                                   { my %xml_parser_encoding;
870                                                     sub _fix_xml
871           27                   27            99       { my( $tree, $xml)= @_; # $xml is a ref to the xml string
872                                                   
873           27                                 61         my $max_tries=5;
874           27                                 60         my $add_decl;
875                                                   
876           27           100                  201         while( ! _check_xml( $xml) && $max_tries--)
877                                                           { 
878                                                             # a couple of fixes for weird HTML::TreeBuilder errors
879   ***     21     50                         193             if( $@=~ m{^\s*xml declaration not at start of external entity})
      ***            50                               
880   ***      0                                  0               { $$xml=~ s{<\?xml version.*\?>}{}; 
881                                                                 #warn " fixed xml declaration in the wrong place\n";
882                                                               }
883                                                             elsif( $@=~ m{^\s*not well-formed \(invalid token\)})
884           21                                 68               { my $encoding= _encoding_from_meta( $tree);
885           21    100                          69                 unless( keys %xml_parser_encoding) { %xml_parser_encoding= _xml_parser_encodings(); }
               2                                  7   
886                                                   
887           21    100                          89                 if( ! $add_decl)
888   ***      5     50      0                   18                   { if( $xml_parser_encoding{$encoding})
      ***             0      0                        
      ***             0                               
889            5                                 11                       { $add_decl=1; }
890                                                                     elsif( $encoding eq 'euc-jp' && $xml_parser_encoding{'x-euc-jp-jisx0221'})
891   ***      0                                  0                       { $encoding="x-euc-jp-jisx0221"; $add_decl=1;}
      ***      0                                  0   
892                                                                     elsif( $encoding eq 'shift-jis' && $xml_parser_encoding{'x-sjis-jisx0221'})
893   ***      0                                  0                       { $encoding="x-sjis-jisx0221";   $add_decl=1;}
      ***      0                                  0   
894                                                   
895   ***      5     50                          13                     if( $add_decl) 
896            5                                 66                       { $$xml=~ s{^(<\?xml.*?\?>)?}{<?xml version="1.0" encoding="$encoding"?>}s;
897                                                                         #warn "  added decl (encoding $encoding)\n";
898                                                                       }
899                                                                     else
900   ***      0                                  0                       { $$xml=~ s{^(<\?xml.*?\?>)?}{}s;
901                                                                         #warn "  converting to utf8 from $encoding\n";
902   ***      0                                  0                         $$xml= _to_utf8( $encoding, $$xml);
903                                                                       }
904                                                                   }
905                                                                 else
906           16                                178                   { $$xml=~ s{^(<\?xml.*?\?>)?}{}s;
907                                                                     #warn "  converting to utf8 from $encoding\n";
908           16                                 54                     $$xml= _to_utf8( $encoding, $$xml);
909                                                                   }
910                                                               }
911                                                         }
912                                                     }
913                                                   
914                                                     sub _xml_parser_encodings
915            2                    2             7       { my @encodings=( 'iso-8859-1'); # this one is included by default, there is no map for it in @INC
916            2                                  7         foreach my $inc (@INC)
917           25                               3163           { push @encodings, map { basename( $_, '.enc') } glob( File::Spec->catdir( $inc => XML => Parser => Encodings => '*.enc')); }
              90                              15167   
918            2                                290         return map { $_ => 1 } @encodings;
              92                                351   
919                                                       }
920                                                   }
921                                                   
922                                                   sub _check_xml
923           48                   48           142     { my( $xml)= @_; # $xml is a ref to the xml string
924           48                                109       my $ok= eval { XML::Parser->new->parse( $$xml); };
              48                                325   
925                                                       #if( $ok) { warn "  parse OK\n"; }
926           48                               1404       return $ok;
927                                                     }
928                                                   
929                                                   sub _encoding_from_meta
930           21                   21            64     { my( $tree)= @_; 
931           21                                 52       my $enc="iso-8859-1";
932           21                                 92       my @meta= $tree->find( 'meta');
933           21                                 82       foreach my $meta (@meta)
934   ***     10     50     33                   78         { if(    $meta->{'http-equiv'} && ($meta->{'http-equiv'} =~ m{^\s*content-type\s*}i)
      ***                   33                        
      ***                   33                        
935                                                               && $meta->{content}      && ($meta->{content}      =~ m{^\s*text/html\s*;\s*charset\s*=\s*(\S*)\s*}i)
936                                                             )
937   ***      0                                  0             { $enc= lc $1;
938                                                               #warn "  encoding from meta tag is '$enc'\n";
939   ***      0                                  0               last;
940                                                             }
941                                                         }
942           21                                 82       return $enc;
943                                                     }
944                                                   
945                                                   { sub _to_utf8 
946           16                   16           150       { my( $encoding, $string)= @_;
947           16                                135         local $SIG{__DIE__};
948   ***     16     50      0                   54         if( _use(  'Encode')) 
      ***             0                               
      ***             0                               
949           16                                 66           { Encode::from_to( $string, $encoding => 'utf8', 0x0400); } # 0x0400 is Encode::FB_XMLCREF
950                                                         elsif( _use( 'Text::Iconv'))
951   ***      0                                  0           { my $converter =  eval { Text::Iconv->new( $encoding => "utf8") };
      ***      0                                  0   
952   ***      0      0                           0             if( $converter) {  $string= $converter->convert( $string); }
      ***      0                                  0   
953                                                           }
954                                                         elsif( _use( 'Unicode::Map8') && _use( 'Unicode::String'))
955   ***      0                                  0           { my $map= Unicode::Map8->new( $encoding); 
956   ***      0                                  0             $string= $map->tou( $string)->utf8;
957                                                           }
958           16                               1616         $string=~ s{[\x00-\x08\x0B\x0C\x0E-\x1F]}{}g; # get rid of control chars, portable in 5.6
959           16                                142       return $string;
960                                                     }
961                                                   }
962                                                   
963                                                   
964                                                   sub _indent_xhtml
965            1                    1             9     { my( $xhtml)= @_; # $xhtml is a ref
966            1                                 11       my %block_tag= map { $_ => 1 } qw( html 
              39                                167   
967                                                                                            head 
968                                                                                              meta title link script base
969                                                                                            body 
970                                                                                              h1 h2 h3 h4 h5 h6 
971                                                                                              p br address  blockquote pre 
972                                                                                              ol ul li  dd dl dt 
973                                                                                              table tr td th tbody tfoot thead  col colgroup caption 
974                                                                                              div frame frameset hr
975                                                                                        ); 
976                                                   
977            1                                 13       my $level=0;
978            1                                 15       $$xhtml=~ s{( (?:<!(?:--.*?-->|[CDATA[.*]]>)) # ignore comments and CDATA sections
979   ***      5     50     33                   62                     | <(\w+)                        # start tag
      ***      5      0      0                   16   
980   ***      5     50                          27                     |(</\(\w+)                      # end tag 
981            5                                 75                   )
982                                                                  }
983   ***      0                                  0                  {
      ***      0                                  0   
984   ***      0                                  0                    if(    $2 && $block_tag{$2})  { my $indent= "  " x $level; 
985                                                                                                    $level++ unless( $2=~ m{/>});
986                                                                                                    "\n$indent<$2"; 
987                                                                                                  }
988                                                                    elsif( $3  && $block_tag{$3}) { $level--; "</$3"; }
989                                                                    else                          { $1; }
990                                                                  }xesg;
991                                                     }
992                                                   
993                                                   
994                                                   sub add_stylesheet
995            2                    2            11     { my( $t, $type, $href)= @_;
996            2                                  7       my %text_type= map { $_ => 1 } qw( xsl css);
               4                                 22   
997            2                                 13       my $ss= $t->{twig_elt_class}->new( '#PI');
998            2    100                           9       if( $text_type{$type}) 
999            1                                  8         { $ss->_set_pi( 'xml-stylesheet', qq{type="text/$type" href="$href"}); }
1000                                                      else
1001           1                                 11         { croak "unsupported style sheet type '$type'"; }
1002                                                        
1003           1                                  4       $t->_add_cpi_outside_of_root( leading_cpi => $ss);
1004           1                                  5       return $t;
1005                                                    }
1006                                                  
1007                                                  { my %used;       # module => 1 if require ok, 0 otherwise
1008                                                    my %disallowed; # for testing, refuses to _use modules in this hash
1009                                                  
1010                                                    sub _disallow_use
1011           5                    5           213       { my( @modules)= @_;
1012           5                                 11         $disallowed{$_}= 1 foreach (@modules);
               5                                 43   
1013                                                      }
1014                                                  
1015                                                    sub _allow_use
1016           4                    4            18       { my( @modules)= @_;
1017           4                                  9         $disallowed{$_}= 0 foreach (@modules);
               4                                 32   
1018                                                      }
1019                                                  
1020                                                    sub _use
1021        2964                 2964         13260       { my( $module, $version)= @_;
1022        2964           100                12564         $version ||= 0;
1023        2964    100                        9326         if( $disallowed{$module})   { return 0; }
               5                                 41   
1024        2959    100                       10412         if( $used{$module})         { return 1; }
            2793                              23227   
1025         166    100                       10763         if( eval "require $module") { import $module; $used{$module}= 1; 
             163                               1669   
             163                               6812   
1026          92                   92           986                                       no strict 'refs';
              92                                207   
              92                                607   
1027  ***    163     50                         353                                       if( ${"${module}::VERSION"} >= $version ) { return 1; }
             163                               1846   
             163                               2250   
1028  ***      0                                  0                                       else                                      { return 0; }
1029                                                                                    }
1030           3                                 12         else                        {                          $used{$module}= 0; return 0; }
               3                                 17   
1031                                                      }
1032                                                  }
1033                                                  
1034                                                  # used to solve the [n] predicates while avoiding getting the entire list
1035                                                  sub _first_n(&$@)        # needs a prototype to accept passing bare blocks
1036         106                  106           300     { my $coderef= shift;
1037         106                                222       my $n= shift;         
1038         106                                176       my $i=0;
1039         106    100                         303       if( $n > 0)
                    100                               
1040          99    100                         309         { foreach (@_)         { if( &$coderef) { $i++; return $_ if( $i == $n); } } }
             121    100                         346   
              35                                 60   
              35                                322   
1041                                                      elsif( $n < 0)
1042           6    100                          19         { foreach (reverse @_) { if( &$coderef) { $i--; return $_ if( $i == $n); } } }
              13    100                          37   
              11                                 21   
              11                                 57   
1043                                                      else
1044           1                                  4         { croak "illegal position number 0"; }
1045          71                                603       return undef;
1046                                                    }
1047                                                  
1048                                                  sub _slurp_uri
1049          10                   10           306     { my( $uri, $base)= @_;
1050          10    100                          91       if( $uri=~ m{^\w+://}) { _use( 'LWP::Simple'); return LWP::Simple::get( $uri); }
               1                                  4   
               1                                  5   
1051           9                                 35       else                   { return _slurp( _based_filename( $uri, $base));        }
1052                                                    }
1053                                                  
1054                                                  sub _based_filename
1055          25                   25           431     { my( $filename, $base)= @_;
1056                                                      # cf. XML/Parser.pm's file_ext_ent_handler
1057  ***     25    100     66                  303       if (defined($base) and not ($filename =~ m{^(?:[\\/]|\w+:)})) 
1058           3                                115             { my $newpath = $base;
1059           3                                 26               $newpath =~ s{[^\\/:]*$}{$filename};
1060           3                                  9               $filename = $newpath;
1061                                                            }
1062          25                                319       return $filename;
1063                                                    }
1064                                                  
1065                                                  sub _slurp
1066          17                   17           170     { my( $filename)= @_;
1067                                                      # use bareword filehandle to stay compatible with real old perl
1068          17    100                         462       open( TWIG_TO_SLURP, "<$filename") or croak "cannot open '$filename': $!"; 
1069          14                                113       local $/= undef;
1070          14                                257       my $content= <TWIG_TO_SLURP>;
1071          14                                101       close TWIG_TO_SLURP;
1072          14                                180       return $content;
1073                                                    }
1074                                                    
1075                                                  sub _slurp_fh
1076           1                    1             3     { my( $fh)= @_;
1077           1                                  7       local $/= undef;
1078           1                                 31       my $content= <$fh>;
1079           1                                 11       return $content;
1080                                                    }    
1081                                                   
1082                                                  # I should really add extra options to allow better configuration of the 
1083                                                  # LWP::UserAgent object
1084                                                  # this method forks (except on VMS!)
1085                                                  #   - the child gets the data and copies it to the pipe,
1086                                                  #   - the parent reads the stream and sends it to XML::Parser
1087                                                  # the data is cut it chunks the size of the XML::Parser::Expat buffer
1088                                                  # the method returns the twig and the status
1089                                                  sub _parseurl
1090          20                   20           120     { my( $t, $safe, $url, $agent)= @_;
1091  ***     20     50                          72       _use( 'LWP') || croak "LWP not available, needed to use parseurl methods";
1092  ***     20     50                         153       if( $^O ne 'VMS')
1093  ***     20     50                         598         { pipe( README, WRITEME) or croak  "cannot create connected pipes: $!";
1094          20    100                      819327           if( my $pid= fork)
1095                                                            { # parent code: parse the incoming file
1096          15                                551               close WRITEME; # no need to write
1097          15    100                         851               my $result= $safe ? $t->safe_parse( \*README) : $t->parse( \*README);
1098          15                                285               close README;
1099          15    100                         237               return $@ ? 0 : $t;
1100                                                            }
1101                                                          else
1102                                                           { # child
1103           5                                583               close README; # no need to read
1104           5                                178               $|=1;
1105  ***      5            66                  530               $agent    ||= LWP::UserAgent->new;
1106           5                                397               my $request  = HTTP::Request->new( GET => $url);
1107                                                              # _pass_url_content is called with chunks of data the same size as
1108                                                              # the XML::Parser buffer 
1109                                                              my $response = $agent->request( $request, 
1110           5                    4           275                                sub { _pass_url_content( \*WRITEME, @_); }, BUFSIZE);
               4                                 92   
1111           5    100                          67               $response->is_success or croak "$url ", $response->message;
1112           4                                 84               close WRITEME;
1113           4                                  9               CORE::exit(); # CORE is there for mod_perl (which redefines exit)
1114                                                            }
1115                                                        } 
1116                                                      else 
1117  ***      0                                  0         { $|=1;
1118  ***      0             0                    0           $agent    ||= LWP::UserAgent->new;
1119  ***      0                                  0           my $request  = HTTP::Request->new( GET => $url);
1120  ***      0                                  0           my $response = $agent->request( $request);
1121  ***      0      0                           0           $response->is_success or croak "$url ", $response->message;
1122  ***      0      0                           0           my $result= $safe ? $t->safe_parse($response->content) : $t->parse($response->content);
1123  ***      0      0                           0           return $@ ? 0 : $t;
1124                                                       }
1125                                                  
1126                                                    }
1127                                                  
1128                                                  # get the (hopefully!) XML data from the URL and 
1129                                                  sub _pass_url_content
1130           4                    4            28     { my( $fh, $data, $response, $protocol)= @_;
1131           4                                  9       print {$fh} $data;
               4                                 53   
1132                                                    }
1133                                                  
1134                                                  sub add_options
1135           1                    1           310     { my %args= map { $_, 1 } @_;
               1                                  6   
1136           1                                  6       %args= _normalize_args( %args);
1137           1                                  6       foreach (keys %args) { $valid_option{$_}++; } 
               1                                  8   
1138                                                    }
1139                                                  
1140  ***      0                    0             0   sub _pretty_print_styles { return XML::Twig::Elt::_pretty_print_styles(); }
1141                                                  
1142                                                  sub _twig_store_internal_dtd
1143                                                   { 
1144                                                     # warn " in _twig_store_internal_dtd...\n"; # DEBUG handler
1145         160                  160           707       my( $p, $string)= @_;
1146         160                                545       my $t= $p->{twig};
1147         160    100                         632       if( $t->{twig_keep_encoding}) { $string= $p->original_string(); }
               3                                 15   
1148         160                                707       $t->{twig_doctype}->{internal} .= $string;
1149         160                                302       return;
1150                                                    }
1151                                                  
1152                                                  sub _twig_stop_storing_internal_dtd
1153                                                     { # warn " in _twig_stop_storing_internal_dtd...\n"; # DEBUG handler
1154          76                   76           251       my $p= shift;
1155  ***     76     50     33                  719       if( @saved_default_handler && defined $saved_default_handler[1])
1156          76                                371         { $p->setHandlers( @saved_default_handler); }
1157                                                      else
1158  ***      0                                  0         { my $t= $p->{twig};
1159  ***      0                                  0           $p->setHandlers( Default => undef);
1160                                                        }
1161          76                               6050       $p->{twig}->{twig_doctype}->{internal}=~ s{^\s*\[}{};
1162          76                                470       $p->{twig}->{twig_doctype}->{internal}=~ s{\]\s*$}{};
1163          76                                164       return;
1164                                                    }
1165                                                  
1166                                                  sub _twig_doctype_fin_print
1167                                                    { # warn " in _twig_doctype_fin_print...\n"; # DEBUG handler
1168          16                   16            64       my( $p)= shift;
1169  ***     16    100     66                  166       if( $p->{twig}->{twig_doctype}->{has_internal} && !$expat_1_95_2) { print ' ]>'; }
               6                                 19   
1170          16                                 30       return;
1171                                                    }
1172                                                      
1173                                                  
1174                                                  sub _normalize_args
1175        7340                 7340         12321     { my %normalized_args;
1176        7340                              32589       while( my $key= shift )
1177        5133                              22873         { $key= join '', map { ucfirst } split /_/, $key;
            6843                              29228   
1178                                                          #$key= "Twig".$key unless( substr( $key, 0, 4) eq 'Twig');
1179        5133                              35544           $normalized_args{$key}= shift ;
1180                                                        }
1181        7340                              43588       return %normalized_args;
1182                                                    }    
1183                                                  
1184  ***   3593    100     66   3593         12885   sub _is_fh { return unless $_[0]; return $_[0] if( isa( $_[0], 'GLOB') || isa( $_[0], 'IO::Scalar')); }
             972    100                        2083   
1185                                                  
1186                                                  sub _set_handler
1187         552                  552          2382     { my( $handlers, $path, $handler)= @_;
1188                                                  
1189         552           100                 6167       my $prev_handler= $handlers->{handlers}->{string}->{$path} || undef;
1190                                                  
1191         552    100    100                 1997          _set_special_handler         ( $handlers, $path, $handler, $prev_handler)
                           100                        
                           100                        
                           100                        
1192                                                      || _set_pi_handler              ( $handlers, $path, $handler, $prev_handler)
1193                                                      || _set_level_handler           ( $handlers, $path, $handler, $prev_handler)
1194                                                      || _set_regexp_handler          ( $handlers, $path, $handler, $prev_handler)
1195                                                      || _set_xpath_handler           ( $handlers, $path, $handler, $prev_handler)
1196                                                      || croak "unrecognized expression in handler: '$path'";
1197                                                  
1198                                                  
1199                                                      # this both takes care of the simple (gi) handlers and store
1200                                                      # the handler code reference for other handlers
1201         546                               3853       $handlers->{handlers}->{string}->{$path}= $handler;
1202                                                  
1203         546                               2762       return $prev_handler;
1204                                                    }
1205                                                  
1206                                                  
1207                                                  sub _set_special_handler
1208         552                  552          2450     { my( $handlers, $path, $handler, $prev_handler)= @_;
1209         552    100                        5660       if( $path =~ m{^\s*($ALL|$DEFAULT|#COMMENT)\s*$}io )
1210          25                                168         { $handlers->{handlers}->{$1}= $handler; 
1211          25                                348           return 1;
1212                                                        }
1213                                                      else 
1214         527                               4859         { return 0; }
1215                                                    }
1216                                                  
1217                                                  sub _set_xpath_handler
1218         512                  512          2151     { my( $handlers, $path, $handler, $prev_handler)= @_;
1219         512    100                        1759       if( my $handler_data= _parse_xpath_handler( $path, $handler))
1220         506                               1995         { _add_handler( $handlers, $handler_data, $path, $prev_handler);
1221         506                               5107           return 1;
1222                                                        }
1223                                                      else 
1224           6                                 62         { return 0; }
1225                                                    }
1226                                                  
1227                                                  sub _add_handler
1228         512                  512          2383     { my( $handlers, $handler_data, $path, $prev_handler)= @_;
1229                                                  
1230         512                               2228       my $tag= $handler_data->{tag};
1231         512    100                        3088       my @handlers= $handlers->{xpath_handler}->{$tag} ? @{$handlers->{xpath_handler}->{$tag}} : ();
             114                                742   
1232                                                  
1233         512    100                        1710       if( $prev_handler) { @handlers= grep { $_->{path} ne $path } @handlers; }
              61                                168   
             151                                782   
1234                                                  
1235         512    100                        2589       push @handlers, $handler_data if( $handler_data->{handler});
1236                                                      
1237                                                  
1238  ***    512    100     50                 1711       @handlers= sort {    (($a->{score}->{type}        || 0)  <=>  ($b->{score}->{type}        || 0))
      ***    249            50                14676   
                           100                        
                           100                        
      ***                   66                        
      ***                   50                        
      ***                   50                        
                           100                        
      ***                   50                        
      ***                   50                        
                           100                        
      ***                   50                        
      ***                   50                        
      ***                   66                        
1239                                                                        || (($b->{score}->{anchored}    || 0)  <=>  ($a->{score}->{anchored}    || 0))
1240                                                                        || (($b->{score}->{steps}       || 0)  <=>  ($a->{score}->{steps}       || 0))
1241                                                                        || (($b->{score}->{predicates}  || 0)  <=>  ($a->{score}->{predicates}  || 0))
1242                                                                        || (($b->{score}->{tests}       || 0)  <=>  ($a->{score}->{tests}       || 0))
1243                                                                        || ($a->{path} cmp $a->{path})
1244                                                                      } @handlers;
1245                                                  
1246         512                               3845       $handlers->{xpath_handler}->{$tag}= \@handlers;
1247                                                    }
1248                                                  
1249                                                  sub _set_pi_handler
1250         527                  527          2521     { my( $handlers, $path, $handler, $prev_handler)= @_;
1251                                                      # PI conditions ( '?target' => \&handler or '?' => \&handler
1252                                                      #             or '#PItarget' => \&handler or '#PI' => \&handler)
1253         527    100                        3239       if( $path=~ /^\s*(?:\?|#PI)\s*(?:([^\s]*)\s*)$/)
1254           9           100                   74         { my $target= $1 || '';
1255                                                          # update the path_handlers count, knowing that
1256                                                          # either the previous or the new handler can be undef
1257           9                                 60           $handlers->{pi_handlers}->{$1}= $handler;
1258           9                                104           return 1;
1259                                                        }
1260                                                      else 
1261         518                               5524         { return 0; 
1262                                                        }
1263                                                    }
1264                                                  
1265                                                  sub _set_level_handler
1266         518                  518          2429     { my( $handlers, $path, $handler, $prev_handler)= @_;
1267         518    100                        1852       if( $path =~ m{^ \s* level \s* \( \s* ([0-9]+) \s* \) \s* $}ox )
1268           3                                 13         { my $level= $1;
1269  ***      3            66     13            23           my $sub= sub { my( $stack)= @_; return( ($stack->[-1]->{_tag} !~ m{^#}) && (scalar @$stack == $level + 1) ) }; 
              13                                 34   
              13                                217   
1270           3                                 34           my $handler_data=  { tag=> '*', score => { type => $LEVEL_TRIGGER}, trigger => $sub, 
1271                                                                               path => $path, handler => $handler, test_on_text => 0
1272                                                                             };
1273           3                                 12           _add_handler( $handlers, $handler_data, $path, $prev_handler);
1274           3                                 28           return 1;
1275                                                        }
1276                                                      else 
1277         515                               5315         { return 0; }
1278                                                    }
1279                                                  
1280                                                  sub _set_regexp_handler
1281         515                  515          2318     { my( $handlers, $path, $handler, $prev_handler)= @_; 
1282                                                      # if the expression was a regexp it is now a string (it was stringified when it became a hash key)
1283         515    100                        1866       if( $path=~ m{^\(\?([xism]*)(?:-[xism]*)?:(.*)\)$}) 
1284           3                                 74         { my $regexp= qr/(?$1:$2)/; # convert it back into a regexp
1285           3                   21            24           my $sub= sub { my( $stack)= @_; return( $stack->[-1]->{_tag} =~ $regexp ) }; 
              21                                 56   
              21                                247   
1286           3                                 36           my $handler_data=  { tag=> '*', score => { type => $REGEXP_TRIGGER} , trigger => $sub, 
1287                                                                               path => $path, handler => $handler, test_on_text => 0 
1288                                                                             };
1289           3                                 15           _add_handler( $handlers, $handler_data, $path, $prev_handler);
1290           3                                 26           return 1;
1291                                                        }
1292                                                      else 
1293         512                               4785         { return 0; }
1294                                                    }
1295                                                  
1296                                                  sub _parse_xpath_handler
1297         512                  512          1700     { my( $xpath, $handler)= @_;
1298         512                               1268       my $xpath_original= $xpath;
1299                                                  
1300         512                               1026       my $DEBUG_HANDLER= 0; # 0 or 1 (output the handler checking code) or 2 (super verbose)
1301                                                  
1302  ***    512     50                        1730       if( $DEBUG_HANDLER >=1) { warn "\n\nparsing path '$xpath'\n"; }
      ***      0                                  0   
1303                                                  
1304         512                               1120       my $path_to_check= $xpath;
1305         512                              14387       $path_to_check=~ s{/?/?$REG_NAME_W?\s*(?:$REG_PREDICATE\s*)?}{}g;
1306  ***    512     50     33                 2295       if( $DEBUG_HANDLER && $path_to_check=~ /\S/) { warn "left: $path_to_check\n"; }
      ***      0                                  0   
1307         512    100                        1491       return if( $path_to_check=~ /\S/);
1308                                                  
1309         510                               4311       (my $xpath_to_display= $xpath)=~ s{(["{}'\[\]\@\$])}{\\$1}g;
1310                                                  
1311                                                      #my @xpath_steps= split /(?<!\\)(\/\/?)/, $xpath; 
1312         510                                885       my @xpath_steps;
1313         510                                750       my $last_token_is_sep;
1314         510                              14772       while( $xpath=~ s{^\s*
1315                                                                         ( (//?)                                      # separator
1316                                                                          | (?:$REG_NAME_W\s*(?:$REG_PREDICATE\s*)?) # tag name and optional predicate
1317                                                                          | (?:$REG_PREDICATE)                       # just a predicate
1318                                                                         )
1319                                                                       }
1320                                                                       {}x
1321                                                           )
1322                                                        { # check that we have alternating separators and steps
1323         629    100                        2693           if( $2) # found a separator
1324          71    100                         194             { if(  $last_token_is_sep) { return 0; } # 2 seps in a row
               1                                  6   
1325          70                                149               $last_token_is_sep= 1;
1326                                                            }
1327                                                          else
1328         558    100    100                 2494             { if( defined( $last_token_is_sep) && !$last_token_is_sep) { return 0; } # 2 steps in a row
               2                                 14   
1329         556                               1226               $last_token_is_sep= 0;
1330                                                            }
1331                                                  
1332         626                               7499           push @xpath_steps, $1;
1333                                                        }
1334         507    100                        1295       if( $last_token_is_sep) { return 0; } # expression cannot end with a separator 
               1                                  7   
1335                                                  
1336         506                                950       my $i=-1;
1337                                                  
1338  ***    506            33                 3273       my $perlfunc= _join_n( $NO_WARNINGS . ';',
1339                                                                             q|my( $stack)= @_;                    |,
1340                                                                             q|my @current_elts= (scalar @$stack); |,
1341                                                                             q|my @new_current_elts;               |,
1342                                                                             q|my $elt;                            |,
1343                                                                             ($DEBUG_HANDLER >= 1) && (qq#warn q{checking path '$xpath_to_display'\n};#),
1344                                                                           );
1345                                                  
1346                                                  
1347         506                               1250       my $last_tag='';
1348         506    100                        2111       my $anchored= $xpath_original=~ m{^\s*/(?!/)} ? 1 : 0; 
1349         506                               2804       my $score={ type => $XPATH_TRIGGER, anchored => $anchored };
1350         506                               1843       my $flag= { test_on_text => 0 };
1351         506                               1315       my $sep='/';  # '/' or '//'
1352         506                               2300       while( my $xpath_step= pop @xpath_steps)
1353         553                               7384         { my( $tag, $predicate)= $xpath_step =~ m{^($REG_NAME_W)?(?:\[(.*)\])?\s*$};
1354         553                               2242           $score->{steps}++;
1355         553           100                 1817           $tag||='*';
1356                                                  
1357  ***    553     50                        1901           my $warn_empty_stack= $DEBUG_HANDLER >= 2 ? qq{warn "return with empty stack\\n";} : '';
1358                                                  
1359         553    100                        1434           if( $predicate)
1360  ***    169     50                         481             { if( $DEBUG_HANDLER >= 2)  { warn "predicate is: '$predicate'\n"; }
      ***      0                                  0   
1361                                                              # changes $predicate (from an XPath expression to a Perl one)
1362         169                                549               _parse_predicate_in_handler( $predicate, $flag, $score);
1363  ***    169     50                         820               if( $DEBUG_HANDLER >= 2) { warn "predicate becomes: '$predicate'\n"; }
      ***      0                                  0   
1364                                                            }
1365                                                  
1366         553    100                        2643          my $tag_cond=  $tag ne '*' ? qq#(\$elt->{_tag} eq "$tag")# : '';
1367         553                               1517          my $cond= join( " && ", grep { $_ } $tag_cond, $predicate);
            1106                               3517   
1368                                                  
1369  ***    553            66                 1956          $last_tag ||= $tag;
1370                                                  
1371                                                  
1372         553    100                        1677          if( $sep eq '/')
      ***            50                               
1373                                                           { 
1374         552                               2181              $perlfunc .= sprintf( _join_n(  q#foreach my $current_elt (@current_elts)              #,
1375                                                                                             q#  { next if( !$current_elt);                         #,
1376                                                                                             q#    $current_elt--;                                  #,
1377                                                                                             q#    $elt= $stack->[$current_elt];                    #,
1378                                                                                             q#    if( %s) { push @new_current_elts, $current_elt;} #,
1379                                                                                             q#  }                                                  #,
1380                                                                                          ),
1381                                                                                   $cond
1382                                                                                 );
1383                                                           }
1384                                                         elsif( $sep eq '//')
1385                                                           { 
1386           1                                  5              $perlfunc .= sprintf( _join_n(  q#foreach my $current_elt (@current_elts)                #,
1387                                                                                             q#  { next if( !$current_elt);                           #,
1388                                                                                             q#    $current_elt--;                                    #,
1389                                                                                             q#    my $candidate= $current_elt;                       #,
1390                                                                                             q#    while( $candidate >=0)                             #,
1391                                                                                             q#      { $elt= $stack->[$candidate];                    #,
1392                                                                                             q#        if( %s) { push @new_current_elts, $candidate;} #,
1393                                                                                             q#        $candidate--;                                  #,
1394                                                                                             q#      }                                                #,
1395                                                                                             q#  }                                                    #,
1396                                                                                          ),
1397                                                                                   $cond
1398                                                                                 );
1399                                                           }
1400  ***    553     50                        2505          my $warn= $DEBUG_HANDLER >= 2 ? _join_n( qq#warn qq%fail at cond '$cond'%;#) : '';
1401         553                               1857          $perlfunc .= sprintf( _join_n( q#unless( @new_current_elts) { %s return 0; } #,
1402                                                                                        q#@current_elts= @new_current_elts;           #,
1403                                                                                        q#@new_current_elts=();                       #,
1404                                                                                      ),
1405                                                                               $warn
1406                                                                             );
1407                                                  
1408         553                               3881           $sep= pop @xpath_steps;
1409                                                       }
1410                                                  
1411         506    100                        1243       if( $anchored) # there should be a better way, but this works
1412                                                        {  
1413  ***     21     50                          84          my $warn= $DEBUG_HANDLER >= 2 ? _join_n( qq#warn qq{fail, stack not empty};#) : '';
1414          21                                 68          $perlfunc .= sprintf( _join_n( q#if( ! grep { $_ == 0 } @current_elts) { %s return 0;}#), $warn);
1415                                                        }
1416                                                  
1417  ***    506     50                        1455       $perlfunc.= qq{warn "handler for '$xpath_to_display' triggered\\n";\n} if( $DEBUG_HANDLER >=2);
1418         506                               1970       $perlfunc.= qq{return q{$xpath_original};\n};
1419  ***    506     50                        1640       warn "\nperlfunc:\n$perlfunc\n" if( $DEBUG_HANDLER>=1);
1420         506                   11          1191       my $s= eval "sub { $perlfunc }";
              11                   10            82   
              11                   11            24   
              11                   10           105   
              10                   12            73   
              10                   10            21   
              10                   12            59   
              11                   14            87   
              11                   15            30   
              11                   12            77   
              10                   12            90   
              10                    6            21   
              10                    7            68   
              12                    8            95   
              12                    7            24   
              12                    5            72   
              10                    4            79   
              10                    4            23   
              10                    3            68   
              12                    3            96   
              12                    2            26   
              12                    2            64   
              14                    2           104   
              14                    2            30   
              14                    2            87   
              15                    2           262   
              13                    2            32   
              13                    2            76   
              12                    2            93   
              12                    2            52   
              12                    2            73   
              12                    2            84   
              12                    2          2206   
              12                    2            81   
               6                    2            52   
               6                    2            16   
               6                    2            40   
               7                    2            48   
               7                    2            23   
               7                    2            42   
               8                    2            63   
               8                    2            19   
               8                    2            49   
               7                    2            67   
               7                    2            16   
               7                    2            55   
               5                    2            41   
               5                    1            11   
               5                    1            29   
               4                    1            32   
               4                    1             7   
               4                    1            24   
               3                    1            22   
               3                    1            13   
               3                    1            19   
               3                    1            19   
               3                    1             8   
               3                    1            16   
               3                    1            21   
               3                    1             7   
               3                    1            18   
               2                    1            15   
               2                    1             5   
               2                    1            11   
               2                    1            16   
               2                    1             3   
               2                    1            13   
               2                    1            16   
               2                    1             4   
               2                    1            14   
               2                    1            14   
               2                    1             3   
               2                    1            11   
               2                    1            15   
               2                    1             4   
               2                    1            11   
               2                    1            13   
               2                    1             4   
               2                    1            10   
               2                    1            16   
               2                    1             4   
               2                    1            10   
               2                    1            16   
               2                    1             3   
               2                    1            13   
               2                    2            14   
               2                    2             4   
               2                    2            11   
               2                    2            20   
               2                    1             4   
               2                    1            11   
               2                    1            14   
               2                                  4   
               2                                 10   
               2                                 17   
               2                                  4   
               2                                 11   
               2                                 20   
               2                                  5   
               2                                 15   
               2                                 21   
               2                                  5   
               2                                 11   
               2                                 14   
               2                                  6   
               2                                 13   
               2                                 15   
               2                                  4   
               2                                 11   
               2                                 20   
               2                                  4   
               2                                 12   
               2                                 17   
               2                                  4   
               2                                 13   
               2                                 16   
               2                                  5   
               2                                 10   
               2                                 15   
               2                                  4   
               2                                 11   
               2                                 14   
               2                                  6   
               2                                 11   
               2                                 16   
               2                                  4   
               2                                 19   
               2                                 17   
               2                                  4   
               2                                 16   
               2                                 14   
               2                                  5   
               2                                 13   
               2                                 14   
               2                                  5   
               2                                 13   
               2                                 20   
               2                                  4   
               2                                 14   
               2                                 19   
               2                                  5   
               2                                 15   
               1                                  9   
               1                                  2   
               1                                  7   
               1                                  7   
               1                                  2   
               1                                  6   
               1                                 10   
               1                                  2   
               1                                  7   
               1                                  7   
               1                                  2   
               1                                  6   
               1                                  7   
               1                                  2   
               1                                  5   
               1                                  7   
               1                                  2   
               1                                  6   
               1                                  7   
               1                                  1   
               1                                  5   
               1                                  8   
               1                                  2   
               1                                  6   
               1                                  8   
               1                                  1   
               1                                  6   
               1                                 13   
               1                                  2   
               1                                  7   
               1                                  8   
               1                                  2   
               1                                  7   
               1                                  7   
               1                                  2   
               1                                  6   
               1                                 10   
               1                                  3   
               1                                  7   
               1                                  7   
               1                                  2   
               1                                  5   
               1                                  7   
               1                                  2   
               1                                  5   
               1                                  7   
               1                                  2   
               1                                  5   
               1                                  9   
               1                                  2   
               1                                  6   
               1                                  8   
               1                                  2   
               1                                  6   
               1                                  7   
               1                                  2   
               1                                  5   
               1                                  8   
               1                                  2   
               1                                  6   
               1                                  7   
               1                                  2   
               1                                  5   
               1                                  9   
               1                                  2   
               1                                  8   
               1                                  8   
               1                                  2   
               1                                  6   
               1                                  6   
               1                                  2   
               1                                  5   
               1                                  8   
               1                                  1   
               1                                  6   
               1                                  7   
               1                                  3   
               1                                  7   
               1                                 15   
               1                                  3   
               1                                  6   
               1                                  7   
               1                                  3   
               1                                  6   
               1                                  7   
               1                                  2   
               1                                  6   
               1                                  8   
               1                                  1   
               1                                  7   
               1                                  7   
               1                                  2   
               1                                  6   
               1                                 11   
               1                                  2   
               1                                  8   
               1                                  6   
               1                                  2   
               1                                  6   
               1                                  7   
               1                                  2   
               1                                  5   
               1                                  7   
               1                                  2   
               1                                  6   
               1                                  7   
               1                                  2   
               1                                  5   
               1                                  7   
               1                                  3   
               1                                  6   
               1                                  7   
               1                                  3   
               1                                  5   
               1                                  7   
               1                                  2   
               1                                  5   
               1                                 11   
               1                                  2   
               1                                  9   
               2                                 18   
               2                                  4   
               2                                 12   
               2                                 15   
               2                                  4   
               2                                 12   
               1                                  7   
               1                                  3   
               1                                  5   
               1                                  6   
               1                                  2   
               1                                 13   
               1                                 10   
               1                                  2   
               1                                  7   
1421  ***    506     50                        2329         if( $@) 
1422  ***      0                                  0           { croak "wrong handler condition '$xpath' ($@);" }
1423                                                  
1424  ***    506     50                        1614         warn "last tag: '$last_tag', test_on_text: '$flag->{test_on_text}'\n" if( $DEBUG_HANDLER >=1);
1425  ***    506     50                        1479         warn "score: ", join( ' ', map { "$_: $score->{$_}" } sort keys %$score), "\n" if( $DEBUG_HANDLER >=1);
      ***      0                                  0   
1426         506                               9103         return { tag=> $last_tag, score => $score, trigger => $s, path => $xpath_original, handler => $handler, test_on_text => $flag->{test_on_text} };
1427                                                      }
1428                                                  
1429        1633                 1633         16239   sub _join_n { return join( "\n", @_, ''); }
1430                                                  
1431                                                  # input: the predicate ($_[0]) which will be changed in place
1432                                                  #        flags, a hashref with various flags (like test_on_text)
1433                                                  #        the score 
1434                                                  sub _parse_predicate_in_handler
1435         169                  169           971     { my( $flag, $score)= @_[1..2];
1436         169                               6016       $_[0]=~ s{(   ($REG_STRING)                        # strings
             409                               4298   
1437                                                                   |\@($REG_NAME)(?=\s*(?:[><=!]|!~|=~)) # @att (followed by a comparison operator)
1438         409                               1551                    |\@($REG_NAME)                        # @att (not followed by a comparison operator)
1439                                                                   |=~|!~                                # matching operators
1440                                                                   |([><]=?|=|!=)(?=\s*[\d+-])           # test before a number
1441         409    100    100                 5758                    |([><]=?|=|!=)                        # test, other cases
      ***     44            66                  145   
                           100                        
1442                                                                   |($REG_FUNCTION)                      # no arg functions
1443         409    100    100                 3464                    # this bit is a mess, but it is the only solution with this half-baked parser
      ***     89    100     66                  533   
      ***           100     66                        
      ***           100     66                        
      ***           100     33                        
                    100                               
                    100                               
                    100                               
      ***            50                               
      ***            50                               
1444         111    100                        1181                    |(string\(\s*$REG_NAME\s*\)\s*$REG_MATCH\s*$REG_REGEXP)  # string( child)=~ /regexp/
1445                                                                   |(string\(\s*$REG_NAME\s*\)\s*$REG_COMP\s*$REG_STRING) # string( child) = "value" (or other test)
1446                                                                   |(string\(\s*$REG_NAME\s*\)\s*$REG_COMP\s*$REG_NUMBER) # string( child) = nb (or other test)
1447          14    100                         129                    |(and|or)
1448                                                                )}
1449                                                               { my( $token, $string, $att, $bare_att, $num_test, $alpha_test, $func, $string_regexp, $string_test_alpha, $string_test_num, $and_or) 
1450           2                                 19                  = ( $1,     $2,      $3,   $4,        $5,        $6,          $7,    $8,             $9,                 $10,              $11); 
1451          89                                874       
1452          40                                294                  $score->{predicates}++;
1453           2                                 27                 
1454           2                                 13                  # store tests on text (they are not always allowed)
1455           2                                  6                  if( $func || $string_regexp || $string_test_num || $string_test_alpha ) { $flag->{test_on_text}= 1;   }
1456           2                                  8   
1457           2                                  8                  if( defined $string)   { $token }
1458           2                                 26                  elsif( $att)           { $att=~ m{^#} ? qq{ (\$elt->{_elt} && \$elt->{_elt}->{att}->{'$att'})}
1459  ***      0      0                           0                                                        : qq{\$elt->{'$att'}}
1460  ***      0                                  0                                         }
1461                                                                 elsif( $bare_att)      { $bare_att=~ m{^#} ? qq{(\$elt->{_elt} && defined(\$elt->{_elt}->{att}->{'$bare_att'}))}
1462  ***      0      0                           0                                                             : qq{defined( \$elt->{'$bare_att'})}
      ***      0                                  0   
1463          60                                872                                         }
1464                                                                 elsif( $num_test && ($num_test eq '=') ) { "==" } # others tests are unchanged
1465                                                                 elsif( $alpha_test)    { $PERL_ALPHA_TEST{$alpha_test} }
1466                                                                 elsif( $func && $func=~ m{^string})
1467                                                                                        { "\$elt->{_elt}->text"; }
1468                                                                 elsif( $string_regexp && $string_regexp =~ m{string\(\s*($REG_NAME)\s*\)\s*($REG_MATCH)\s*($REG_REGEXP)})
1469                                                                                        { "defined( _first_n {  \$_->text $2 $3 } 1, \$elt->{_elt}->_children( '$1'))"; }
1470                                                                 elsif( $string_test_alpha && $string_test_alpha     =~ m{string\(\s*($REG_NAME)\s*\)\s*($REG_COMP)\s*($REG_STRING)})
1471                                                                                        { my( $tag, $op, $str)= ($1, $2, $3);
1472                                                                                          $str=~ s{(?<=.)'(?=.)}{\\'}g; # escape a quote within the string 
1473                                                                                          $str=~ s{^"}{'};
1474                                                                                          $str=~ s{"$}{'};
1475                                                                                          "defined( _first_n { \$_->text $PERL_ALPHA_TEST{$op} $str } 1, \$elt->{_elt}->children( '$tag'))"; }
1476                                                                 elsif( $string_test_num && $string_test_num   =~ m{string\(\s*($REG_NAME)\s*\)\s*($REG_COMP)\s*($REG_NUMBER)})
1477                                                                                        { my $test= ($2 eq '=') ? '==' : $2;
1478                                                                                          "defined( _first_n { \$_->text $test $3 } 1, \$elt->{_elt}->children( '$1'))"; 
1479                                                                                        }
1480                                                                 elsif( $and_or)        { $score->{tests}++; $and_or eq 'and' ? '&&' : '||' ; }
1481                                                                 else                   { $token; }
1482                                                               }gexs;
1483                                                    }
1484                                                      
1485                                                  
1486                                                  sub setCharHandler
1487           1                    1             5     { my( $t, $handler)= @_;
1488           1                                  7       $t->{twig_char_handler}= $handler;
1489                                                    }
1490                                                  
1491                                                  
1492                                                  sub _reset_handlers
1493         296                  296          1176     { my $handlers= shift;
1494         296                                895       delete $handlers->{handlers};
1495         296                                647       delete $handlers->{path_handlers};
1496         296                               1701       delete $handlers->{subpath_handlers};
1497  ***    296     50                        1170       $handlers->{attcond_handlers_exp}=[] if( $handlers->{attcond_handlers});
1498         296                               1227       delete $handlers->{attcond_handlers};
1499                                                    }
1500                                                    
1501                                                  sub _set_handlers
1502  ***    296            66    296          1147     { my $handlers= shift || return;
1503         295                                684       my $set_handlers= {};
1504         295                                776       foreach my $path (keys %{$handlers})
             295                               1612   
1505         439                               1864         { _set_handler( $set_handlers, $path, $handlers->{$path}); }
1506         289                               1727       return $set_handlers;
1507                                                    }
1508                                                      
1509                                                  
1510                                                  sub setTwigHandler
1511          63                   63          1561     { my( $t, $path, $handler)= @_;
1512          63           100                  381       $t->{twig_handlers} ||={};
1513          63                                301       return _set_handler( $t->{twig_handlers}, $path, $handler);
1514                                                    }
1515                                                  
1516                                                  sub setTwigHandlers
1517         193                  193          1479     { my( $t, $handlers)= @_;
1518         193           100                 1811       my $previous_handlers= $t->{twig_handlers} || undef;
1519         193                               1338       _reset_handlers( $t->{twig_handlers});
1520         193                                715       $t->{twig_handlers}= _set_handlers( $handlers);
1521         187                                768       return $previous_handlers;
1522                                                    }
1523                                                  
1524                                                  sub setStartTagHandler
1525           3                    3            34     { my( $t, $path, $handler)= @_;
1526  ***      3            50                   19       $t->{twig_starttag_handlers}||={};
1527           3                                 14       return _set_handler( $t->{twig_starttag_handlers}, $path, $handler);
1528                                                    }
1529                                                  
1530                                                  sub setStartTagHandlers
1531          26                   26           146     { my( $t, $handlers)= @_;
1532          26           100                  284       my $previous_handlers= $t->{twig_starttag_handlers} || undef;
1533          26                                168       _reset_handlers( $t->{twig_starttag_handlers});
1534          26                                100       $t->{twig_starttag_handlers}= _set_handlers( $handlers);
1535          26                                171       return $previous_handlers;
1536                                                     }
1537                                                  
1538                                                  sub setIgnoreEltsHandler
1539           1                    1            11     { my( $t, $path, $action)= @_;
1540  ***      1            50                    8       $t->{twig_ignore_elts_handlers}||={};
1541           1                                  6       return _set_handler( $t->{twig_ignore_elts_handlers}, $path, $action );
1542                                                    }
1543                                                  
1544                                                  sub setIgnoreEltsHandlers
1545           4                    4            16     { my( $t, $handlers)= @_;
1546           4                                 16       my $previous_handlers= $t->{twig_ignore_elts_handlers};
1547           4                                 24       _reset_handlers( $t->{twig_ignore_elts_handlers});
1548           4                                 15       $t->{twig_ignore_elts_handlers}= _set_handlers( $handlers);
1549           4                                 12       return $previous_handlers;
1550                                                     }
1551                                                  
1552                                                  sub setEndTagHandler
1553           2                    2           731     { my( $t, $path, $handler)= @_;
1554           2           100                   14       $t->{twig_endtag_handlers}||={};
1555           2                                 13       return _set_handler( $t->{twig_endtag_handlers}, $path,$handler);
1556                                                    }
1557                                                  
1558                                                  sub setEndTagHandlers
1559          10                   10            37     { my( $t, $handlers)= @_;
1560          10                                 40       my $previous_handlers= $t->{twig_endtag_handlers};
1561          10                                 60       _reset_handlers( $t->{twig_endtag_handlers});
1562          10                                 38       $t->{twig_endtag_handlers}= _set_handlers( $handlers);
1563          10                                 35       return $previous_handlers;
1564                                                     }
1565                                                  
1566                                                  # a little more complex: set the twig_handlers only if a code ref is given
1567                                                  sub setTwigRoots
1568          63                   63           222     { my( $t, $handlers)= @_;
1569          63                                242       my $previous_roots= $t->{twig_roots};
1570          63                                391       _reset_handlers($t->{twig_roots});
1571          63                                243       $t->{twig_roots}= _set_handlers( $handlers);
1572                                                  
1573          63                                315       _check_illegal_twig_roots_handlers( $t->{twig_roots});
1574                                                      
1575          61                                117       foreach my $path (keys %{$handlers})
              61                                242   
1576          60           100                  403         { $t->{twig_handlers}||= {};
1577  ***     60    100     66                  846           _set_handler( $t->{twig_handlers}, $path, $handlers->{$path})
1578                                                            if( ref($handlers->{$path}) && isa( $handlers->{$path}, 'CODE')); 
1579                                                        }
1580          61                                202       return $previous_roots;
1581                                                    }
1582                                                  
1583                                                  sub _check_illegal_twig_roots_handlers
1584          63                   63           201     { my( $handlers)= @_;
1585          63                                141       foreach my $tag_handlers (values %{$handlers->{xpath_handler}})
              63                                362   
1586          61                                188         { foreach my $handler_data (@$tag_handlers)
1587          61    100                         492             { if( my $type= $handler_data->{test_on_text})
1588           2                                  8                 { croak "string() condition not supported on twig_roots option"; }
1589                                                            }
1590                                                        }
1591          61                                146       return;
1592                                                    }
1593                                                      
1594                                                  
1595                                                  # just store the reference to the expat object in the twig
1596                                                  sub _twig_init
1597                                                     { # warn " in _twig_init...\n"; # DEBUG handler
1598                                                      
1599        2780                 2780        2480448       my $p= shift;
1600        2780                              10402       my $t=$p->{twig};
1601                                                  
1602        2780    100                       11450       if( $t->{twig_parsing} ) { croak "cannot reuse a twig that is already parsing"; }
               1                                  5   
1603        2779                              10125       $t->{twig_parsing}=1;
1604                                                  
1605        2779                               9360       $t->{twig_parser}= $p; 
1606        2779    100                        8332       if( $weakrefs) { weaken( $t->{twig_parser}); }
            2778                              17712   
1607                                                  
1608                                                      # in case they had been created by a previous parse
1609        2779                               7693       delete $t->{twig_dtd};
1610        2779                               6431       delete $t->{twig_doctype};
1611        2779                               6108       delete $t->{twig_xmldecl};
1612        2779                               6936       delete $t->{twig_root};
1613                                                  
1614                                                      # if needed set the output filehandle
1615        2779                              10142       $t->_set_fh_to_twig_output_fh();
1616        2779                               8289       return;
1617                                                    }
1618                                                  
1619                                                  # uses eval to catch the parser's death
1620                                                  sub safe_parse
1621           9                    9           168     { my $t= shift;
1622           9                                132       eval { $t->parse( @_); } ;
               9                                219   
1623  ***      9    100     50                  108       return $@ ? $t->_reset_twig &&  0 : $t;
1624                                                    }
1625                                                  
1626                                                  sub safe_parsefile
1627           3                    3             8     { my $t= shift;
1628           3                                  5       eval { $t->parsefile( @_); } ;
               3                                 13   
1629           3    100                          21       return $@ ? $t->_reset_twig : $t;
1630                                                    }
1631                                                  
1632                                                  # restore a twig in a proper state so it can be reused for a new parse
1633                                                  sub _reset_twig
1634           5                    5            13     { my $t= shift;
1635           5                                 19       $t->{twig_parsing}= 0;
1636           5                                 18       delete $t->{twig_current};
1637           5                                 13       delete $t->{extra_data};
1638           5                                 12       delete $t->{twig_dtd};
1639           5                                 11       delete $t->{twig_in_pcdata};
1640           5                                 13       delete $t->{twig_in_cdata};
1641           5                                 12       delete $t->{twig_stored_space};
1642           5                                 40       delete $t->{twig_entity_list};
1643           5    100                          77       $t->root->delete if( $t->root);
1644           5                                 35       delete $t->{root};
1645                                                    }
1646                                                  
1647                                                  
1648                                                  sub _add_or_discard_stored_spaces
1649       20666                20666         46177     { my $t= shift;
1650       20666                              55588       my %option= @_;
1651                                                     
1652       20666    100                       81399       return unless( $t->{twig_current}); # ugly hack, with ignore on, twig_current can disappear 
1653  ***  17890    100     66               222333       if( $t->{twig_stored_spaces} || $option{force} || $t->{twig_preserve_space})
                           100                        
1654        1757    100                        7697         { if( $t->{twig_current}->is_pcdata)
1655           2                                 12             { $t->{twig_current}->append_pcdata($t->{twig_stored_spaces}); }
1656                                                          else
1657        1755                              10097             { my $current_gi= $t->{twig_current}->gi;
1658        1755    100                       10059               unless( defined( $t->{twig_space_policy}->{$current_gi}))
1659         455                               1793                 { $t->{twig_space_policy}->{$current_gi}= _space_policy( $t, $current_gi); }
1660                                                  
1661        1755    100    100                37065               if(    $t->{twig_space_policy}->{$current_gi} ||  ($t->{twig_stored_spaces}!~ m{\n})
      ***                   66                        
                           100                        
1662                                                                  || $option{force} || $t->{twig_preserve_space}
1663                                                                )
1664          90                                379                 { _insert_pcdata( $t, $t->{twig_stored_spaces} ); }
1665        1755                               7208               $t->{twig_stored_spaces}='';
1666                                                  
1667                                                            }
1668                                                        }
1669       17890                              44323       return;
1670                                                    }
1671                                                  
1672                                                  # the default twig handlers, which build the tree
1673                                                  sub _twig_start
1674                                                     { # warn " in _twig_start...\n"; # DEBUG handler
1675                                                      
1676       10367                10367         58274       my ($p, $gi, @att)= @_;
1677       10367                              37777       my $t=$p->{twig};
1678                                                  
1679                                                      # empty the stored pcdata (space stored in case they are really part of 
1680                                                      # a pcdata element) or stored it if the space policy dictades so
1681                                                      # create a pcdata element with the spaces if need be
1682       10367                              29329       _add_or_discard_stored_spaces( $t);
1683       10367                              32308       my $parent= $t->{twig_current};
1684                                                  
1685                                                      # if we were parsing PCDATA then we exit the pcdata
1686       10367    100                       34465       if( $t->{twig_in_pcdata})
1687         103                                320         { $t->{twig_in_pcdata}= 0;
1688         103                                277           delete $parent->{'twig_current'};
1689         103                                332           $parent= $parent->{parent};
1690                                                        }
1691                                                  
1692                                                      # if we choose to keep the encoding then we need to parse the tag
1693       10367    100                       56579       if( my $func = $t->{parse_start_tag})
      ***            50                               
1694        1310                               5864         { ($gi, @att)= &$func($p->original_string); }
1695                                                      elsif( $t->{twig_entities_in_attribute})
1696                                                        { 
1697  ***      0                                  0          ($gi,@att)= _parse_start_tag( $p->recognized_string); 
1698  ***      0                                  0            $t->{twig_entities_in_attribute}=0;
1699                                                        }
1700                                                  
1701                                                      # if we are using an external DTD, we need to fill the default attributes
1702       10367    100                       34405       if( $t->{twig_read_external_dtd}) { _fill_default_atts( $t, $gi, \@att); }
              48                                177   
1703                                                      
1704                                                      # filter the input data if need be  
1705       10367    100                       35871       if( my $filter= $t->{twig_input_filter})
1706           5                                 16         { $gi= $filter->( $gi);
1707           5                                 58           @att= map { $filter->($_) } @att; 
               4                                 25   
1708                                                        }
1709                                                  
1710       10367    100                       31588       if( $t->{twig_map_xmlns}) { _replace_ns( $t, \$gi, \@att); }
              46                                191   
1711                                                  
1712       10367                              56864       my $elt= $t->{twig_elt_class}->new( $gi);
1713       10367                              40093       $elt->set_atts( @att);
1714                                                   
1715                                                      # now we can store the tag and atts
1716       10367                              58899       my $context= { _tag => $gi, _elt => $elt, @att};
1717       10367    100                       32029       if( $weakrefs) { weaken( $context->{_elt}); }
           10363                              57164   
1718       10367                              17002       push @{$t->{_twig_context_stack}}, $context;
           10367                              42309   
1719                                                  
1720       10367    100                       37854       delete $parent->{'twig_current'} if( $parent);
1721       10367                              32139       $t->{twig_current}= $elt;
1722       10367                              30837       $elt->{'twig_current'}=1;
1723                                                  
1724       10367    100                       24368       if( $parent)
1725        7591                              21392         { my $prev_sibling= $parent->{last_child};
1726        7591    100                       19400           if( $prev_sibling) 
1727        5644                              16499             { $prev_sibling->{next_sibling}=  $elt; 
1728        5644    100                       16419               $elt->{prev_sibling}=$prev_sibling; if( $XML::Twig::weakrefs) { weaken( $elt->{prev_sibling});} ;
            5644                              14125   
            5642                              24805   
1729                                                            }
1730                                                  
1731        7591    100                       23443           $elt->{parent}=$parent; if( $XML::Twig::weakrefs) { weaken( $elt->{parent});} ;
            7591                              18675   
            7588                              30880   
1732        7591    100                       27299           unless( $parent->{first_child}) { $parent->{first_child}=  $elt; } 
            1947                               6386   
1733        7591    100                       19034            delete $parent->{empty}; $parent->{last_child}=$elt; if( $XML::Twig::weakrefs) { weaken( $parent->{last_child});} ;
            7591                              22077   
            7591                              18862   
            7588                              32668   
1734                                                        }
1735                                                      else 
1736                                                        { # processing root
1737        2776                              11273           $t->set_root( $elt);
1738                                                          # call dtd handler if need be
1739  ***   2776     50                       11879           $t->{twig_dtd_handler}->($t, $t->{twig_dtd})
1740                                                            if( defined $t->{twig_dtd_handler});
1741                                                        
1742                                                          # set this so we can catch external entities
1743                                                          # (the handler was modified during DTD processing)
1744        2776    100                       14819           if( $t->{twig_default_print})
                    100                               
1745          33                                194             { $p->setHandlers( Default => \&_twig_print); }
1746                                                          elsif( $t->{twig_roots})
1747          33                  127           285             { $p->setHandlers( Default => sub { return }); }
             127                                253   
1748                                                          else
1749        2710                              16334             { $p->setHandlers( Default => \&_twig_default); }
1750                                                        }
1751                                                    
1752       10367    100                      174884       $elt->{empty}=  $p->recognized_string=~ m{/\s*>$}s ? 1 : 0;
1753                                                  
1754       10367    100                      264774       $elt->{extra_data}= $t->{extra_data} if( $t->{extra_data});
1755       10367                              34320       $t->{extra_data}='';
1756                                                  
1757                                                      # if the element is ID-ed then store that info
1758       10367                              38836       my $id= $elt->{'att'}->{$ID};
1759       10367    100                       28117       if( defined $id)
1760         500                               2289         { $t->{twig_id_list}->{$id}= $elt; 
1761         500    100                        1459           if( $weakrefs) { weaken( $t->{twig_id_list}->{$id}); }
             497                               3172   
1762                                                        }
1763                                                  
1764                                                      # call user handler if need be
1765       10367    100                       37322       if( $t->{twig_starttag_handlers})
1766                                                        { # call all appropriate handlers
1767         100                                455           my @handlers= _handler( $t, $t->{twig_starttag_handlers}, $gi);
1768                                                      
1769         100                                688           local $_= $elt;
1770                                                      
1771         100                                358           foreach my $handler ( @handlers)
1772          31    100                         126             { $handler->($t, $elt) || last; }
1773                                                          # call _all_ handler if needed
1774         100    100                         815           if( my $all= $t->{twig_starttag_handlers}->{handlers}->{$ALL})
1775           3                                 12             { $all->($t, $elt); }
1776                                                        }
1777                                                  
1778                                                      # check if the tag is in the list of tags to be ignored
1779       10367    100                       33711       if( $t->{twig_ignore_elts_handlers})
1780          48                                213         { my @handlers= _handler( $t, $t->{twig_ignore_elts_handlers}, $gi);
1781                                                          # only the first handler counts, it contains the action (discard/print/string)
1782          48    100                         140           if( @handlers) { my $action= shift @handlers; $t->ignore( $action); }
              13                                 31   
              13                                 56   
1783                                                        }
1784                                                  
1785  ***  10367    100     66                46821       if( $elt->{'att'}->{'xml:space'} && (  $elt->{'att'}->{'xml:space'} eq 'preserve')) { $t->{twig_preserve_space}++; }
               1                                  4   
1786                                                  
1787       10367                              26303       return;
1788                                                    }
1789                                                  
1790                                                  sub _replace_ns
1791          48                   48           286     { my( $t, $gi, $atts)= @_;
1792          48                                203       foreach my $new_prefix ( $t->parser->new_ns_prefixes)
1793          28                                419         { my $uri= $t->parser->expand_ns_prefix( $new_prefix);
1794                                                          # replace the prefix if it is mapped
1795          28    100    100                 1096           if( !$t->{twig_keep_original_prefix} && (my $mapped_prefix= $t->{twig_map_xmlns}->{$uri}))
1796          16                                 46             { $new_prefix= $mapped_prefix; }
1797                                                          # now put the namespace declaration back in the element
1798          28    100                          97           if( $new_prefix eq '#default')
1799           3                                 18             { push @$atts, "xmlns" =>  $uri; } 
1800                                                          else
1801          25                                163             { push @$atts, "xmlns:$new_prefix" =>  $uri; } 
1802                                                        }
1803                                                  
1804          48    100                         792       if( $t->{twig_keep_original_prefix})
1805                                                        { # things become more complex: we need to find the original prefix
1806                                                          # and store both prefixes
1807          13                                 54           my $ns_info= $t->_ns_info( $$gi);
1808          13                                 24           my $map_att;
1809          13    100                          55           if( $ns_info->{mapped_prefix})
1810          11                                 61             { $$gi= "$ns_info->{mapped_prefix}:$$gi";
1811          11                                 62               $map_att->{$ns_info->{mapped_prefix}}= $ns_info->{prefix};
1812                                                            }
1813          13                                 25           my $att_name=1;
1814          13                                 45           foreach( @$atts) 
1815          30    100                          69             { if( $att_name) 
1816                                                                { 
1817          15                                 50                   my $ns_info= $t->_ns_info( $_);
1818          15    100                          61                   if( $ns_info->{mapped_prefix})
1819           4                                 19                     { $_= "$ns_info->{mapped_prefix}:$_";
1820           4                                 23                       $map_att->{$ns_info->{mapped_prefix}}= $ns_info->{prefix};
1821                                                                    }
1822          15                                 73                   $att_name=0; 
1823                                                                }
1824                                                              else           
1825          15                                 50                 {  $att_name=1; }
1826                                                            }
1827          13    100                          85           push @$atts, '#original_gi', $map_att if( $map_att);
1828                                                        }
1829                                                      else
1830          35                               1642         { $$gi= $t->_replace_prefix( $$gi); 
1831          35                                 77           my $att_name=1;
1832          35                                117           foreach( @$atts) 
1833          88    100                         259             { if( $att_name) { $_= $t->_replace_prefix( $_); $att_name=0; }
              44                                138   
              44                                138   
1834          44                                151               else           {  $att_name=1; }
1835                                                            }
1836                                                        }
1837          48                                125       return;
1838                                                    }
1839                                                  
1840                                                  
1841                                                  # extract prefix, local_name, uri, mapped_prefix from a name
1842                                                  # will only work if called from a start or end tag handler
1843                                                  sub _ns_info
1844          28                   28           105     { my( $t, $name)= @_;
1845          28                                 78       my $ns_info={};
1846          28                                 85       my $p= $t->parser;
1847          28                                114       $ns_info->{uri}= $p->namespace( $name); 
1848          28    100                         708       return $ns_info unless( $ns_info->{uri});
1849                                                  
1850          15                                 75       $ns_info->{prefix}= _a_proper_ns_prefix( $p, $ns_info->{uri});
1851  ***     15            66                  142       $ns_info->{mapped_prefix}= $t->{twig_map_xmlns}->{$ns_info->{uri}} || $ns_info->{prefix};
1852                                                  
1853          15                                 47       return $ns_info;
1854                                                    }
1855                                                      
1856                                                  sub _a_proper_ns_prefix
1857          22                   22            95     { my( $p, $uri)= @_;
1858          22                                 99       foreach my $prefix ($p->current_ns_prefixes)
1859          36    100                        1247         { if( $p->expand_ns_prefix( $prefix) eq $uri)
1860          22                                741             { return $prefix; }
1861                                                        }
1862  ***      0                                  0       return;
1863                                                    }
1864                                                  
1865                                                  sub _fill_default_atts
1866          48                   48           204     { my( $t, $gi, $atts)= @_;
1867          48                                163       my $dtd= $t->{twig_dtd};
1868          48                                165       my $attlist= $dtd->{att}->{$gi};
1869          48                                250       my %value= @$atts;
1870          48                                249       foreach my $att (keys %$attlist)
1871  ***     66    100     66                  648         { if(   !exists( $value{$att}) 
                           100                        
1872                                                              && exists( $attlist->{$att}->{default})
1873                                                              && ( $attlist->{$att}->{default} ne '#IMPLIED')
1874                                                            )
1875                                                            { # the quotes are included in the default, so we need to remove them
1876          13                                 68               my $default_value= substr( $attlist->{$att}->{default}, 1, -1);
1877          13                                 59               push @$atts, $att, $default_value;
1878                                                            }
1879                                                        }
1880          48                                184       return;
1881                                                    }
1882                                                  
1883                                                  
1884                                                  # the default function to parse a start tag (in keep_encoding mode)
1885                                                  # can be overridden with the parse_start_tag method
1886                                                  # only works for 1-byte character sets
1887                                                  sub _parse_start_tag
1888        1338                 1338         26496     { my $string= shift;
1889        1338                               2862       my( $gi, @atts);
1890                                                  
1891                                                      # get the gi (between < and the first space, / or > character)
1892                                                      #if( $string=~ s{^<\s*([^\s>/]*)[\s>/]*}{}s)
1893        1338    100                       18919       if( $string=~ s{^<\s*($REG_NAME)\s*[\s>/]}{}s)
1894        1320                               5938         { $gi= $1; }
1895                                                      else
1896          18                                 84         { croak "error parsing tag '$string'"; }
1897        1320                               5811       while( $string=~ s{^([^\s=]*)\s*=\s*(["'])(.*?)\2\s*}{}s)
1898         171                               1394         { push @atts, $1, $3; }
1899        1320                               7982       return $gi, @atts;
1900                                                    }
1901                                                  
1902                                                  sub set_root
1903        2780                 2780          9894     { my( $t, $elt)= @_;
1904        2780                              11421       $t->{twig_root}= $elt;
1905        2780                               8499       $elt->{twig}= $t;
1906        2780    100                        7796       if( $weakrefs) { weaken(  $elt->{twig}); }
            2779                              12116   
1907        2780                               6675       return $t;
1908                                                    }
1909                                                  
1910                                                  sub _twig_end
1911                                                     { # warn " in _twig_end...\n"; # DEBUG handler
1912       10272                10272         44146       my ($p, $gi)  = @_;
1913                                                  
1914       10272                              35443       my $t=$p->{twig};
1915                                                  
1916       10272    100                       37699       if( $t->{twig_map_xmlns}) { $gi= $t->_replace_prefix( $gi); }
              46                                179   
1917                                                    
1918       10272                              27603       _add_or_discard_stored_spaces( $t);
1919                                                   
1920                                                      # the new twig_current is the parent
1921       10272                              31013       my $elt= $t->{twig_current};
1922       10272                              27331       delete $elt->{'twig_current'};
1923                                                  
1924                                                      # if we were parsing PCDATA then we exit the pcdata too
1925       10272    100                       36386       if( $t->{twig_in_pcdata})
1926        6141                              16613         { $t->{twig_in_pcdata}= 0;
1927  ***   6141     50                       29121           $elt= $elt->{parent} if($elt->{parent});
1928        6141                              14780           delete $elt->{'twig_current'};
1929                                                        }
1930                                                  
1931                                                      # parent is the new current element
1932       10272                              27602       my $parent= $elt->{parent};
1933       10272                              30223       $t->{twig_current}= $parent;
1934                                                  
1935       10272    100                       24640       if( $parent)
1936        7518                              23029         { $parent->{'twig_current'}=1;
1937                                                          # twig_to_be_normalized
1938        7518    100                       27251           if( $parent->{twig_to_be_normalized}) { $parent->normalize; $parent->{twig_to_be_normalized}=0; }
               5                                 19   
               5                                 20   
1939                                                        }
1940                                                  
1941       10272    100                       33185       if( $t->{extra_data}) 
1942         317                               1450         { $elt->_set_extra_data_before_end_tag( $t->{extra_data});  
1943         317                               1137           $t->{extra_data}='';
1944                                                        }
1945                                                  
1946       10272    100                       32065       if( $t->{twig_handlers})
1947                                                        { # look for handlers
1948        3099                              14054           my @handlers= _handler( $t, $t->{twig_handlers}, $gi);
1949                                                          
1950        3099    100                       12506           if( $t->{twig_tdh})
1951          48    100                         125             { if( @handlers) { push @{$t->{twig_handlers_to_trigger}}, [ $elt, \@handlers ]; }
              29                                 44   
              29                                242   
1952          48    100                         325               if( my $all= $t->{twig_handlers}->{handlers}->{$ALL}) 
1953          12                                 17                 { push @{$t->{twig_handlers_to_trigger}}, [ $elt, [$all] ]; }
              12                                 79   
1954                                                            }
1955                                                          else
1956                                                            {
1957        3051                               6630               local $_= $elt; # so we can use $_ in the handlers
1958                                                      
1959        3051                               9137               foreach my $handler ( @handlers)
1960         535    100                        2188                 { $handler->($t, $elt) || last; }
1961                                                              # call _all_ handler if needed
1962        3039    100                       31825               if( my $all= $t->{twig_handlers}->{handlers}->{$ALL})
1963          33                                123                 { $all->($t, $elt); }
1964                                                            }
1965                                                        }
1966                                                  
1967                                                      # if twig_roots is set for the element then set appropriate handler
1968       10260    100    100                41205       if(  $t->{twig_root_depth} and ($p->depth == $t->{twig_root_depth}) )
1969          76    100                        1513         { if( $t->{twig_default_print})
1970                                                            { # select the proper fh (and store the currently selected one)
1971          24                                 86               $t->_set_fh_to_twig_output_fh(); 
1972          24    100                         109               if( $t->{twig_keep_encoding})
1973           5                                 78                 { $p->setHandlers( %twig_handlers_roots_print_original); }
1974                                                              else
1975          19                                233                 { $p->setHandlers( %twig_handlers_roots_print); }
1976                                                            }
1977                                                          else
1978          52                                751             { $p->setHandlers( %twig_handlers_roots); }
1979                                                        }
1980                                                  
1981  ***  10260    100     66                76115       if( $elt->{'att'}->{'xml:space'} && (  $elt->{'att'}->{'xml:space'} eq 'preserve')) { $t->{twig_preserve_space}--; }
               1                                  4   
1982                                                  
1983       10260                              14351       pop @{$t->{_twig_context_stack}};
           10260                              35899   
1984       10260                              41547       return;
1985                                                    }
1986                                                  
1987                                                  sub _trigger_tdh
1988           4                    4            14     { my( $t)= @_;
1989                                                  
1990  ***      4     50                           8       if( @{$t->{twig_handlers_to_trigger}})
               4                                 18   
1991           4                                  7         { my @handlers_to_trigger_now= sort { $a->[0]->cmp( $b->[0]) } @{$t->{twig_handlers_to_trigger}};
              78                                380   
               4                                  6   
1992           4                                 34           foreach my $elt_handlers (@handlers_to_trigger_now)
1993          41                                132             { my( $handled_elt, $handlers_to_trigger)= @$elt_handlers;
1994          41                                110               foreach my $handler ( @$handlers_to_trigger) 
1995  ***     41     50                          78                 { local $_= $handled_elt; $handler->($t, $handled_elt) || last; }
              41                                123   
1996                                                            }
1997                                                        }
1998           4                                 15       return;
1999                                                    }
2000                                                  
2001                                                  # return the list of handler that can be activated for an element 
2002                                                  # (either of CODE ref's or 1's for twig_roots)
2003                                                  
2004                                                  sub _handler
2005        3705                 3705         17798     { my( $t, $handlers, $gi)= @_;
2006                                                  
2007        3705                              10274       my @found_handlers=();
2008        3705                               5076       my $found_handler;
2009                                                  
2010        3705                              27104       foreach my $handler ( map { @$_ } grep { $_ } $handlers->{xpath_handler}->{$gi}, $handlers->{xpath_handler}->{'*'})
             777                               3227   
            7410                              25032   
2011        1075                               3533         {  my $trigger= $handler->{trigger};
2012        1075    100                        5017            if( my $found_path= $trigger->( $t->{_twig_context_stack}))
2013         695                               2316             { my $found_handler= $handler->{handler};
2014         695                               3358               push @found_handlers, $found_handler; 
2015                                                            }
2016                                                        }
2017                                                  
2018                                                      # if no handler found call default handler if defined
2019        3705    100    100                36317       if( !@found_handlers && defined $handlers->{handlers}->{$DEFAULT})
2020          41                                201         { push @found_handlers, $handlers->{handlers}->{$DEFAULT}; }
2021                                                  
2022        3705    100    100                17001       if( @found_handlers and $t->{twig_do_not_chain_handlers}) 
2023           1                                  4         { @found_handlers= ($found_handlers[0]); }
2024                                                  
2025        3705                              15194       return @found_handlers; # empty if no handler found
2026                                                  
2027                                                    }
2028                                                  
2029                                                  
2030                                                  sub _replace_prefix
2031         125                  125           478     { my( $t, $name)= @_;
2032         125                                462       my $p= $t->parser;
2033         125                                614       my $uri= $p->namespace( $name);
2034                                                      # try to get the namespace from default if none is found (for attributes)
2035                                                      # this should probably be an option
2036         125    100    100                 3344       if( !$uri and( $name!~/^xml/)) { $uri= $p->expand_ns_prefix( '#default'); }
              34                                150   
2037         125    100                         976       if( $uri)
2038          75    100                         385         { if (my $mapped_prefix= $t->{twig_map_xmlns}->{$uri})
2039          68                                354             { return "$mapped_prefix:$name"; }
2040                                                          else
2041           7                                 25             { my $prefix= _a_proper_ns_prefix( $p, $uri);
2042           7    100                          33               if( $prefix eq '#default') { $prefix=''; }
               1                                  3   
2043           7    100                          54               return $prefix ? "$prefix:$name" : $name; 
2044                                                            }
2045                                                        }
2046                                                      else
2047          50                                211         { return $name; }
2048                                                    }
2049                                                  
2050                                                  
2051                                                  sub _twig_char
2052                                                     { # warn " in _twig_char...\n"; # DEBUG handler
2053                                                      
2054       15976                15976         67009       my ($p, $string)= @_;
2055       15976                              53719       my $t=$p->{twig}; 
2056                                                  
2057       15976    100                       59470       if( $t->{twig_keep_encoding})
2058        6556    100                       21208         { if( !$t->{twig_in_cdata})
2059         461                               1727             { $string= $p->original_string(); }
2060                                                          else
2061                                                            { 
2062          92                   92          1025               use bytes; # > perl 5.5
              92                                222   
              92                                967   
2063        6095    100                       17077               if( length( $string) < 1024)
2064        6055                              21312                 { $string= $p->original_string(); }
2065                                                              else
2066                                                                { #warn "dodgy case";
2067                                                                  # TODO original_string does not hold the entire string, but $string is wrong
2068                                                                  # I believe due to a bug in XML::Parser
2069                                                                  # for now, we use the original string, even if it means that it's been converted to utf8
2070                                                                }
2071                                                            }
2072                                                        }
2073                                                  
2074       15976    100                      153809       if( $t->{twig_input_filter}) { $string= $t->{twig_input_filter}->( $string); }
               2                                 10   
2075       15976    100                       55025       if( $t->{twig_char_handler}) { $string= $t->{twig_char_handler}->( $string); }
               2                                 10   
2076                                                  
2077       15976                              43354       my $elt= $t->{twig_current};
2078                                                  
2079       15976    100                       66418       if(    $t->{twig_in_cdata})
                    100                               
2080                                                        { # text is the continuation of a previously created cdata
2081        6142                              29677           $elt->{cdata}.=  $t->{twig_stored_spaces} . $string;
2082                                                        } 
2083                                                      elsif( $t->{twig_in_pcdata})
2084                                                        { # text is the continuation of a previously created cdata
2085         257    100                         901           if( $t->{extra_data})
2086          72                                449             { $elt->_push_extra_data_in_pcdata( $t->{extra_data}, length( $elt->{pcdata}));
2087          72                                270               $t->{extra_data}='';
2088                                                            }
2089         257                                930           $elt->{pcdata}.=  $string; 
2090                                                        } 
2091                                                      else
2092                                                        { # text is just space, which might be discarded later
2093        9577    100                       38742           if( $string=~/\A\s*\Z/s)
2094                                                            { 
2095        3296    100                       12253               if( $t->{extra_data})
2096                                                                { # we got extra data (comment, pi), lets add the spaces to it
2097          34                                135                   $t->{extra_data} .= $string; 
2098                                                                }
2099                                                              else
2100                                                                { # no extra data, just store the spaces
2101        3262                              13298                   $t->{twig_stored_spaces}.= $string;
2102                                                                }
2103                                                            } 
2104                                                          else
2105        6281                              32616             { my $new_elt= _insert_pcdata( $t, $t->{twig_stored_spaces}.$string);
2106        6281                              17435               delete $elt->{'twig_current'};
2107        6281                              18457               $new_elt->{'twig_current'}=1;
2108        6281                              17906               $t->{twig_current}= $new_elt;
2109        6281                              17638               $t->{twig_in_pcdata}=1;
2110        6281    100                       26754               if( $t->{extra_data})
2111          23                                114                 { $new_elt->_push_extra_data_in_pcdata( $t->{extra_data}, 0);
2112          23                                106                   $t->{extra_data}='';
2113                                                                }
2114                                                            }
2115                                                        }
2116       15976                              30080       return; 
2117                                                    }
2118                                                  
2119                                                  sub _twig_cdatastart
2120                                                     { # warn " in _twig_cdatastart...\n"; # DEBUG handler
2121                                                      
2122          95                   95           295       my $p= shift;
2123          95                                314       my $t=$p->{twig};
2124                                                  
2125          95                                323       $t->{twig_in_cdata}=1;
2126          95                                466       my $cdata=  $t->{twig_elt_class}->new( '#CDATA');
2127          95                                324       my $twig_current= $t->{twig_current};
2128                                                  
2129          95    100                         348       if( $t->{twig_in_pcdata})
2130                                                        { # create the node as a sibling of the #PCDATA
2131  ***     17     50                          54           $cdata->{prev_sibling}=$twig_current; if( $XML::Twig::weakrefs) { weaken( $cdata->{prev_sibling});} ;
              17                                 53   
              17                                 77   
2132          17                                 54           $twig_current->{next_sibling}=  $cdata;
2133          17                                 49           my $parent= $twig_current->{parent};
2134  ***     17     50                          48           $cdata->{parent}=$parent; if( $XML::Twig::weakrefs) { weaken( $cdata->{parent});} ;
              17                                 50   
              17                                 65   
2135  ***     17     50                          46            delete $parent->{empty}; $parent->{last_child}=$cdata; if( $XML::Twig::weakrefs) { weaken( $parent->{last_child});} ;
              17                                 53   
              17                                 44   
              17                                 83   
2136          17                                 59           $t->{twig_in_pcdata}=0;
2137                                                        }
2138                                                      else
2139                                                        { # we have to create a PCDATA element if we need to store spaces
2140  ***     78    100     66                  451           if( $t->_space_policy($XML::Twig::index2gi[$twig_current->{'gi'}]) && $t->{twig_stored_spaces})
2141           5                                 22             { _insert_pcdata( $t, $t->{twig_stored_spaces}); }
2142          78                                267           $t->{twig_stored_spaces}='';
2143                                                        
2144                                                          # create the node as a child of the current element      
2145  ***     78     50                         325           $cdata->{parent}=$twig_current; if( $XML::Twig::weakrefs) { weaken( $cdata->{parent});} ;
              78                                229   
              78                                350   
2146          78    100                         312           if( my $prev_sibling= $twig_current->{last_child})
2147  ***      8     50                          26             { $cdata->{prev_sibling}=$prev_sibling; if( $XML::Twig::weakrefs) { weaken( $cdata->{prev_sibling});} ;
               8                                 27   
               8                                 33   
2148           8                                 38               $prev_sibling->{next_sibling}=  $cdata;
2149                                                            }
2150                                                          else
2151          70                                248             { $twig_current->{first_child}=  $cdata; }
2152  ***     78     50                         215            delete $twig_current->{empty}; $twig_current->{last_child}=$cdata; if( $XML::Twig::weakrefs) { weaken( $twig_current->{last_child});} ;
              78                               2233   
              78                                241   
              78                                563   
2153                                                        
2154                                                        }
2155                                                  
2156          95                                256       delete $twig_current->{'twig_current'};
2157          95                                284       $t->{twig_current}= $cdata;
2158          95                                289       $cdata->{'twig_current'}=1;
2159          95    100                         360       if( $t->{extra_data}) { $cdata->set_extra_data( $t->{extra_data}); $t->{extra_data}='' };
               4                                 18   
               4                                 12   
2160          95                                192       return;
2161                                                    }
2162                                                  
2163                                                  sub _twig_cdataend
2164                                                     { # warn " in _twig_cdataend...\n"; # DEBUG handler
2165                                                      
2166          95                   95           279       my $p= shift;
2167          95                                296       my $t=$p->{twig};
2168                                                  
2169          95                                274       $t->{twig_in_cdata}=0;
2170                                                  
2171          95                                260       my $elt= $t->{twig_current};
2172          95                                255       delete $elt->{'twig_current'};
2173          95                                393       my $cdata= $elt->{cdata};
2174          95                                341       $elt->_set_cdata( $cdata);
2175                                                  
2176          95                                158       push @{$t->{_twig_context_stack}}, { _tag => '#CDATA' };
              95                                606   
2177                                                  
2178          95    100                         434       if( $t->{twig_handlers})
2179                                                        { # look for handlers
2180          16                                 74           my @handlers= _handler( $t, $t->{twig_handlers}, CDATA);
2181          16                                 36           local $_= $elt; # so we can use $_ in the handlers
2182          16    100                          60           foreach my $handler ( @handlers) { $handler->($t, $elt) || last; }
               4                                 16   
2183                                                        }
2184                                                  
2185          95                                143       pop @{$t->{_twig_context_stack}};
              95                                331   
2186                                                  
2187          95                                416       $elt= $elt->{parent};
2188          95                                279       $t->{twig_current}= $elt;
2189          95                                292       $elt->{'twig_current'}=1;
2190                                                  
2191          95                                326       $t->{twig_long_cdata}=0;
2192          95                                194       return;
2193                                                    }
2194                                                  
2195                                                  sub _pi_elt_handlers
2196        1463                 1463          7390     { my( $t, $pi)= @_;
2197  ***   1463            66                11112       my $pi_handlers= $t->{twig_handlers}->{pi_handlers} || return;
2198           7                                 59       foreach my $handler ( $pi_handlers->{$pi->{target}}, $pi_handlers->{''})
2199  ***     14     50                          67         { if( $handler) { local $_= $pi; $handler->( $t, $pi) || last; } }
               7    100                          15   
               7                                 25   
2200                                                    }
2201                                                  
2202                                                  sub _pi_text_handler
2203        1503                 1503          6627     { my( $t, $target, $data)= @_;
2204        1503    100                       10352       if( my $handler= $t->{twig_handlers}->{pi_handlers}->{$target})
2205           1                                  5         { return $handler->( $t, $target, $data); }
2206        1502    100                        7944       if( my $handler= $t->{twig_handlers}->{pi_handlers}->{''})
2207           1                                  6         { return $handler->( $t, $target, $data); }
2208        1501    100    100                19921       return defined( $data) && $data ne ''  ? "<?$target $data?>" : "<?$target?>" ;
2209                                                    }
2210                                                  
2211                                                  sub _comment_elt_handler
2212        1753                 1753          6054     { my( $t, $comment)= @_; 
2213        1753    100                       15605       if( my $handler= $t->{twig_handlers}->{handlers}->{'#COMMENT'})
2214           6                                 15         { local $_= $comment; $handler->($t, $comment); }
               6                                 25   
2215                                                    }
2216                                                  
2217                                                  sub _comment_text_handler
2218        1879                 1879          7157     { my( $t, $comment)= @_; 
2219        1879    100                       13523       if( my $handler= $t->{twig_handlers}->{handlers}->{'#COMMENT'})
2220           4                                 18         { $comment= $handler->($t, $comment); 
2221           4    100    100                   89           if( !defined $comment || $comment eq '') { return ''; }
               2                                  9   
2222                                                        }
2223        1877                              10246       return "<!--$comment-->";
2224                                                    }
2225                                                  
2226                                                  
2227                                                  
2228                                                  sub _twig_comment
2229                                                     { # warn " in _twig_comment...\n"; # DEBUG handler
2230                                                      
2231        3637                 3637         16773       my( $p, $comment_text)= @_;
2232        3637                              13777       my $t=$p->{twig};
2233                                                  
2234        3637    100                       15600       if( $t->{twig_keep_encoding}) { $comment_text= substr( $p->original_string(), 4, -3); }
            1751                               7350   
2235                                                      
2236        3637                              60259       $t->_twig_pi_comment( $p, '#COMMENT', $t->{twig_keep_comments}, $t->{twig_process_comments},
2237                                                                            '_set_comment', '_comment_elt_handler', '_comment_text_handler', $comment_text
2238                                                                          );
2239        3637                               8722       return;
2240                                                    }
2241                                                  
2242                                                  sub _twig_pi
2243                                                     { # warn " in _twig_pi...\n"; # DEBUG handler
2244                                                      
2245        2972                 2972         16027       my( $p, $target, $data)= @_;
2246        2972                              11684       my $t=$p->{twig};
2247                                                  
2248        2972    100                       12157       if( $t->{twig_keep_encoding}) 
2249        1459                               6180         { my $pi_text= substr( $p->original_string(), 2, -2); 
2250        1459                              33363           ($target, $data)= split( /\s+/, $pi_text, 2);
2251                                                        }
2252                                                  
2253        2972                              24428       $t->_twig_pi_comment( $p, '#PI', $t->{twig_keep_pi}, $t->{twig_process_pi},
2254                                                                            '_set_pi', '_pi_elt_handlers', '_pi_text_handler', $target, $data
2255                                                                          );
2256        2972                               7031       return;
2257                                                    }
2258                                                  
2259                                                  sub _twig_pi_comment
2260        6609                 6609         65316     { my( $t, $p, $type, $keep, $process, $set, $elt_handler, $text_handler, @parser_args)= @_;
2261                                                  
2262        6609    100                       35031       if( $t->{twig_input_filter})
2263           2                                  6             { foreach my $arg (@parser_args) { $arg= $t->{twig_input_filter}->( $arg); } }
               3                                 21   
2264                                                            
2265                                                      # if pi/comments are to be kept then we piggiback them to the current element
2266        6609    100                       22012       if( $keep)
                    100                               
2267                                                        { # first add spaces
2268        3382    100                       11852           if( $t->{twig_stored_spaces})
2269          22                                100                 { $t->{extra_data}.= $t->{twig_stored_spaces};
2270          22                                 77                   $t->{twig_stored_spaces}= '';
2271                                                                }
2272                                                  
2273        3382                              13384           my $extra_data= $t->$text_handler( @parser_args);
2274        3382                              18380           $t->{extra_data}.= $extra_data;
2275                                                  
2276                                                        }
2277                                                      elsif( $process)
2278                                                        {
2279        3216                               9624           my $twig_current= $t->{twig_current}; # defined unless we are outside of the root
2280                                                  
2281        3216                              17146           my $elt= $t->{twig_elt_class}->new( $type);
2282        3216                              12352           $elt->$set( @parser_args);
2283        3216    100                       12694           if( $t->{extra_data}) 
2284         676                               2708             { $elt->set_extra_data( $t->{extra_data});
2285         676                               2384               $t->{extra_data}='';
2286                                                            }
2287                                                  
2288        3216    100                        9761           unless( $t->root) 
                    100                               
                    100                               
2289        1451                               4960             { $t->_add_cpi_outside_of_root( leading_cpi => $elt);
2290                                                            }
2291                                                          elsif( $t->{twig_in_pcdata})
2292                                                            { # create the node as a sibling of the #PCDATA
2293           7                                 32               $elt->paste_after( $twig_current);
2294           7                                 26               $t->{twig_in_pcdata}=0;
2295                                                            }
2296                                                          elsif( $twig_current)
2297                                                            { # we have to create a PCDATA element if we need to store spaces
2298  ***    312    100     66                 2005               if( $t->_space_policy($XML::Twig::index2gi[$twig_current->{'gi'}]) && $t->{twig_stored_spaces})
2299           1                                  6                 { _insert_pcdata( $t, $t->{twig_stored_spaces}); }
2300         312                               1082               $t->{twig_stored_spaces}='';
2301                                                              # create the node as a child of the current element
2302         312                               1045               $elt->paste_last_child( $twig_current);
2303                                                            }
2304                                                          else
2305        1446                               4872             { $t->_add_cpi_outside_of_root( trailing_cpi => $elt); }
2306                                                  
2307        3216    100                        8853           if( $twig_current)
2308         319                                899             { delete $twig_current->{'twig_current'};
2309         319                                976               my $parent= $elt->{parent};
2310         319                               1059               $t->{twig_current}= $parent;
2311         319                               1102               $parent->{'twig_current'}=1;
2312                                                            }
2313                                                  
2314        3216                              12668           $t->$elt_handler( $elt);
2315                                                        }
2316                                                  
2317                                                    }
2318                                                      
2319                                                  
2320                                                  # add a comment or pi before the first element
2321                                                  sub _add_cpi_outside_of_root
2322        2902                 2902         12443     { my($t, $type, $elt)= @_; # $type is 'leading_cpi' or 'trailing_cpi'
2323  ***   2902            66                18364       $t->{$type} ||= $t->{twig_elt_class}->new( '#CPI');
2324                                                      # create the node as a child of the current element
2325        2902                              12648       $elt->paste_last_child( $t->{$type});
2326        2902                               6862       return $t;
2327                                                    }
2328                                                    
2329                                                  sub _twig_final
2330                                                     { # warn " in _twig_final...\n"; # DEBUG handler
2331                                                      
2332        2767                 2767         80264       my $p= shift;
2333        2767    100                       28226       my $t= $p->isa( 'XML::Twig') ? $p : $p->{twig};
2334                                                  
2335                                                      # store trailing data
2336        2767    100                       11283       if( $t->{extra_data}) { $t->{trailing_cpi_text} = $t->{extra_data}; $t->{extra_data}=''; }
             579                               2975   
             579                               1873   
2337        2767           100                27724       $t->{trailing_spaces}= $t->{twig_stored_spaces} || ''; 
2338        2767                               8815       my $s=  $t->{twig_stored_spaces}; $s=~s{\n}{\\n}g;
            2767                               7989   
2339        2767    100                       10517       if( $t->{twig_stored_spaces}) { my $s=  $t->{twig_stored_spaces}; }
             236                                843   
2340                                                  
2341                                                      # restore the selected filehandle if needed
2342        2767                               9597       $t->_set_fh_to_selected_fh();
2343                                                  
2344        2767    100                        9778       $t->_trigger_tdh if( $t->{twig_tdh});
2345                                                  
2346        2767    100                        8963       select $t->{twig_original_selected_fh} if($t->{twig_original_selected_fh}); # probably dodgy
2347                                                  
2348        2767    100                        9506       if( exists $t->{twig_autoflush_data})
2349          11                                 21         { my @args;
2350          11    100                          52           push @args,  $t->{twig_autoflush_data}->{fh}      if( $t->{twig_autoflush_data}->{fh});
2351          11    100                          80           push @args,  @{$t->{twig_autoflush_data}->{args}} if( $t->{twig_autoflush_data}->{args});
               1                                  7   
2352          11                                 43           $t->flush( @args);
2353          11                                 43           delete $t->{twig_autoflush_data};
2354          11                                 74           $t->root->delete;
2355                                                        }
2356                                                  
2357                                                      # tries to clean-up (probably not very well at the moment)
2358                                                      #undef $p->{twig};
2359        2767                               8905       undef $t->{twig_parser};
2360        2767                               9146       delete $t->{twig_parsing};
2361        2767                               7834       @{$t}{ qw( twig_parser twig_parsing _twig_context_stack twig_current) }=();
            2767                              16708   
2362                                                  
2363        2767                              14089       return $t;
2364                                                    }
2365                                                  
2366                                                  sub _insert_pcdata
2367        6377                 6377         24907     { my( $t, $string)= @_;
2368                                                      # create a new #PCDATA element
2369        6377                              21853       my $parent= $t->{twig_current};    # always defined
2370        6377                              30371       my $elt=  $t->{twig_elt_class}->new( PCDATA);
2371        6377                              20198       $elt->_set_pcdata( $string);
2372        6377                              18632       my $prev_sibling= $parent->{last_child};
2373        6377    100                       15483       if( $prev_sibling) 
2374         156                                560         { $prev_sibling->{next_sibling}=  $elt; 
2375  ***    156     50                         450           $elt->{prev_sibling}=$prev_sibling; if( $XML::Twig::weakrefs) { weaken( $elt->{prev_sibling});} ;
             156                                485   
             156                                721   
2376                                                        }
2377                                                      else
2378        6221                              21010         { $parent->{first_child}=  $elt; }
2379                                                  
2380        6377    100                       18388       $elt->{parent}=$parent; if( $XML::Twig::weakrefs) { weaken( $elt->{parent});} ;
            6377                              17322   
            6376                              26845   
2381        6377    100                       18053        delete $parent->{empty}; $parent->{last_child}=$elt; if( $XML::Twig::weakrefs) { weaken( $parent->{last_child});} ;
            6377                              18676   
            6377                              16924   
            6376                              30106   
2382        6377                              21019       $t->{twig_stored_spaces}='';
2383        6377                              19578       return $elt;
2384                                                    }
2385                                                  
2386                                                  sub _space_policy
2387         845                  845          3764     { my( $t, $gi)= @_;
2388         845                               1742       my $policy;
2389         845    100                        3877       $policy=0 if( $t->{twig_discard_spaces});
2390         845    100                        3202       $policy=1 if( $t->{twig_keep_spaces});
2391         845    100    100                 3721       $policy=1 if( $t->{twig_keep_spaces_in}
2392                                                                 && $t->{twig_keep_spaces_in}->{$gi});
2393         845    100    100                 3947       $policy=0 if( $t->{twig_discard_spaces_in} 
2394                                                                 && $t->{twig_discard_spaces_in}->{$gi});
2395         845                               4703       return $policy;
2396                                                    }
2397                                                  
2398                                                  
2399                                                  sub _twig_entity($$$$$$)
2400                                                     { # warn " in _twig_entity...\n"; # DEBUG handler
2401                                                      
2402          68                   68           465       my( $p, $name, $val, $sysid, $pubid, $ndata, $param)= @_;
2403          68                                279       my $t=$p->{twig};
2404                                                  
2405                                                      #{ no warnings; my $base= $p->base; warn "_twig_entity called: expand: '$t->{twig_expand_external_ents}', base: '$base', name: '$name', val: '$val', sysid: '$sysid', pubid: '$pubid', ndata: '$ndata', param: '$param'\n";}
2406                                                  
2407          68                                131       my $missing_entity=0;
2408                                                  
2409          68    100                         210       if( $sysid) 
2410          31    100                          86         { if($ndata)
2411          15    100                          78             { if( ! -f _based_filename( $sysid, $p->base)) { $missing_entity= 1; }
              14                                 54   
2412                                                            }
2413                                                          else
2414          16    100                          75             { if( $t->{twig_expand_external_ents})
2415           4                                  4                 { $val= eval { _slurp_uri( $sysid, $p->base) };
               4                                 20   
2416           4    100                          21                   if( ! defined $val) 
2417           2    100                          12                     { if( $t->{twig_extern_ent_nofail}) 
2418           1                                  4                         { $missing_entity= 1; }
2419                                                                      else
2420           1                                 10                         { _croak( "cannot load SYSTEM entity '$name' from '$sysid': $@", 3); }
2421                                                                    }
2422                                                                }
2423                                                            }
2424                                                        }
2425                                                  
2426          67                                461       my $ent=XML::Twig::Entity->new( $name, $val, $sysid, $pubid, $ndata, $param);
2427          67    100                         211       if( $missing_entity) { $t->{twig_missing_system_entities}->{$name}= $ent; }
              15                                 92   
2428                                                  
2429          67                                264       my $entity_list= $t->entity_list;
2430  ***     67     50                         224       if( $entity_list) { $entity_list->add( $ent); }
              67                                233   
2431                                                  
2432  ***     67     50                         247       if( $parser_version > 2.27) 
2433                                                        { # this is really ugly, but with some versions of XML::Parser the value 
2434                                                          # of the entity is not properly returned by the default handler
2435          67                                219           my $ent_decl= $ent->text;
2436          67    100                         350           if( $t->{twig_keep_encoding})
2437  ***      3     50     33                   66             { if( defined $ent->{val} && ($ent_decl !~ /["']/))
2438  ***      0                                  0                 { my $val=  $ent->{val};
2439  ***      0      0                           0                   $ent_decl .= $val =~ /"/ ? qq{'$val' } : qq{"$val" }; 
2440                                                                }
2441                                                              # for my solaris box (perl 5.6.1, XML::Parser 2.31, expat?)
2442           3                                115               $t->{twig_doctype}->{internal}=~ s{<!ENTITY\s+$name\s+$}{substr( $ent_decl, 0, -1)}e;
      ***      0                                  0   
2443                                                            }
2444  ***     67     50                        2168           $t->{twig_doctype}->{internal} .= $ent_decl 
2445                                                            unless( $t->{twig_doctype}->{internal}=~ m{<!ENTITY\s+$name\s+});
2446                                                        }
2447                                                  
2448          67                                197       return;
2449                                                    }
2450                                                  
2451                                                  
2452                                                  sub _twig_extern_ent
2453                                                     { # warn " in _twig_extern_ent...I (", $_[0]->original_string, ")\n"; # DEBUG handler
2454           7                    7            39       my( $p, $base, $sysid, $pubid)= @_;
2455           7                                 25       my $t= $p->{twig};
2456  ***      7     50                          30       if( $t->{twig_no_expand}) 
2457  ***      0      0                           0         { my $ent_name= $t->{twig_keep_encoding} ? $p->original_string : $p->recognized_string;
2458  ***      0                                  0           _twig_insert_ent( $t, $ent_name);
2459  ***      0                                  0           return '';
2460                                                        }
2461           7                                  7       my $ent_content= eval { $t->{twig_ext_ent_handler}->( $p, $base, $sysid) };
               7                                 40   
2462           7    100                        1365       if( ! defined $ent_content)
2463                                                        { 
2464           1                                  6           my $ent_name = $p->recognized_string;
2465           1                                 21           my $file     =  _based_filename( $sysid, $base);
2466           1                                  8           my $error_message= "cannot expand $ent_name - cannot load '$file'";
2467  ***      1     50                           6           if( $t->{twig_extern_ent_nofail}) { return "<!-- $error_message -->"; }
      ***      0                                  0   
2468           1                                  5           else                              { _croak( $error_message);   }
2469                                                        }
2470           6                                 14       return $ent_content; 
2471                                                    }
2472                                                  
2473                                                  # I use this so I can change the $Carp::CarpLevel (which determines how many call frames to skip when reporting an error)
2474                                                  sub _croak
2475          42                   42           174     { my( $message, $level)= @_;
2476          42           100                  322       $Carp::CarpLevel= $level || 0;
2477          42                                153       croak $message;
2478                                                    }
2479                                                  
2480                                                  sub _twig_xmldecl
2481                                                     { # warn " in _twig_xmldecl...\n"; # DEBUG handler
2482                                                      
2483         102                  102           453       my $p= shift;
2484         102                                384       my $t=$p->{twig};
2485  ***    102            50                  620       $t->{twig_xmldecl}||={};                 # could have been set by set_output_encoding
2486         102                                604       $t->{twig_xmldecl}->{version}= shift;
2487         102                                479       $t->{twig_xmldecl}->{encoding}= shift; 
2488         102                                452       $t->{twig_xmldecl}->{standalone}= shift;
2489         102                                220       return;
2490                                                    }
2491                                                  
2492                                                  sub _twig_doctype
2493                                                     { # warn " in _twig_doctype...\n"; # DEBUG handler
2494          77                   77           602       my( $p, $name, $sysid, $pub, $internal)= @_;
2495          77                                347       my $t=$p->{twig};
2496  ***     77            50                  484       $t->{twig_doctype}||= {};                   # create 
2497          77                                434       $t->{twig_doctype}->{name}= $name;          # always there
2498          77                                329       $t->{twig_doctype}->{sysid}= $sysid;        #  
2499          77                                317       $t->{twig_doctype}->{pub}= $pub;            #  
2500                                                  
2501                                                      # now let's try to cope with XML::Parser 2.28 and above
2502  ***     77     50                         319       if( $parser_version > 2.27)
2503          77                                572         { @saved_default_handler= $p->setHandlers( Default     => \&_twig_store_internal_dtd,
2504                                                                                                   Entity      => \&_twig_entity,
2505                                                                                                 );
2506          77                               6632         $p->setHandlers( DoctypeFin  => \&_twig_stop_storing_internal_dtd);
2507          77                               3721         $t->{twig_doctype}->{internal}='';
2508                                                        }
2509                                                      else            
2510                                                        # for XML::Parser before 2.28
2511  ***      0             0                    0         { $internal||='';
2512  ***      0                                  0           $internal=~ s{^\s*\[}{}; 
2513  ***      0                                  0           $internal=~ s{]\s*$}{}; 
2514  ***      0                                  0           $t->{twig_doctype}->{internal}=$internal; 
2515                                                        }
2516                                                  
2517                                                      # now check if we want to get the DTD info
2518          77    100    100                  524       if( $t->{twig_read_external_dtd} && $sysid)
2519                                                        { # let's build a fake document with an internal DTD
2520           5                                 37           my $dtd=  "<!DOCTYPE $name [" . _slurp_uri( $sysid) .  "]><$name/>";
2521                                                         
2522           5                                 28           $t->save_global_state();            # save the globals (they will be reset by the following new)  
2523           5           100                   76           my $t_dtd= XML::Twig->new( load_DTD => 1, ParseParamEnt => 1, error_context => $t->{ErrorContext} || 0);          # create a temp twig
2524           5                                 33           $t_dtd->parse( $dtd);               # parse it
2525           5                                 26           $t->{twig_dtd}= $t_dtd->{twig_dtd}; # grab the dtd info
2526                                                          #$t->{twig_dtd_is_external}=1;
2527  ***      5     50                          21           $t->entity_list->_add_list( $t_dtd->entity_list) if( $t_dtd->entity_list); # grab the entity info
2528           5                                 22           $t->restore_global_state();
2529                                                        }
2530          77                                316       return;
2531                                                    }
2532                                                  
2533                                                  sub _twig_element
2534                                                     { # warn " in _twig_element...\n"; # DEBUG handler
2535                                                      
2536          44                   44           251       my( $p, $name, $model)= @_;
2537          44                                172       my $t=$p->{twig};
2538          44           100                  219       $t->{twig_dtd}||= {};                      # may create the dtd 
2539          44           100                  233       $t->{twig_dtd}->{model}||= {};             # may create the model hash 
2540          44           100                  244       $t->{twig_dtd}->{elt_list}||= [];          # ordered list of elements 
2541          44                                107       push @{$t->{twig_dtd}->{elt_list}}, $name; # store the elt
              44                                228   
2542          44                                233       $t->{twig_dtd}->{model}->{$name}= $model;  # store the model
2543  ***     44     50     33                 1707       if( ($parser_version > 2.27) && ($t->{twig_doctype}->{internal}=~ m{(^|>)\s*$}) ) 
2544  ***     44     50                         314         { my $text= $XML::Twig::Elt::keep_encoding ? $p->original_string : $p->recognized_string; 
2545  ***     44     50                         957           unless( $text)
2546                                                            { # this version of XML::Parser does not return the text in the *_string method
2547                                                              # we need to rebuild it
2548          44                                 67               $text= "<!ELEMENT $name $model>";
2549                                                            }
2550          44                               3151           $t->{twig_doctype}->{internal} .= $text;
2551                                                        }
2552          44                                113       return;
2553                                                    }
2554                                                  
2555                                                  sub _twig_attlist
2556                                                     { # warn " in _twig_attlist...\n"; # DEBUG handler
2557                                                      
2558          37                   37           257       my( $p, $gi, $att, $type, $default, $fixed)= @_;
2559                                                      #warn "in attlist: gi: '$gi', att: '$att', type: '$type', default: '$default', fixed: '$fixed'\n";
2560          37                                142       my $t=$p->{twig};
2561  ***     37            50                  147       $t->{twig_dtd}||= {};                      # create dtd if need be 
2562          37           100                  178       $t->{twig_dtd}->{$gi}||= {};               # create elt if need be 
2563                                                      #$t->{twig_dtd}->{$gi}->{att}||= {};        # create att if need be 
2564  ***     37     50     33                 2830       if( ($parser_version > 2.27) && ($t->{twig_doctype}->{internal}=~ m{(^|>)\s*$}) ) 
2565  ***     37     50                         232         { my $text= $XML::Twig::Elt::keep_encoding ? $p->original_string : $p->recognized_string; 
2566  ***     37     50                         720           unless( $text)
2567                                                            { # this version of XML::Parser does not return the text in the *_string method
2568                                                              # we need to rebuild it
2569          37                                149               my $att_decl="$att $type";
2570          37    100                         112               $att_decl .= " #FIXED"   if( $fixed);
2571  ***     37     50                         144               $att_decl .= " $default" if( defined $default);
2572                                                              # 2 cases: there is already an attlist on that element or not
2573          37    100                         211               if( $t->{twig_dtd}->{att}->{$gi})
2574                                                                { # there is already an attlist, add to it
2575          15                                597                   $t->{twig_doctype}->{internal}=~ s{(<!ATTLIST\s*$gi )(.*?)\n?>}
              15                                213   
2576                                                                                                    { "$1$2\n" . ' ' x length( $1) . "$att_decl\n>"}es;
2577                                                                }
2578                                                              else
2579                                                                { # create the attlist
2580          22                                187                    $t->{twig_doctype}->{internal}.= "<!ATTLIST $gi $att_decl>"
2581                                                                }
2582                                                            }
2583                                                        }
2584          37                                351       $t->{twig_dtd}->{att}->{$gi}->{$att}= {} ;
2585          37                                270       $t->{twig_dtd}->{att}->{$gi}->{$att}->{type}= $type; 
2586  ***     37     50                         292       $t->{twig_dtd}->{att}->{$gi}->{$att}->{default}= $default if( defined $default);
2587          37                                223       $t->{twig_dtd}->{att}->{$gi}->{$att}->{fixed}= $fixed; 
2588          37                                 74       return;
2589                                                    }
2590                                                  
2591                                                  sub _twig_default
2592                                                     { # warn " in _twig_default...\n"; # DEBUG handler
2593                                                      
2594         333                  333          1651       my( $p, $string)= @_;
2595                                                      
2596         333                               1276       my $t= $p->{twig};
2597                                                     
2598                                                      # we need to process the data in 2 cases: entity, or spaces after the closing tag
2599                                                  
2600                                                      # after the closing tag (no twig_current and root has been created)
2601         333    100    100                 5493       if(  ! $t->{twig_current} && $t->{twig_root} && $string=~ m{^\s+$}m) { $t->{twig_stored_spaces} .= $string; }
      ***    236            66                  985   
2602                                                  
2603                                                      # process only if we have an entity
2604         333    100                        1887       if( $string=~ m{^&([^;]*);$})
2605                                                        { # the entity has to be pure pcdata, or we have a problem
2606  ***     36     50     33                 1022           if( ($p->original_string=~ m{^<}) && ($p->original_string=~ m{>$}) ) 
2607                                                            { # string is a tag, entity is in an attribute
2608  ***      0      0                           0               $t->{twig_entities_in_attribute}=1 if( $t->{twig_do_not_escape_amp_in_atts});
2609                                                            }
2610                                                          else
2611          36                                751             { my $ent;
2612          36    100                         145               if( $t->{twig_keep_encoding}) 
2613           9                                 32                 { _twig_char( $p, $string); 
2614           9                                 50                   $ent= substr( $string, 1, -1);
2615                                                                }
2616                                                              else
2617          27                                 86                 { $ent= _twig_insert_ent( $t, $string); 
2618                                                                }
2619                                                  
2620          36                                101               return $ent;
2621                                                            }
2622                                                          return
2623  ***      0                                  0         }
2624                                                    }
2625                                                      
2626                                                  sub _twig_insert_ent
2627                                                    { 
2628          27                   27           109       my( $t, $string)=@_;
2629                                                  
2630          27                               1043       my $twig_current= $t->{twig_current};
2631                                                  
2632          27                                131       my $ent=  $t->{twig_elt_class}->new( '#ENT');
2633          27                                 95       $ent->{ent}=  $string;
2634                                                  
2635          27                                 82       _add_or_discard_stored_spaces( $t, force => 0);
2636                                                      
2637          27    100                         107       if( $t->{twig_in_pcdata})
2638                                                        { # create the node as a sibling of the #PCDATA
2639                                                  
2640  ***     13     50                          44           $ent->{prev_sibling}=$twig_current; if( $XML::Twig::weakrefs) { weaken( $ent->{prev_sibling});} ;
              13                                 38   
              13                                 62   
2641          13                                 40           $twig_current->{next_sibling}=  $ent;
2642          13                                 39           my $parent= $twig_current->{parent};
2643  ***     13     50                          40           $ent->{parent}=$parent; if( $XML::Twig::weakrefs) { weaken( $ent->{parent});} ;
              13                                 40   
              13                                 53   
2644  ***     13     50                          30            delete $parent->{empty}; $parent->{last_child}=$ent; if( $XML::Twig::weakrefs) { weaken( $parent->{last_child});} ;
              13                                 42   
              13                                 37   
              13                                 62   
2645                                                          # the twig_current is now the parent
2646          13                                 35           delete $twig_current->{'twig_current'};
2647          13                                 40           $t->{twig_current}= $parent;
2648                                                          # we left pcdata
2649          13                                 40           $t->{twig_in_pcdata}=0;
2650                                                        }
2651                                                      else
2652                                                        { # create the node as a child of the current element
2653  ***     14     50                          46           $ent->{parent}=$twig_current; if( $XML::Twig::weakrefs) { weaken( $ent->{parent});} ;
              14                                 39   
              14                                 62   
2654          14    100                          55           if( my $prev_sibling= $twig_current->{last_child})
2655  ***      8     50                          24             { $ent->{prev_sibling}=$prev_sibling; if( $XML::Twig::weakrefs) { weaken( $ent->{prev_sibling});} ;
               8                                 22   
               8                                 32   
2656           8                                 27               $prev_sibling->{next_sibling}=  $ent;
2657                                                            }
2658                                                          else
2659  ***      6     50                          17             { if( $twig_current) { $twig_current->{first_child}=  $ent; } }
               6                                 21   
2660  ***     14     50                          38           if( $twig_current) {  delete $twig_current->{empty}; $twig_current->{last_child}=$ent; if( $XML::Twig::weakrefs) { weaken( $twig_current->{last_child});} ; }
      ***     14     50                          33   
              14                                 43   
              14                                 37   
              14                                 72   
2661                                                        }
2662                                                  
2663                                                      # meant to trigger entity handler, does not seem to be activated at this time
2664                                                      #if( my $handler= $t->{twig_handlers}->{gi}->{'#ENT'})
2665                                                      #  { local $_= $ent; $handler->( $t, $ent); }
2666                                                  
2667          27                                 92       return $ent;
2668                                                    }
2669                                                  
2670                                                  sub parser
2671         231                  231          1351     { return $_[0]->{twig_parser}; }
2672                                                  
2673                                                  # returns the declaration text (or a default one)
2674                                                  sub xmldecl
2675        2271                 2271          5578     { my $t= shift;
2676        2271    100    100                31177       return '' unless( $t->{twig_xmldecl} || $t->{output_encoding});
2677          55                                 95       my $decl_string;
2678          55                                178       my $decl= $t->{twig_xmldecl};
2679          55    100                         155       if( $decl)
2680          51                                152         { my $version= $decl->{version};
2681          51                                107           $decl_string= q{<?xml};
2682          51                                242           $decl_string .= qq{ version="$version"};
2683                                                  
2684                                                          # encoding can either have been set (in $decl->{output_encoding})
2685                                                          # or come from the document (in $decl->{encoding})
2686          51    100                         329           if( $t->{output_encoding})
                    100                               
2687          13                                123             { my $encoding= $t->{output_encoding};
2688          13                                 54               $decl_string .= qq{ encoding="$encoding"};
2689                                                            }
2690                                                          elsif( $decl->{encoding})
2691          15                                 47             { my $encoding= $decl->{encoding};
2692          15                                 62               $decl_string .= qq{ encoding="$encoding"};
2693                                                            }
2694                                                      
2695          51    100                         292           if( defined( $decl->{standalone}))
2696          10                                 27             { $decl_string .= q{ standalone="};  
2697          10    100                          47               $decl_string .= $decl->{standalone} ? "yes" : "no";  
2698          10                                 28               $decl_string .= q{"}; 
2699                                                            }
2700                                                        
2701          51                                147           $decl_string .= "?>\n";
2702                                                        }
2703                                                      else
2704           4                                 26         { my $encoding= $t->{output_encoding};
2705           4                                 23           $decl_string= qq{<?xml version="1.0" encoding="$encoding"?>};
2706                                                        }
2707                                                        
2708          55                                178       my $output_filter= XML::Twig::Elt::output_filter();
2709          55    100                         431       return $output_filter ? $output_filter->( $decl_string) : $decl_string;
2710                                                    }
2711                                                  
2712                                                  sub set_doctype
2713           4                    4            41     { my( $t, $name, $system, $public, $internal)= @_;
2714           4    100                          28       $t->{twig_doctype}= {} unless defined $t->{twig_doctype};
2715           4                                 13       my $doctype= $t->{twig_doctype};
2716  ***      4     50                          23       $doctype->{name}     = $name     if( defined $name);
2717           4    100                          17       $doctype->{sysid}    = $system   if( defined $system);
2718           4    100                          16       $doctype->{pub}      = $public   if( defined $public);
2719           4    100                          22       $doctype->{internal} = $internal if( defined $internal);
2720                                                    }
2721                                                  
2722                                                  sub doctype_name
2723           4                    4            34     { my $t= shift;
2724           4    100                          28       my $doctype= $t->{twig_doctype} or return '';
2725  ***      3            50                   25       return $doctype->{name} || '';
2726                                                    }
2727                                                  
2728                                                  sub system_id
2729           4                    4            14     { my $t= shift;
2730           4    100                          26       my $doctype= $t->{twig_doctype} or return '';
2731           3           100                   31       return $doctype->{sysid} || '';
2732                                                    }
2733                                                  
2734                                                  sub public_id
2735           4                    4            13     { my $t= shift;
2736           4    100                          25       my $doctype= $t->{twig_doctype} or return '';
2737           3           100                   35       return $doctype->{pub} || '';
2738                                                    }
2739                                                  
2740                                                  sub internal_subset
2741           4                    4            12     { my $t= shift;
2742           4    100                          26       my $doctype= $t->{twig_doctype} or return '';
2743           3           100                   30       return $doctype->{internal} || '';
2744                                                    }
2745                                                  
2746                                                  # return the dtd object
2747                                                  sub dtd
2748           7                    7            29     { my $t= shift;
2749           7                                 74       return $t->{twig_dtd};
2750                                                    }
2751                                                  
2752                                                  # return an element model, or the list of element models
2753                                                  sub model
2754           3                    3            10     { my $t= shift;
2755           3                                431       my $elt= shift;
2756           3    100                          20       return $t->dtd->{model}->{$elt} if( $elt);
2757           1                                  3       return sort keys %{$t->dtd->{model}};
               1                                  4   
2758                                                    }
2759                                                  
2760                                                          
2761                                                  # return the entity_list object 
2762                                                  sub entity_list($)
2763         157                  157           838     { my $t= shift;
2764         157                                911       return $t->{twig_entity_list};
2765                                                    }
2766                                                  
2767                                                  # return the list of entity names 
2768                                                  sub entity_names($)
2769           6                    6            19     { my $t= shift;
2770           6                                 24       return $t->entity_list->entity_names;
2771                                                    }
2772                                                  
2773                                                  # return the entity object 
2774                                                  sub entity($$)
2775          14                   14           630     { my $t= shift;
2776          14                                 39       my $entity_name= shift;
2777          14                                 48       return $t->entity_list->ent( $entity_name);
2778                                                    }
2779                                                  
2780                                                  
2781                                                  sub print_prolog
2782         886                  886          2557     { my $t= shift;
2783  ***    886     50     33                 3465       my $fh=  _is_fh($_[0])  ? shift : $t->{twig_output_fh} || select() || \*STDOUT;
      ***                   50                        
2784          92                   92           927       no strict 'refs';
              92                                251   
              92                                899   
2785         886                               4522       print {$fh} $t->prolog( @_);
             886                               5469   
2786                                                    }
2787                                                  
2788                                                  sub prolog
2789        2272                 2272          5602     { my $t= shift;
2790        2272    100                        8694       if( $t->{no_prolog}){ return ''; }
               3                                 21   
2791                                                  
2792        2269    100                       17049       return   $t->{no_prolog}             ? '' 
      ***            50                               
2793                                                             : defined $t->{no_dtd_output} ? $t->xmldecl
2794                                                             :                               $t->xmldecl . $t->doctype( @_);
2795                                                    }
2796                                                  
2797                                                  sub doctype
2798        2271                 2271          7251     { my $t= shift;
2799        2271                               6919       my %args= _normalize_args( @_);
2800        2271           100                15781       my $update_dtd = $args{UpdateDTD} || '';
2801        2271                               4389       my $doctype_text='';
2802                                                      
2803        2271                               7280       my $doctype= $t->{twig_doctype};
2804                                                  
2805        2271    100                        5514       if( $doctype)
2806  ***     43     50                         285         { $doctype_text .= qq{<!DOCTYPE $doctype->{name}} if( $doctype->{name});
2807          43    100                         182           $doctype_text .= qq{ PUBLIC "$doctype->{pub}"}  if( $doctype->{pub});
2808          43    100    100                  378           $doctype_text .= qq{ SYSTEM}                    if( $doctype->{sysid} && !$doctype->{pub});
2809          43    100                         269           $doctype_text .= qq{ "$doctype->{sysid}"}       if( $doctype->{sysid});
2810                                                        }
2811                                                  
2812        2271    100                        6958       if( $update_dtd)
                    100                               
2813  ***      9    100     33                   46         { if( $doctype)  
      ***            50                               
2814           7                                 26             { my $internal=$doctype->{internal};
               2                                  7   
2815                                                              # awfull hack, but at least it works a little better that what was there before
2816           7    100                          27               if( $internal)
2817                                                                { # remove entity declarations (they will be re-generated from the updated entity list)
2818           5                                 46                   $internal=~ s{<! \s* ENTITY \s+ $REG_NAME \s+ ( ("[^"]*"|'[^']*') \s* | SYSTEM [^>]*) >\s*}{}xg;
2819           5                                 76                   $internal=~ s{^\n}{};
2820                                                                }
2821  ***      7     50    100                   34               $internal .= $t->entity_list->text ||'' if( $t->entity_list);
2822           7    100                          39               if( $internal) { $doctype_text .= "[\n$internal]>\n"; }
               4                                 26   
2823                                                            }
2824                                                          elsif( !$t->{'twig_dtd'} && keys %{$t->entity_list}) 
2825           2                                 40             { $doctype_text .= "<!DOCTYPE " . $t->root->gi . " [\n" . $t->entity_list->text . "\n]>";;}
2826                                                          else
2827  ***      0                                  0             { my $doctype_text= $t->{twig_dtd};
2828  ***      0                                  0               $doctype_text .= $t->dtd_text;
2829                                                            }            
2830                                                        }
2831                                                      elsif( $doctype)
2832          36    100                         184         { if( my $internal= $doctype->{internal}) 
2833                                                            { # add opening and closing brackets if not already there
2834                                                              # plus some spaces and newlines for a nice formating
2835                                                              # I test it here because I can't remember which version of
2836                                                              # XML::Parser need it or not, nor guess which one will in the
2837                                                              # future, so this about the best I can do
2838          23                                230               $internal=~ s{^\s*(\[\s*)?}{ [\n};
2839          23                               2378               $internal=~ s{\s*(\]\s*(>\s*)?)?\s*$}{\n]>\n};
2840          23                                 89               $doctype_text .=  $internal; 
2841                                                            }
2842                                                        }
2843                                                        
2844        2271    100                        5133       if( $doctype_text)
2845                                                        {
2846                                                          # terrible hack, as I can't figure out in which case the darn prolog
2847                                                          # should get an extra > (depends on XML::Parser and expat versions)
2848          45                               2834           $doctype_text=~ s/(>\s*)*$/>\n/; # if($doctype_text);
2849                                                  
2850          45                                162           my $output_filter= XML::Twig::Elt::output_filter();
2851  ***     45     50                         512           return $output_filter ? $output_filter->( $doctype_text) : $doctype_text;
2852                                                        }
2853                                                      else
2854        2226                              13097         { return $doctype_text; }
2855                                                    }
2856                                                  
2857                                                  sub _leading_cpi
2858        2271                 2271          5405     { my $t= shift;
2859  ***   2271            66                14413       my $leading_cpi= $t->{leading_cpi} || return '';
2860         777                               2738       return $leading_cpi->xml_string;
2861                                                    }
2862                                                  
2863                                                  sub _trailing_cpi
2864        2262                 2262          5718     { my $t= shift;
2865  ***   2262            66                15064       my $trailing_cpi= $t->{trailing_cpi} || return '';
2866         772                               2556       return $trailing_cpi->xml_string;
2867                                                    }
2868                                                  
2869                                                  sub _trailing_cpi_text
2870        2262                 2262          5368     { my $t= shift;
2871        2262           100                16047       return $t->{trailing_cpi_text} || '';
2872                                                    }
2873                                                  
2874                                                  sub print_to_file
2875           2                    2            11     { my( $t, $filename)= (shift, shift);
2876           2    100                         105       open( TWIG_PRINT_TO_FILE, ">$filename") or _croak( "cannot create file $filename: $!");
2877  ***      1     50     33                   17       if( $] > 5.006 && ! $t->{twig_keep_encoding}) 
2878  ***      1     50                       15666         { if( grep /useperlio=define/, `$^X -V`) # we can only use binmode :utf8 if perl was compiled with useperlio
2879           1                                 25             { binmode( TWIG_PRINT_TO_FILE, ":utf8" ); }
2880                                                        }
2881           1                                 29       $t->print( \*TWIG_PRINT_TO_FILE, @_);
2882           1                                 68       close TWIG_PRINT_TO_FILE;
2883           1                                 16       return $t;
2884                                                    }
2885                                                  
2886                                                  sub print
2887          20                   20           594     { my $t= shift;
2888          20    100                          99       my $fh=  _is_fh( $_[0])  ? shift : undef;
2889          20                                104       my %args= _normalize_args( @_);
2890                                                  
2891          20    100                         152       my $old_select    = defined $fh                  ? select $fh                                 : undef;
2892          20    100                          94       my $old_pretty    = defined ($args{PrettyPrint}) ? $t->set_pretty_print( $args{PrettyPrint})  : undef;
2893          20    100                         571       my $old_empty_tag = defined ($args{EmptyTags})   ? $t->set_empty_tag_style( $args{EmptyTags}) : undef;
2894                                                  
2895          20                                117        print  $t->prolog( %args) . $t->_leading_cpi( %args);
2896          20                                283        $t->{twig_root}->print;
2897          20           100                   78        print $t->_trailing_cpi        # trailing comments and pi's (elements, in 'process' mode)
      ***                   50                        
      ***                   66                        
2898                                                           . $t->_trailing_cpi_text   # trailing comments and pi's (in 'keep' mode)
2899                                                           . ( ($t->{twig_keep_spaces}||'') && ($t->{trailing_spaces} || ''))
2900                                                           ;
2901                                                  
2902                                                      
2903          20    100                         294       $t->set_pretty_print( $old_pretty)       if( defined $old_pretty); 
2904          20    100                          71       $t->set_empty_tag_style( $old_empty_tag) if( defined $old_empty_tag); 
2905          20    100                          57       if( $fh) { select $old_select; }
              17                                109   
2906                                                  
2907          20                                 86       return $t;
2908                                                    }
2909                                                  
2910                                                  
2911                                                  sub flush
2912         909                  909          2424     { my $t= shift;
2913                                                  
2914  ***    909     50                        3834       $t->_trigger_tdh if $t->{twig_tdh};
2915                                                  
2916         909    100                        2902       return if( $t->{twig_completely_flushed});
2917                                                    
2918         901    100                        3239       my $fh=  _is_fh( $_[0]) ? shift : undef;
2919         901    100                        8964       my $old_select= defined $fh ? select $fh : undef;
2920         901    100                        2808       my $up_to= ref $_[0] ? shift : undef;
2921         901                               3210       my %args= _normalize_args( @_);
2922                                                  
2923         901                               1411       my $old_pretty;
2924         901    100                        3342       if( defined $args{PrettyPrint})
2925           6                                 26         { $old_pretty= $t->set_pretty_print( $args{PrettyPrint}); 
2926           6                                 23           delete $args{PrettyPrint};
2927                                                        }
2928                                                  
2929         901                               1290        my $old_empty_tag_style;
2930         901    100                        2546        if( $args{EmptyTags})
2931           8                                 34         { $old_empty_tag_style= $t->set_empty_tag_style( $args{EmptyTags}); 
2932           8                                 27           delete $args{EmptyTags};
2933                                                        }
2934                                                  
2935                                                  
2936                                                      # the "real" last element processed, as _twig_end has closed it
2937         901                               1221       my $last_elt;
2938         901                               1569       my $flush_trailing_data=0;
2939         901    100                        3772       if( $up_to)
                    100                               
2940          18                                 38         { $last_elt= $up_to; }
2941                                                      elsif( $t->{twig_current})
2942           6                                 29         { $last_elt= $t->{twig_current}->_last_child; }
2943                                                      else
2944         877                               2281         { $last_elt= $t->{twig_root};
2945         877                               1509           $flush_trailing_data=1;
2946         877                               4284           $t->{twig_completely_flushed}=1;
2947                                                        }
2948                                                  
2949                                                      # flush the DTD unless it has ready flushed (ie root has been flushed)
2950         901                               3183       my $elt= $t->{twig_root};
2951         901    100                        3455       unless( $elt->_flushed)
2952                                                        { # store flush info so we can auto-flush later
2953         886    100                        3755           if( $t->{twig_autoflush})
2954         877                               3518             { $t->{twig_autoflush_data}={};
2955         877    100                        1376               $t->{twig_autoflush_data}->{fh}   = $fh  if( $fh);
2956         877    100                        8149               $t->{twig_autoflush_data}->{args} = \@_  if( @_);
2957                                                            }
2958         886                               4695           $t->print_prolog( %args); 
2959         886                              29923           print $t->_leading_cpi;
2960                                                        }
2961                                                  
2962         901                              28413       while( $elt)
2963         951                               1537         { my $next_elt; 
2964  ***    951    100     66                 5934           if( $last_elt && $last_elt->in( $elt))
2965                                                            { 
2966          31    100                         215               unless( $elt->_flushed) 
2967                                                                { # just output the front tag
2968          25                                118                   print $elt->start_tag();
2969          25                                372                   $elt->_set_flushed;
2970                                                                }
2971          31                                107               $next_elt= $elt->{first_child};
2972                                                            }
2973                                                          else
2974                                                            { # an element before the last one or the last one,
2975         920                               3170               $next_elt= $elt->{next_sibling};  
2976         920                               3005               $elt->_flush();
2977         920                               3445               $elt->delete; 
2978  ***    920    100     66                 8808               last if( $last_elt && ($elt == $last_elt));
2979                                                            }
2980          50                                147           $elt= $next_elt;
2981                                                        }
2982                                                  
2983         901    100                        2676       if( $flush_trailing_data)
2984         877                               2789         { print $t->_trailing_cpi        # trailing comments and pi's (elements, in 'process' mode)
2985                                                              , $t->_trailing_cpi_text   # trailing comments and pi's (in 'keep' mode)
2986                                                        }
2987                                                  
2988         901    100                       29690       select $old_select if( defined $old_select);
2989         901    100                        2759       $t->set_pretty_print( $old_pretty) if( defined $old_pretty); 
2990         901    100                        2120       $t->set_empty_tag_style( $old_empty_tag_style) if( defined $old_empty_tag_style); 
2991                                                  
2992  ***    901     50                        3920       if( my $ids= $t->{twig_id_list}) 
2993  ***      0      0                           0         { while( my ($id, $elt)= each %$ids) { if( ! defined $elt) { delete $t->{twig_id_list}->{$id} } } }
      ***      0                                  0   
      ***      0                                  0   
2994                                                  
2995         901                               4085       return $t;
2996                                                    }
2997                                                  
2998                                                  
2999                                                  # flushes up to an element
3000                                                  # this method just reorders the arguments and calls flush
3001                                                  sub flush_up_to
3002          18                   18            65     { my $t= shift;
3003          18                                 44       my $up_to= shift;
3004          18    100                         122       if( _is_fh( $_[0]))
3005          10                                 35         { my $fh=  shift;
3006          10                                 55           $t->flush( $fh, $up_to, @_);
3007                                                        }
3008                                                      else
3009           8                                 58         { $t->flush( $up_to, @_); }
3010                                                  
3011          18                                124       return $t;
3012                                                    }
3013                                                  
3014                                                      
3015                                                  # same as print except the entire document text is returned as a string
3016                                                  sub sprint
3017        1365                 1365          9944     { my $t= shift;
3018        1365                               4901       my %args= _normalize_args( @_);
3019                                                  
3020        1365                               2369       my $old_pretty;
3021        1365    100                        5448       if( defined $args{PrettyPrint})
3022           8                                114         { $old_pretty= $t->set_pretty_print( $args{PrettyPrint}); 
3023           8                                 31           delete $args{PrettyPrint};
3024                                                        }
3025                                                  
3026        1365                               2825        my $old_empty_tag_style;
3027        1365    100                        4568        if( defined $args{EmptyTags})
3028          12                                134         { $old_empty_tag_style= $t->set_empty_tag_style( $args{EmptyTags}); 
3029          12                                 38           delete $args{EmptyTags};
3030                                                        }
3031                                                        
3032        1365                               6123       my $string=   $t->prolog( %args)       # xml declaration and doctype
3033                                                                  . $t->_leading_cpi( %args) # leading comments and pi's in 'process' mode
3034                                                                  . $t->{twig_root}->sprint  
3035                                                                  . $t->_trailing_cpi        # trailing comments and pi's (elements, in 'process' mode)
3036                                                                  . $t->_trailing_cpi_text   # trailing comments and pi's (in 'keep' mode)
3037                                                                  ;
3038        1365    100    100                 8596       if( $t->{twig_keep_spaces} && $t->{trailing_spaces}) { $string .= $t->{trailing_spaces}; }
               4                                 15   
3039                                                  
3040        1365    100                        3600       $t->set_pretty_print( $old_pretty) if( defined $old_pretty); 
3041        1365    100                        3235       $t->set_empty_tag_style( $old_empty_tag_style) if( defined $old_empty_tag_style); 
3042                                                  
3043        1365                              11116       return $string;
3044                                                    }
3045                                                      
3046                                                  
3047                                                  # this method discards useless elements in a tree
3048                                                  # it does the same thing as a flush except it does not print it
3049                                                  # the second argument is an element, the last purged element
3050                                                  # (this argument is usually set through the purge_up_to method)
3051                                                  sub purge
3052          10                   10            40     { my $t= shift;
3053          10                                 25       my $up_to= shift;
3054                                                  
3055  ***     10     50                          44       $t->_trigger_tdh if $t->{twig_tdh};
3056                                                  
3057                                                      # the "real" last element processed, as _twig_end has closed it
3058          10                                 27       my $last_elt;
3059          10    100                          38       if( $up_to)
                    100                               
3060           7                                 16         { $last_elt= $up_to; }
3061                                                      elsif( $t->{twig_current})
3062           2                                 17         { $last_elt= $t->{twig_current}->_last_child; }
3063                                                      else
3064           1                                  4         { $last_elt= $t->{twig_root}; }
3065                                                      
3066          10                                 31       my $elt= $t->{twig_root};
3067                                                  
3068          10                                 31       while( $elt)
3069          29                                 65         { my $next_elt; 
3070  ***     29    100     66                  177           if( $last_elt && $last_elt->in( $elt))
3071          13                                 45             { $elt->_set_flushed;
3072          13                                 46               $next_elt= $elt->{first_child};
3073                                                            }
3074                                                          else
3075                                                            { # an element before the last one or the last one,
3076          16                                 49               $next_elt= $elt->{next_sibling};  
3077          16                                 53               $elt->delete; 
3078  ***     16    100     66                  145               last if( $last_elt && ($elt == $last_elt) );
3079                                                            }
3080          19                                 63           $elt= $next_elt;
3081                                                        }
3082                                                  
3083          10    100                          58       if( my $ids= $t->{twig_id_list}) 
3084           2    100                          16         { while( my ($id, $elt)= each %$ids) { if( ! defined $elt) { delete $t->{twig_id_list}->{$id} } } }
               8                                 43   
               4                                 35   
3085                                                  
3086          10                                 29       return $t;
3087                                                    }
3088                                                      
3089                                                  # flushes up to an element. This method just calls purge
3090                                                  sub purge_up_to
3091           7                    7            19     { my $t= shift;
3092           7                                 28       return $t->purge( @_);
3093                                                    }
3094                                                  
3095                                                  sub root
3096        4732                 4732         41591     { return $_[0]->{twig_root}; }
3097                                                  
3098                                                  sub normalize
3099           1                    1             5     { return $_[0]->root->normalize; }
3100                                                  
3101                                                  # create accessor methods on attribute names
3102                                                  { my %accessor; # memorize accessor names so re-creating them won't trigger an error
3103                                                  sub create_accessors
3104                                                    { 
3105  ***      3     50             3            14       _croak( "cannot use the create_accessors method with perl 5.005") if( $] < 5.006);
3106                                                  
3107           3                                  7       my $twig_or_class= shift;
3108           3    100                          17       my $elt_class= ref $twig_or_class ? $twig_or_class->{twig_elt_class}
3109                                                                                        : 'XML::Twig::Elt'
3110                                                                                        ;
3111          92                   92           882       no strict 'refs';
              92                                208   
              92                                831   
3112           3                                 11       foreach my $att (@_)
3113           4    100    100                   64         { _croak( "attempt to redefine existing method $att using create_accessors")
3114                                                            if( $elt_class->can( $att) && !$accessor{$att});
3115                                                  
3116           3    100                          58           if( !$accessor{$att})                                # > perl 5.5
3117           2                                 15             { *{"$elt_class\::$att"}=                          # > perl 5.5
3118                                                                  sub :lvalue                                  # > perl 5.5
3119          11                   11            28                     { my $elt= shift;                          # > perl 5.5
3120          11    100                          33                       if( @_) { $elt->{att}->{$att}= $_[0]; }  # > perl 5.5
               2                                  9   
3121          11                                 79                       $elt->{att}->{$att};                     # > perl 5.5
3122           2                                 17                     };                                         # > perl 5.5
3123           2                                 11               $accessor{$att}=1;                               # > perl 5.5
3124                                                            }                                                  # > perl 5.5
3125                                                        }
3126           2                                  8       return $twig_or_class;
3127                                                    }
3128                                                  }
3129                                                  
3130                                                  
3131                                                  sub first_elt
3132          87                   87          1964     { my( $t, $cond)= @_;
3133  ***     87            33                  350       my $root= $t->root || return undef;
3134          87    100                         351       return $root if( $root->passes( $cond));
3135          82                                405       return $root->next_elt( $cond); 
3136                                                    }
3137                                                  
3138                                                  sub last_elt
3139           7                    7           255     { my( $t, $cond)= @_;
3140  ***      7            33                   24       my $root= $t->root || return undef;
3141           7                                 27       return $root->last_descendant( $cond); 
3142                                                    }
3143                                                  
3144                                                  sub next_n_elt
3145           4                    4            28     { my( $t, $offset, $cond)= @_;
3146           4    100                          16       $offset -- if( $t->root->matches( $cond) );
3147           4                                 15       return $t->root->next_n_elt( $offset, $cond);
3148                                                    }
3149                                                  
3150                                                  sub get_xpath
3151         150                  150         12839     { my $twig= shift;
3152         150    100                         937       if( isa( $_[0], 'ARRAY'))
3153           1                                  3         { my $elt_array= shift;
3154           1                                  4           return _unique_elts( map { $_->get_xpath( @_) } @$elt_array);
               2                                  8   
3155                                                        }
3156                                                      else
3157         149                                505         { return $twig->root->get_xpath( @_); }
3158                                                    }
3159                                                  
3160                                                  # get a list of elts and return a sorted list of unique elts
3161                                                  sub _unique_elts
3162         172                  172           610     { my @sorted= sort { $a ->cmp( $b) } @_;
             190                                643   
3163         172                                499       my @unique;
3164         172                                815       while( my $current= shift @sorted)
3165         279    100    100                 2481         { push @unique, $current unless( @unique && ($unique[-1] == $current)); }
3166         172                               1133       return @unique;
3167                                                    }
3168                                                  
3169                                                  sub findvalue
3170          12                   12            33     { my $twig= shift;
3171          12    100                          66       if( isa( $_[0], 'ARRAY'))
3172           1                                  2         { my $elt_array= shift;
3173           1                                  4           return join( '', map { $_->findvalue( @_) } @$elt_array);
               2                                  9   
3174                                                        }
3175                                                      else
3176          11                                 34         { return $twig->root->findvalue( @_); }
3177                                                    }
3178                                                  
3179                                                  sub set_id_seed
3180           2                    2            18     { my $t= shift;
3181           2                                 12       XML::Twig::Elt->set_id_seed( @_);
3182           2                                  6       return $t;
3183                                                    }
3184                                                  
3185                                                  # return an array ref to an index, or undef
3186                                                  sub index
3187          10                   10            46     { my( $twig, $name, $index)= @_;
3188          10    100                          84       return defined( $index) ? $twig->{_twig_index}->{$name}->[$index] : $twig->{_twig_index}->{$name};
3189                                                    }
3190                                                  
3191                                                  # return a list with just the root
3192                                                  # if a condition is given then return an empty list unless the root matches
3193                                                  sub children
3194          82                   82           357     { my( $t, $cond)= @_;
3195          82                                281       my $root= $t->root;
3196          82    100    100                  558       unless( $cond && !($root->passes( $cond)) )
3197          79                                370         { return ($root); }
3198                                                      else
3199           3                                 19         { return (); }
3200                                                    }
3201                                                    
3202           1                    1             6   sub _children { return ($_[0]->root); }
3203                                                  
3204                                                  # weird, but here for completude
3205                                                  # used to solve (non-sensical) /doc[1] XPath queries
3206                                                  sub child
3207           2                    2             6     { my $t= shift;
3208           2                                 16       my $nb= shift;
3209           2                                 10       return ($t->children( @_))[$nb];
3210                                                    }
3211                                                  
3212                                                  sub descendants
3213          79                   79           375     { my( $t, $cond)= @_;
3214          79                                327       my $root= $t->root;
3215          79    100                         279       if( $root->passes( $cond) )
3216          44                                184         { return ($root, $root->descendants( $cond)); }
3217                                                      else
3218          35                                155         { return ( $root->descendants( $cond)); }
3219                                                    }
3220                                                  
3221           2                    2            34   sub simplify  { my $t= shift; $t->root->simplify( @_);  }
               2                                  8   
3222          17                   17           175   sub subs_text { my $t= shift; $t->root->subs_text( @_); }
              17                                 63   
3223          18                   18            40   sub trim      { my $t= shift; $t->root->trim( @_);      }
              18                                 55   
3224                                                  
3225                                                  
3226                                                  sub set_keep_encoding
3227        2763                 2763          9155     { my( $t, $keep)= @_;
3228        2763                              12912       $t->{twig_keep_encoding}= $keep;
3229        2763                              10558       $t->{NoExpand}= $keep;
3230        2763                               9421       return XML::Twig::Elt::set_keep_encoding( $keep);
3231                                                     }
3232                                                  
3233                                                  sub set_expand_external_entities
3234        2771                 2771         11234     { return XML::Twig::Elt::set_expand_external_entities( @_); }
3235                                                  
3236                                                  sub escape_gt
3237  ***      0                    0             0     { my $t= shift; $t->{twig_escape_gt}= 1; return XML::Twig::Elt::escape_gt( @_); }
      ***      0                                  0   
      ***      0                                  0   
3238                                                  
3239                                                  sub do_not_escape_gt
3240  ***      0                    0             0     { my $t= shift; $t->{twig_escape_gt}= 0; return XML::Twig::Elt::do_not_escape_gt( @_); }
      ***      0                                  0   
      ***      0                                  0   
3241                                                  
3242                                                  # WARNING: at the moment the id list is not updated reliably
3243                                                  sub elt_id
3244          65                   65          1789     { return $_[0]->{twig_id_list}->{$_[1]}; }
3245                                                  
3246                                                  # change it in ALL twigs at the moment
3247                                                  sub change_gi 
3248           4                    4            33     { my( $twig, $old_gi, $new_gi)= @_;
3249           4                                 10       my $index;
3250           4    100                          29       return unless($index= $XML::Twig::gi2index{$old_gi});
3251           2                                  8       $XML::Twig::index2gi[$index]= $new_gi;
3252           2                                  7       delete $XML::Twig::gi2index{$old_gi};
3253           2                                  7       $XML::Twig::gi2index{$new_gi}= $index;
3254           2                                  7       return $twig;
3255                                                    }
3256                                                  
3257                                                  
3258                                                  # builds the DTD from the stored (possibly updated) data
3259                                                  sub dtd_text
3260           4                    4            18     { my $t= shift;
3261           4                                 16       my $dtd= $t->{twig_dtd};
3262  ***      4     50                          23       my $doctype= $t->{twig_doctype} or return '';
3263           4                                 19       my $string= "<!DOCTYPE ".$doctype->{name};
3264                                                  
3265           4                                 12       $string .= " [\n";
3266                                                  
3267           4                                 11       foreach my $gi (@{$dtd->{elt_list}})
               4                                 20   
3268           5                                 12         { $string.= "<!ELEMENT $gi ".$dtd->{model}->{$gi}.">\n" ;
3269           5    100                         349           if( $dtd->{att}->{$gi})
3270           2                                  9             { my $attlist= $dtd->{att}->{$gi};
3271           2                                  8               $string.= "<!ATTLIST $gi\n";
3272           2                                  5               foreach my $att ( sort keys %{$attlist})
               2                                 17   
3273                                                                { 
3274           4    100                          20                   if( $attlist->{$att}->{fixed})
3275           1                                 10                     { $string.= "   $att $attlist->{$att}->{type} #FIXED $attlist->{$att}->{default}"; }
3276                                                                  else
3277           3                                 30                     { $string.= "   $att $attlist->{$att}->{type} $attlist->{$att}->{default}"; }
3278           4                                 16                   $string.= "\n";
3279                                                                }
3280           2                                 10               $string.= ">\n";
3281                                                            }
3282                                                        }
3283  ***      4     50                          21       $string.= $t->entity_list->text if( $t->entity_list);
3284           4                                 16       $string.= "\n]>\n";
3285           4                                 23       return $string;
3286                                                    }
3287                                                          
3288                                                  # prints the DTD from the stored (possibly updated) data
3289                                                  sub dtd_print
3290           3                    3            22     { my $t= shift;
3291           3    100                          15       my $fh=  _is_fh( $_[0])  ? shift : undef;
3292           3    100                           9       if( $fh) { print $fh $t->dtd_text; }
               2                                 13   
3293           1                                  5       else     { print $t->dtd_text;     }
3294           3                                 76       return $t;
3295                                                    }
3296                                                  
3297                                                  # build the subs that call directly expat
3298                                                  BEGIN
3299          92                   92          1613     { my @expat_methods= qw( depth in_element within_element context
3300                                                                             current_line current_column current_byte
3301                                                                             recognized_string original_string 
3302                                                                             xpcroak xpcarp 
3303                                                                             xml_escape
3304                                                                             base current_element element_index 
3305                                                                             position_in_context);
3306          92                                354       foreach my $method (@expat_methods)
3307          92                   92           854         { no strict 'refs';
              92                                229   
              92                                560   
3308        1472                   34         13273           *{$method}= sub { my $t= shift;
              34                                695   
3309          34    100                         221                             _croak( "calling $method after parsing is finished") unless( $t->{twig_parsing}); 
3310          18                                118                             return $t->{twig_parser}->$method(@_); 
3311        1472                              11673                           };
3312                                                        }
3313                                                    }
3314                                                  
3315                                                  sub path
3316          17                   17           134     { my( $t, $gi)= @_;
3317  ***     17     50                          67       if( $t->{twig_map_xmlns})
3318  ***      0                                  0         { return "/" . join( "/", map { $t->_replace_prefix( $_)} ($t->{twig_parser}->context, $gi)); }
      ***      0                                  0   
3319                                                      else
3320          17                                 93         { return "/" . join( "/", ($t->{twig_parser}->context, $gi)); }
3321                                                    }
3322                                                  
3323                                                  sub finish
3324           1                    1            10     { my $t= shift;
3325           1                                  5       return $t->{twig_parser}->finish;
3326                                                    }
3327                                                  
3328                                                  # just finish the parse by printing the rest of the document
3329                                                  sub finish_print
3330           6                    6            94     { my( $t, $fh)= @_;
3331           6                                 15       my $old_fh;
3332           6    100                          30       unless( defined $fh)
      ***            50                               
3333           2                                  7         { $t->_set_fh_to_twig_output_fh(); }
3334                                                      elsif( defined $fh)
3335           4                                 17         { $old_fh= select $fh; 
3336  ***      4     50                          30           $t->{twig_original_selected_fh}= $old_fh if( $old_fh); 
3337                                                        }
3338                                                      
3339           6                                 26       my $p=$t->{twig_parser};
3340           6    100                          24       if( $t->{twig_keep_encoding})
3341           1                                 14         { $p->setHandlers( %twig_handlers_finish_print); }
3342                                                      else
3343           5                                 84         { $p->setHandlers( %twig_handlers_finish_print_original); }
3344           6                               2382       return $t;
3345                                                    }
3346                                                  
3347        2760                 2760          9303   sub set_remove_cdata { return XML::Twig::Elt::set_remove_cdata( @_); }
3348                                                  
3349          19                   19            66   sub output_filter          { return XML::Twig::Elt::output_filter( @_);          }
3350        2783                 2783          9045   sub set_output_filter      { return XML::Twig::Elt::set_output_filter( @_);      }
3351                                                  
3352           2                    2            20   sub output_text_filter     { return XML::Twig::Elt::output_text_filter( @_);     }
3353        2769                 2769         14683   sub set_output_text_filter { return XML::Twig::Elt::set_output_text_filter( @_); }
3354                                                  
3355                                                  sub set_input_filter
3356           4                    4            17     { my( $t, $input_filter)= @_;
3357           4                                 14       my $old_filter= $t->{twig_input_filter};
3358  ***      4    100     66                   59         if( !$input_filter || isa( $input_filter, 'CODE') )
      ***            50                               
      ***            50                               
3359           2                                 10           { $t->{twig_input_filter}= $input_filter; }
3360                                                        elsif( $input_filter eq 'latin1')
3361  ***      0                                  0           {  $t->{twig_input_filter}= latin1(); }
3362                                                        elsif( $filter{$input_filter})
3363  ***      0                                  0           {  $t->{twig_input_filter}= $filter{$input_filter}; }
3364                                                        else
3365           2                                 12           { _croak( "invalid input filter: $input_filter"); }
3366                                                        
3367           2                                  6         return $old_filter;
3368                                                      }
3369                                                  
3370                                                  sub set_empty_tag_style
3371          85                   85           544     { return XML::Twig::Elt::set_empty_tag_style( @_); }
3372                                                  
3373                                                  sub set_pretty_print
3374          89                   89           433     { return XML::Twig::Elt::set_pretty_print( @_); }
3375                                                  
3376                                                  sub set_quote
3377           4                    4            60     { return XML::Twig::Elt::set_quote( @_); }
3378                                                  
3379                                                  sub set_indent
3380           4                    4            22     { return XML::Twig::Elt::set_indent( @_); }
3381                                                  
3382                                                  sub set_keep_atts_order
3383        2760                 2760          5519     { shift; return XML::Twig::Elt::set_keep_atts_order( @_); }
            2760                               9042   
3384                                                  
3385                                                  sub keep_atts_order
3386           2                    2            10     { return XML::Twig::Elt::keep_atts_order( @_); }
3387                                                  
3388                                                  sub set_do_not_escape_amp_in_atts
3389        2770                 2770         10372     { return XML::Twig::Elt::set_do_not_escape_amp_in_atts( @_); }
3390                                                  
3391                                                  # save and restore package globals (the ones in XML::Twig::Elt)
3392                                                  # should probably return the XML::Twig object itself, but instead
3393                                                  # returns the state (as a hashref) for backward compatibility
3394                                                  sub save_global_state
3395          10                   10           218     { my $t= shift;
3396          10                                 38       return $t->{twig_saved_state}= XML::Twig::Elt::global_state();
3397                                                    }
3398                                                  
3399                                                  sub restore_global_state
3400          16                   16           632     { my $t= shift;
3401          16                                 82       XML::Twig::Elt::set_global_state( $t->{twig_saved_state});
3402                                                    }
3403                                                  
3404                                                  sub global_state
3405           1                    1             5     { return XML::Twig::Elt::global_state(); }
3406                                                  
3407                                                  sub set_global_state
3408           1                    1             6     {  return XML::Twig::Elt::set_global_state( $_[1]); }
3409                                                  
3410                                                  sub dispose
3411           3                    3             9     { my $t= shift;
3412           3                                  9       $t->DESTROY;
3413           3                                  3       return;
3414                                                    }
3415                                                    
3416                                                  sub DESTROY
3417        2756                 2756          8996     { my $t= shift;
3418  ***   2756     50     66                39706       if( $t->{twig_root} && isa(  $t->{twig_root}, 'XML::Twig')) 
3419  ***      0                                  0         { $t->{twig_root}->delete } 
3420                                                  
3421                                                      # added to break circular references
3422        2756                               9872       undef $t->{twig};
3423        2756    100                       16406       undef $t->{twig_root}->{twig} if( $t->{twig_root});
3424        2756                               9519       undef $t->{twig_parser};
3425                                                      
3426        2756                               8363       $t={}; # prevents memory leaks (especially when using mod_perl)
3427        2756                               6415       undef $t;
3428                                                    }        
3429                                                  
3430                                                  
3431                                                  #
3432                                                  #  non standard handlers
3433                                                  #
3434                                                  
3435                                                  # kludge: expat 1.95.2 calls both Default AND Doctype handlers
3436                                                  # so if the default handler finds '<!DOCTYPE' then it must 
3437                                                  # unset itself (_twig_print_doctype will reset it)
3438                                                  sub _twig_print_check_doctype
3439                                                     { # warn " in _twig_print_check_doctype...\n"; # DEBUG handler
3440                                                      
3441          15                   15            47       my $p= shift;
3442          15                                 57       my $string= $p->recognized_string();
3443  ***     15     50                         294       if( $string eq '<!DOCTYPE') 
3444                                                        { 
3445  ***      0                                  0           $p->setHandlers( Default => undef); 
3446  ***      0                                  0           $p->setHandlers( Entity => undef); 
3447  ***      0                                  0           $expat_1_95_2=1; 
3448                                                        }
3449                                                      else                        
3450          15                                 45         { print $string; }
3451                                                  
3452          15                                 32       return;
3453                                                    }
3454                                                  
3455                                                  
3456                                                  sub _twig_print
3457                                                     { # warn " in _twig_print...\n"; # DEBUG handler
3458         474                  474          1458       my $p= shift;
3459  ***    474     50     33                 2228       if( $expat_1_95_2 && ($p->recognized_string eq '[') && !$p->{twig}->{expat_1_95_2_seen_bracket})
      ***                   33                        
3460                                                        { # otherwise the opening square bracket of the doctype gets printed twice 
3461  ***      0                                  0           $p->{twig}->{expat_1_95_2_seen_bracket}=1;
3462                                                        }
3463                                                      else
3464         474                               1783         { print $p->recognized_string(); }
3465         474                               8619       return;
3466                                                    }
3467                                                  # recognized_string does not seem to work for entities, go figure!
3468                                                  # so this handler is used to print them anyway
3469                                                  sub _twig_print_entity
3470                                                     { # warn " in _twig_print_entity...\n"; # DEBUG handler
3471           6                    6            48       my $p= shift; 
3472           6                                 43       XML::Twig::Entity->new( @_)->print;
3473                                                    }
3474                                                  
3475                                                  # kludge: expat 1.95.2 calls both Default AND Doctype handlers
3476                                                  # so if the default handler finds '<!DOCTYPE' then it must 
3477                                                  # unset itself (_twig_print_doctype will reset it)
3478                                                  sub _twig_print_original_check_doctype
3479                                                     { # warn " in _twig_print_original_check_doctype...\n"; # DEBUG handler
3480                                                      
3481           3                    3            10       my $p= shift;
3482           3                                 12       my $string= $p->original_string();
3483  ***      3     50                          67       if( $string eq '<!DOCTYPE') 
3484  ***      0                                  0         { $p->setHandlers( Default => undef); 
3485  ***      0                                  0           $p->setHandlers( Entity => undef); 
3486  ***      0                                  0           $expat_1_95_2=1; 
3487                                                        }
3488                                                      else                        
3489           3                                 10         { print $string; }
3490                                                  
3491           3                                  5       return;    
3492                                                    }
3493                                                  
3494                                                  sub _twig_print_original
3495                                                     { # warn " in _twig_print_original...\n"; # DEBUG handler
3496          41                   41           186       my $p= shift; 
3497          41                                163       print $p->original_string();
3498          41                                819       return;    
3499                                                    }
3500                                                  
3501                                                  
3502                                                  sub _twig_print_original_doctype
3503                                                     { # warn " in _twig_print_original_doctype...\n"; # DEBUG handler
3504                                                      
3505           5                    5            42       my(  $p, $name, $sysid, $pubid, $internal)= @_;
3506  ***      5     50                          25       if( $name)
3507                                                        { # with recent versions of XML::Parser original_string does not work,
3508                                                          # hence we need to rebuild the doctype declaration
3509           5                                 13           my $doctype='';
3510  ***      5     50                          26           $doctype .= qq{<!DOCTYPE $name}    if( $name);
3511  ***      5     50                          18           $doctype .=  qq{ PUBLIC  "$pubid"}  if( $pubid);
3512  ***      5    100     66                   28           $doctype .=  qq{ SYSTEM}            if( $sysid && !$pubid);
3513           5    100                          18           $doctype .=  qq{ "$sysid"}          if( $sysid); 
3514  ***      5    100     66                   42           $doctype .=  ' [' if( $internal && !$expat_1_95_2) ;
3515  ***      5    100     66                   44           $doctype .=  qq{>} unless( $internal || $expat_1_95_2);
3516           5                                 55           $p->{twig}->{twig_doctype}->{has_internal}=$internal;
3517           5                                 56           print $doctype;
3518                                                        }
3519           5                                 33       $p->setHandlers( Default => \&_twig_print_original);
3520           5                                237       return;    
3521                                                    }
3522                                                  
3523                                                  sub _twig_print_doctype
3524                                                     { # warn " in _twig_print_doctype...\n"; # DEBUG handler
3525          11                   11            88       my(  $p, $name, $sysid, $pubid, $internal)= @_;
3526  ***     11     50                          55       if( $name)
3527                                                        { # with recent versions of XML::Parser original_string does not work,
3528                                                          # hence we need to rebuild the doctype declaration
3529          11                                 28           my $doctype='';
3530  ***     11     50                          92           $doctype .= qq{<!DOCTYPE $name}    if( $name);
3531  ***     11     50                          33           $doctype .=  qq{ PUBLIC  "$pubid"}  if( $pubid);
3532  ***     11    100     66                   94           $doctype .=  qq{ SYSTEM}            if( $sysid && !$pubid);
3533          11    100                          54           $doctype .=  qq{ "$sysid"}          if( $sysid); 
3534          11    100                          40           $doctype .=  ' [' if( $internal) ;
3535  ***     11    100     66                   92           $doctype .=  qq{>} unless( $internal || $expat_1_95_2);
3536          11                                 96           $p->{twig}->{twig_doctype}->{has_internal}=$internal;
3537          11                                 70           print $doctype;
3538                                                        }
3539          11                                 70       $p->setHandlers( Default => \&_twig_print);
3540          11                                514       return;    
3541                                                    }
3542                                                  
3543                                                  
3544                                                  sub _twig_print_original_default
3545                                                     { # warn " in _twig_print_original_default...\n"; # DEBUG handler
3546           2                    2            64       my $p= shift;
3547           2                                  9       print $p->original_string();
3548           2                                 40       return;    
3549                                                    }
3550                                                  
3551                                                  # account for the case where the element is empty
3552                                                  sub _twig_print_end_original
3553                                                     { # warn " in _twig_print_end_original...\n"; # DEBUG handler
3554          10                   10            64       my $p= shift;
3555          10                                 38       print $p->original_string();
3556          10                                229       return;    
3557                                                    }
3558                                                  
3559                                                  sub _twig_start_check_roots
3560                                                     { # warn " in _twig_start_check_roots...\n"; # DEBUG handler
3561         373                  373          1255       my $p= shift;
3562         373                                942       my $gi= shift;
3563                                                      
3564         373                               1191       my $t= $p->{twig};
3565                                                      
3566  ***    373            66                 3302       my $fh= $t->{twig_output_fh} || select() || \*STDOUT;
      ***                   50                        
3567                                                  
3568         373    100                        1523       unless( $p->depth == 0)
3569         307    100                        5127         { if( $t->{twig_map_xmlns}) { _replace_ns( $t, \$gi, \@_); }
               2                                 10   
3570                                                        }
3571                                                  
3572         373                               1667       push @{$t->{_twig_context_stack}}, { _tag => $gi, @_};
             373                               2696   
3573         373                               1483       my %att= @_;
3574                                                  
3575         373    100                        1871       if( _handler( $t, $t->{twig_roots}, $gi))
3576          78                               1083         { $p->setHandlers( %twig_handlers); # restore regular handlers
3577          78                              32063           $t->{twig_root_depth}= $p->depth; 
3578          78                               1113           pop @{$t->{_twig_context_stack}}; # will be pushed back in _twig_start
              78                                297   
3579          78                                432           _twig_start( $p, $gi, @_);
3580          78                                194           return;
3581                                                        }
3582                                                  
3583                                                      # $tag will always be true if it needs to be printed (the tag string is never empty)
3584         295    100                        1796       my $tag= $t->{twig_default_print} ? $t->{twig_keep_encoding} ? $p->original_string
                    100                               
3585                                                                                                                   : $p->recognized_string
3586                                                                                        : '';
3587                                                  
3588         295    100                        3471       if( $p->depth == 0)
                    100                               
3589          92                   92           807         { no strict 'refs';
              92                                274   
              92                                652   
3590          64    100                        1481           print {$fh} $tag if( $tag);
              33                                186   
3591          64                                242           pop @{$t->{_twig_context_stack}}; # will be pushed back in _twig_start
              64                                255   
3592          64                                371           _twig_start( $p, $gi, @_);
3593          64                                285           $t->root->_set_flushed; # or the root start tag gets output the first time we flush
3594                                                        }
3595                                                      elsif( $t->{twig_starttag_handlers})
3596                                                        { # look for start tag handlers
3597                                                  
3598          23                                429           my @handlers= _handler( $t, $t->{twig_starttag_handlers}, $gi);
3599          23                                 39           my $last_handler_res;
3600          23                                 65           foreach my $handler ( @handlers)
3601          13                                 80             { $last_handler_res= $handler->($t, $gi, %att);
3602  ***     13     50                         228               last unless $last_handler_res;
3603                                                            }
3604          92                   92           749           no strict 'refs';
              92                                222   
              92                                644   
3605  ***     23    100     66                  177           print {$fh} $tag if( $tag && (!@handlers || $last_handler_res));   
      ***     12            66                   44   
3606                                                        }
3607                                                      else
3608          92                   92           688         { no strict 'refs';
              92                                185   
              92                                453   
3609         208    100                        3518           print {$fh} $tag if( $tag); 
              97                                347   
3610                                                        }  
3611         295                                970       return;    
3612                                                    }
3613                                                  
3614                                                  sub _twig_end_check_roots
3615                                                     { # warn " in _twig_end_check_roots...\n"; # DEBUG handler
3616                                                      
3617         295                  295          1511       my( $p, $gi, %att)= @_;
3618         295                               1007       my $t= $p->{twig};
3619                                                      # $tag can be empty (<elt/>), hence the undef and the tests for defined
3620         295    100                        1697       my $tag= $t->{twig_default_print} ? $t->{twig_keep_encoding} ? $p->original_string
                    100                               
3621                                                                                                                   : $p->recognized_string
3622                                                                                        : undef;
3623  ***    295            66                 4408       my $fh= $t->{twig_output_fh} || select() || \*STDOUT;
      ***                   50                        
3624                                                      
3625         295    100                        1351       if( $t->{twig_endtag_handlers})
3626                                                        { # look for end tag handlers
3627          34                                150           my @handlers= _handler( $t, $t->{twig_endtag_handlers}, $gi);
3628          34                                 68           my $last_handler_res=1;
3629          34                                 98           foreach my $handler ( @handlers)
3630  ***     10            66                   39             { $last_handler_res= $handler->($t, $gi) || last; }
3631  ***     34     50                         340           if( ! $last_handler_res) 
3632  ***      0                                  0             { pop @{$t->{_twig_context_stack}};
      ***      0                                  0   
3633  ***      0                                  0               return;
3634                                                            }
3635                                                        }
3636                                                      {
3637          92                   92           787         no strict 'refs';
              92                                202   
              92                                532   
             295                                454   
3638         295    100                         889         print {$fh} $tag if( defined $tag);
             142                                505   
3639                                                      }
3640         295    100                        1327       if( $p->depth == 0)
3641                                                        { 
3642          64                               1110           _twig_end( $p, $gi);  
3643          64                                293           $t->root->{end_tag_flushed}=1;
3644                                                        }
3645                                                  
3646         295                               3305       pop @{$t->{_twig_context_stack}};
             295                               1089   
3647         295                                898       return;    
3648                                                    }
3649                                                  
3650                                                  sub _twig_pi_check_roots
3651                                                     { # warn " in _twig_pi_check_roots...\n"; # DEBUG handler
3652          19                   19           101       my( $p, $target, $data)= @_;
3653          19                                 83       my $t= $p->{twig};
3654  ***     19     50                         162       my $pi= $t->{twig_default_print} ? $t->{twig_keep_encoding} ? $p->original_string
                    100                               
3655                                                                                                                  : $p->recognized_string
3656                                                                                      : undef;
3657  ***     19            66                  472       my $fh= $t->{twig_output_fh} || select() || \*STDOUT;
      ***                   50                        
3658                                                      
3659  ***     19    100     66                  283       if( my $handler=    $t->{twig_handlers}->{pi_handlers}->{$target}
3660                                                                       || $t->{twig_handlers}->{pi_handlers}->{''}
3661                                                        )
3662                                                        { # if handler is called on pi, then it needs to be processed as a regular node
3663           1                                  4           my @flags= qw( twig_process_pi twig_keep_pi);
3664           1                                  3           my @save= @{$t}{@flags}; # save pi related flags
               1                                  5   
3665           1                                  3           @{$t}{@flags}= (1, 0);   # override them, pi needs to be processed
               1                                  5   
3666           1                                  5           _twig_pi( @_);           # call handler on the pi
3667           1                                  3           @{$t}{@flags}= @save;;   # restore flag
               1                                  4   
3668                                                        }
3669                                                      else
3670          92                   92           807         { no strict 'refs';
              92                                201   
              92                                489   
3671  ***     18     50                          64           print  {$fh} $pi if( defined( $pi));
              18                                 62   
3672                                                        }
3673          19                                 45       return;    
3674                                                    }
3675                                                  
3676                                                  
3677                                                  sub _twig_ignore_start
3678                                                     { # warn " in _twig_ignore_start...\n"; # DEBUG handler
3679                                                      
3680          48                   48           220       my( $p, $gi)= @_;
3681          48                                173       my $t= $p->{twig};
3682          48                                136       $t->{twig_ignore_level}++;
3683          48                                128       my $action= $t->{twig_ignore_action};
3684  ***     48     50                         192       if( $action eq 'print' ) { _twig_print_original( @_); }
      ***      0                                  0   
3685                                                  #    elsif( $action eq 'string' )
3686                                                  #      { $t->{twig_buffered_string} .= $p->original_string(); }
3687          48                                 96       return;    
3688                                                    }
3689                                                  
3690                                                  sub _twig_ignore_end
3691                                                     { # warn " in _twig_ignore_end...\n"; # DEBUG handler
3692                                                      
3693         110                  110           488       my( $p, $gi)= @_;
3694         110                                443       my $t= $p->{twig};
3695                                                  
3696         110                                303       my $action= $t->{twig_ignore_action};
3697                                                  
3698  ***    110     50                         392       if( $action eq 'print')
3699  ***      0                                  0         { _twig_print_original( $p, $gi); }
3700                                                  #    elsif( $action eq 'string')
3701                                                  #      { $t->{twig_buffered_string} .= $p->original_string(); }
3702                                                  
3703         110                                302       $t->{twig_ignore_level}--;
3704                                                  
3705         110    100                         389       if( ! $t->{twig_ignore_level})
3706                                                        { 
3707          46                                165           $t->{twig_current}   = $t->{twig_ignore_elt};
3708          46                                282           $t->{twig_current}->set_twig_current;
3709                                                  
3710          46                                206           $t->{twig_ignore_elt}->cut;  # there could possibly be a memory leak here (delete would avoid it,
3711                                                                                       # but could also delete elements that should not be deleted)
3712                                                  
3713                                                          # restore the saved stack to the current level
3714          46                                 81           splice( @{$t->{_twig_context_stack}}, $p->depth+ 1 );
              46                                290   
3715                                                          #warn "stack: ", _dump_stack( $t->{_twig_context_stack}), "\n";
3716                                                  
3717          46                                811           $p->setHandlers( @{$t->{twig_saved_handlers}});
              46                                292   
3718                                                          # test for handlers
3719          46    100                       18899           if( $t->{twig_endtag_handlers})
3720                                                            { # look for end tag handlers
3721          12                                 62               my @handlers= _handler( $t, $t->{twig_endtag_handlers}, $gi);
3722          12                                 28               my $last_handler_res=1;
3723          12                                 35               foreach my $handler ( @handlers)
3724  ***     12            33                   44                 { $last_handler_res= $handler->($t, $gi) || last; }
3725                                                            }
3726          46                                220           pop @{$t->{_twig_context_stack}};
              46                                180   
3727                                                        };
3728         110                                304       return;    
3729                                                    }
3730                                                  
3731                                                  #sub _dump_stack { my( $stack)= @_; return join( ":", map { $_->{_tag} } @$stack); }
3732                                                      
3733                                                  sub ignore
3734          49                   49           207     { my( $t, $elt)= @_;
3735          49                                173       my $current= $t->{twig_current};
3736                                                  
3737          49    100    100                  655       if( ! ($elt && ref( $elt) && isa( $elt, 'XML::Twig::Elt'))) { $elt= $current; }
      ***     19            66                   51   
3738                                                  
3739                                                      #warn "ignore:  current = ", $current->tag, ", elt = ", $elt->tag, ")\n";
3740                                                  
3741                                                      # we need the ($elt == $current->{last_child}) test because the current element is set to the
3742                                                      # parent _before_ handlers are called (and I can't figure out how to fix this)
3743          49    100    100                  453       unless( ($elt == $current) || ($current->{last_child} && ($elt == $current->{last_child})) || $current->in( $elt)) 
                           100                        
                           100                        
3744           2                                  9         { _croak( "element to be ignored must be ancestor of current element"); }
3745                                                  
3746          47    100                         257       $t->{twig_ignore_level}= $current == $elt ? 1 : $t->_level_in_stack( $current) - $t->_level_in_stack($elt) + 1;
3747                                                      #warn "twig_ignore_level:  $t->{twig_ignore_level} (current: ", $current->tag, ", elt: ", $elt->tag, ")\n";
3748          47                                169       $t->{twig_ignore_elt}  = $elt;     # save it, so we can delete it later
3749                                                  
3750  ***     47            50                  143       my $action= shift || 1; 
3751          47                                274       $t->{twig_ignore_action}= $action;
3752                                                  
3753          47                                144       my $p= $t->{twig_parser};
3754          47                                731       my @saved_handlers= $p->setHandlers( %twig_handlers_ignore); # set handlers
3755  ***     47     50                       18970       if( $action eq 'print')
3756  ***      0                                  0         { $p->setHandlers( Default => \&_twig_print_original); }
3757                                                  #    elsif( $action eq 'string')
3758                                                  #      { # not used at the moment
3759                                                  #        $t->{twig_buffered_string}='';
3760                                                  #        $p->setHandlers( Default => \&twig_buffer_original);
3761                                                  #      }
3762                                                  
3763          47                                472       $t->{twig_saved_handlers}= \@saved_handlers;        # save current handlers
3764                                                    }
3765                                                  
3766                                                  sub _level_in_stack
3767          30                   30            98     { my( $t, $elt)= @_;
3768          30                                 66       my $level=1;
3769          30                                 53       foreach my $elt_in_stack ( @{$t->{_twig_context_stack}} )
              30                                155   
3770  ***     83    100     66                  701         { if( $elt_in_stack->{_elt} && ($elt == $elt_in_stack->{_elt})) { return $level }
              30                                175   
3771          53                                126           $level++;
3772                                                        }
3773                                                    }
3774                                                  
3775                                                  
3776                                                  
3777                                                  # select $t->{twig_output_fh} and store the current selected fh 
3778                                                  sub _set_fh_to_twig_output_fh
3779        2805                 2805          7283     { my $t= shift;
3780        2805                               8402       my $output_fh= $t->{twig_output_fh};
3781        2805    100    100                13789       if( $output_fh && !$t->{twig_output_fh_selected})
3782                                                        { # there is an output fh
3783          31                                255           $t->{twig_selected_fh}= select(); # store the currently selected fh
3784          31                                109           $t->{twig_output_fh_selected}=1;
3785          31                                221           select $output_fh;                # select the output fh for the twig
3786                                                        }
3787                                                    }
3788                                                  
3789                                                  # select the fh that was stored in $t->{twig_selected_fh} 
3790                                                  # (before $t->{twig_output_fh} was selected)
3791                                                  sub _set_fh_to_selected_fh
3792        2767                 2767          6819     { my $t= shift;
3793        2767    100                       12188       return unless( $t->{twig_output_fh});
3794          31                                101       my $selected_fh= $t->{twig_selected_fh};
3795          31                                 89       $t->{twig_output_fh_selected}=0;
3796          31                                225       select $selected_fh;
3797          31                                 74       return;
3798                                                    }
3799                                                    
3800                                                  
3801                                                  sub encoding
3802  ***      5     50             5            63     { return $_[0]->{twig_xmldecl}->{encoding} if( $_[0]->{twig_xmldecl}); }
3803                                                  
3804                                                  sub set_encoding
3805           4                    4            22     { my( $t, $encoding)= @_;
3806  ***      4            50                   22       $t->{twig_xmldecl} ||={};
3807  ***      4     50                          16       $t->set_xml_version( "1.0") unless( $t->xml_version);
3808           4                                 18       $t->{twig_xmldecl}->{encoding}= $encoding;
3809           4                                 20       return $t;
3810                                                    }
3811                                                  
3812                                                  sub output_encoding
3813           2                    2            20     { return $_[0]->{output_encoding}; }
3814                                                    
3815                                                  sub set_output_encoding
3816          18                   18           120     { my( $t, $encoding)= @_;
3817          18           100                   75       my $output_filter= $t->output_filter || '';
3818                                                  
3819          18    100    100                  364       if( ($encoding && $encoding !~ m{^utf-?8$}i) || $t->{twig_keep_encoding} || $output_filter)
      ***                   66                        
                           100                        
3820          16           100                   92         { $t->set_output_filter( _encoding_filter( $encoding || '')); }
3821                                                  
3822          18                                 81       $t->{output_encoding}= $encoding;
3823          18                                 76       return $t;
3824                                                    }
3825                                                  
3826                                                  sub xml_version
3827  ***      7     50             7            86     { return $_[0]->{twig_xmldecl}->{version} if( $_[0]->{twig_xmldecl}); }
3828                                                  
3829                                                  sub set_xml_version
3830           1                    1             5     { my( $t, $version)= @_;
3831  ***      1            50                   16       $t->{twig_xmldecl} ||={};
3832           1                                  6       $t->{twig_xmldecl}->{version}= $version;
3833           1                                  4       return $t;
3834                                                    }
3835                                                  
3836                                                  sub standalone
3837  ***      2     50             2            28     { return $_[0]->{twig_xmldecl}->{standalone} if( $_[0]->{twig_xmldecl}); }
3838                                                  
3839                                                  sub set_standalone
3840           1                    1             5     { my( $t, $standalone)= @_;
3841  ***      1            50                    8       $t->{twig_xmldecl} ||={};
3842  ***      1     50                          80       $t->set_xml_version( "1.0") unless( $t->xml_version);
3843           1                                  5       $t->{twig_xmldecl}->{standalone}= $standalone;
3844           1                                  4       return $t;
3845                                                    }
3846                                                  
3847                                                  
3848                                                  # SAX methods
3849                                                  
3850                                                  sub toSAX1
3851           2    100             2            36     { _croak( "cannot use toSAX1 while parsing (use flush_toSAX1)") if (defined $_[0]->{twig_parser});
3852           1                                  7       shift(@_)->_toSAX(@_, \&XML::Twig::Elt::_start_tag_data_SAX1,
3853                                                                            \&XML::Twig::Elt::_end_tag_data_SAX1
3854                                                               ); 
3855                                                    }
3856                                                  
3857                                                  sub toSAX2
3858           5    100             5           156     { _croak( "cannot use toSAX2 while parsing (use flush_toSAX2)") if (defined $_[0]->{twig_parser});
3859           4                                 30       shift(@_)->_toSAX(@_, \&XML::Twig::Elt::_start_tag_data_SAX2,
3860                                                                            \&XML::Twig::Elt::_end_tag_data_SAX2
3861                                                               ); 
3862                                                    }
3863                                                  
3864                                                  
3865                                                  sub _toSAX
3866           5                    5            22     { my( $t, $handler, $start_tag_data, $end_tag_data) = @_;
3867                                                  
3868           5    100                          70       if( my $start_document =  $handler->can( 'start_document'))
3869           4                                 22         { $start_document->( $handler); }
3870                                                      
3871           5                                 27       $t->_prolog_toSAX( $handler);
3872                                                      
3873  ***      5     50                          22       if( $t->root) { $t->root->_toSAX( $handler, $start_tag_data, $end_tag_data) ; }
               5                                 14   
3874  ***      5     50                          73       if( my $end_document =  $handler->can( 'end_document'))
3875           5                                 23         { $end_document->( $handler); }
3876                                                    }
3877                                                  
3878                                                  
3879                                                  sub flush_toSAX1
3880           3                    3            59     { shift(@_)->_flush_toSAX(@_, \&XML::Twig::Elt::_start_tag_data_SAX1,
3881                                                                                 \&XML::Twig::Elt::_end_tag_data_SAX1
3882                                                               ); 
3883                                                    }
3884                                                  
3885                                                  sub flush_toSAX2
3886           3                    3            39     { shift(@_)->_flush_toSAX(@_, \&XML::Twig::Elt::_start_tag_data_SAX2,
3887                                                                                 \&XML::Twig::Elt::_end_tag_data_SAX2
3888                                                               ); 
3889                                                    }
3890                                                  
3891                                                  sub _flush_toSAX
3892           6                    6            33     { my( $t, $handler, $start_tag_data, $end_tag_data)= @_;
3893                                                  
3894                                                      # the "real" last element processed, as _twig_end has closed it
3895           6                                 18       my $last_elt;
3896           6    100                          25       if( $t->{twig_current})
3897           4                                 20         { $last_elt= $t->{twig_current}->_last_child; }
3898                                                      else
3899           2                                  6         { $last_elt= $t->{twig_root}; }
3900                                                  
3901           6                                 20       my $elt= $t->{twig_root};
3902           6    100                          19       unless( $elt->_flushed)
3903                                                        { # init unless already done (ie root has been flushed)
3904  ***      2     50                          15           if( my $start_document =  $handler->can( 'start_document'))
3905           2                                 11             { $start_document->( $handler); }
3906                                                          # flush the DTD
3907           2                                 11           $t->_prolog_toSAX( $handler) 
3908                                                        }
3909                                                  
3910           6                                 22       while( $elt)
3911          18                                151         { my $next_elt; 
3912  ***     18    100     66                  107           if( $last_elt && $last_elt->in( $elt))
3913                                                            { 
3914           6    100                          20               unless( $elt->_flushed) 
3915                                                                { # just output the front tag
3916  ***      4     50                          25                   if( my $start_element = $handler->can( 'start_element'))
3917  ***      4     50                          11                    { if( my $tag_data= $start_tag_data->( $elt))
3918           4                                 17                        { $start_element->( $handler, $tag_data); }
3919                                                                   }
3920           4                                 27                   $elt->_set_flushed;
3921                                                                }
3922           6                                 19               $next_elt= $elt->{first_child};
3923                                                            }
3924                                                          else
3925                                                            { # an element before the last one or the last one,
3926          12                                 34               $next_elt= $elt->{next_sibling};  
3927          12                                 54               $elt->_toSAX( $handler, $start_tag_data, $end_tag_data);
3928          12                                 47               $elt->delete; 
3929  ***     12    100     66                  103               last if( $last_elt && ($elt == $last_elt));
3930                                                            }
3931          12                                 29           $elt= $next_elt;
3932                                                        }
3933           6    100                          46       if( !$t->{twig_parsing}) 
3934  ***      2     50                          16         { if( my $end_document =  $handler->can( 'end_document'))
3935           2                                  9             { $end_document->( $handler); }
3936                                                        }
3937                                                    }
3938                                                  
3939                                                  
3940                                                  sub _prolog_toSAX
3941           7                    7            27     { my( $t, $handler)= @_;
3942           7                                 26       $t->_xmldecl_toSAX( $handler);
3943           7                                 32       $t->_DTD_toSAX( $handler);
3944                                                    }
3945                                                  
3946                                                  sub _xmldecl_toSAX
3947           7                    7            21     { my( $t, $handler)= @_;
3948           7                                 25       my $decl= $t->{twig_xmldecl};
3949           7                                 75       my $data= { Version    => $decl->{version},
3950                                                                  Encoding   => $decl->{encoding},
3951                                                                  Standalone => $decl->{standalone},
3952                                                            };
3953           7    100                          73       if( my $xml_decl= $handler->can( 'xml_decl'))
3954           4                                 18         { $xml_decl->( $handler, $data); }
3955                                                    }
3956                                                                  
3957                                                  sub _DTD_toSAX
3958           7                    7            25     { my( $t, $handler)= @_;
3959           7                                 26       my $doctype= $t->{twig_doctype};
3960           7    100                          31       return unless( $doctype);
3961           2                                 20       my $data= { Name     => $doctype->{name},
3962                                                                  PublicId => $doctype->{pub},
3963                                                                  SystemId => $doctype->{sysid},
3964                                                                };
3965                                                  
3966  ***      2     50                          21       if( my $start_dtd= $handler->can( 'start_dtd'))
3967           2                                  8         { $start_dtd->( $handler, $data); }
3968                                                  
3969                                                      # I should call code to export the internal subset here 
3970                                                      
3971  ***      2     50                          23       if( my $end_dtd= $handler->can( 'end_dtd'))
3972           2                                  8         { $end_dtd->( $handler); }
3973                                                    }
3974                                                  
3975                                                  # input/output filters
3976                                                  
3977                                                  sub latin1 
3978           2                    2            20     { local $SIG{__DIE__};
3979  ***      2     50      0                    8       if( _use(  'Encode'))
      ***             0                               
      ***             0                               
3980           2                                  7         { return encode_convert( 'ISO-8859-15'); }
3981                                                      elsif( _use( 'Text::Iconv'))
3982  ***      0                                  0         { return iconv_convert( 'ISO-8859-15'); }
3983                                                      elsif( _use( 'Unicode::Map8') && _use( 'Unicode::String'))
3984  ***      0                                  0         { return unicode_convert( 'ISO-8859-15'); }
3985                                                      else
3986  ***      0                                  0         { return \&regexp2latin1; }
3987                                                    }
3988                                                  
3989                                                  sub _encoding_filter
3990                                                    { 
3991          16                   16            31         { local $SIG{__DIE__};
              16                                202   
3992  ***     16            66                  145           my $encoding= $_[1] || $_[0];
3993  ***     16     50      0                   51           if( _use( 'Encode'))
      ***             0                               
      ***             0                               
3994          16                                 54             { my $sub= encode_convert( $encoding);
3995          16                                119               return $sub;
3996                                                            }
3997                                                          elsif( _use( 'Text::Iconv'))
3998  ***      0                                  0             { return iconv_convert( $encoding); }
3999                                                          elsif( _use( 'Unicode::Map8') && _use( 'Unicode::String'))
4000  ***      0                                  0             { return unicode_convert( $encoding); }
4001                                                          }
4002  ***      0                                  0       _croak( "Encode, Text::Iconv or Unicode::Map8 and Unicode::String need to be installed in order to use encoding options");
4003                                                    }
4004                                                  
4005                                                  # shamelessly lifted from XML::TyePYX (works only with XML::Parse 2.27)
4006                                                  sub regexp2latin1
4007           1                    1            10     { my $text=shift;
4008           1                                  6       $text=~s{([\xc0-\xc3])(.)}{ my $hi = ord($1);
      ***      0                                  0   
4009  ***      0                                  0                                   my $lo = ord($2);
4010  ***      0                                  0                                   chr((($hi & 0x03) <<6) | ($lo & 0x3F))
4011                                                                                }ge;
4012           1                                 14       return $text;
4013                                                    }
4014                                                  
4015                                                  
4016                                                  sub html_encode
4017  ***      5     50             5            16     { _use( 'HTML::Entities') or croak "cannot use html_encode: missing HTML::Entities";
4018           5                                 24       return HTML::Entities::encode_entities($_[0] );
4019                                                    }
4020                                                  
4021                                                  sub safe_encode
4022          19                   19            50     {   my $str= shift;
4023  ***     19     50                          54         if( $] < 5.008)
4024                                                          { # the no utf8 makes the regexp work in 5.6
4025  ***      0                                  0             $str =~ s{([\xC0-\xDF].|[\xE0-\xEF]..|[\xF0-\xFF]...)}
      ***      0                                  0   
4026                                                                     {_XmlUtf8Decode($1)}egs; 
4027                                                          }
4028                                                        else
4029          19                                 70           { $str= encode( ascii => $str, $FB_HTMLCREF); }
4030          19                               1256         return $str;
4031                                                    }
4032                                                  
4033                                                  sub safe_encode_hex
4034          19                   19            53     {   my $str= shift;
4035  ***     19     50                          54         if( $] < 5.008)
4036                                                          { # the no utf8 makes the regexp work in 5.6
4037  ***      0                                  0             $str =~ s{([\xC0-\xDF].|[\xE0-\xEF]..|[\xF0-\xFF]...)}
      ***      0                                  0   
4038                                                                     {_XmlUtf8Decode($1, 1)}egs; 
4039                                                          }
4040                                                        else
4041          19                                 71           { $str= encode( ascii => $str, $FB_XMLCREF); }
4042          19                               1223         return $str;
4043                                                    }
4044                                                  
4045                                                  # this one shamelessly lifted from XML::DOM
4046                                                  # does NOT work on 5.8.0
4047                                                  sub _XmlUtf8Decode
4048           4                    4            56     { my ($str, $hex) = @_;
4049           4                                 17       my $len = length ($str);
4050           4                                  7       my $n;
4051                                                  
4052  ***      4     50                          11       if ($len == 2)
      ***             0                               
      ***             0                               
      ***             0                               
4053           4                                 24         { my @n = unpack "C2", $str;
4054           4                                 19           $n = (($n[0] & 0x3f) << 6) + ($n[1] & 0x3f);
4055                                                        }
4056                                                      elsif ($len == 3)
4057  ***      0                                  0         { my @n = unpack "C3", $str;
4058  ***      0                                  0           $n = (($n[0] & 0x1f) << 12) + (($n[1] & 0x3f) << 6) + ($n[2] & 0x3f);
4059                                                        }
4060                                                      elsif ($len == 4)
4061  ***      0                                  0         { my @n = unpack "C4", $str;
4062  ***      0                                  0           $n = (($n[0] & 0x0f) << 18) + (($n[1] & 0x3f) << 12) 
4063                                                             + (($n[2] & 0x3f) << 6) + ($n[3] & 0x3f);
4064                                                        }
4065                                                      elsif ($len == 1)    # just to be complete...
4066  ***      0                                  0         { $n = ord ($str); }
4067                                                      else
4068  ***      0                                  0         { croak "bad value [$str] for _XmlUtf8Decode"; }
4069                                                  
4070           4    100                          23       my $char= $hex ? sprintf ("&#x%x;", $n) : "&#$n;";
4071           4                                 27       return $char;
4072                                                    }
4073                                                  
4074                                                  
4075                                                  sub unicode_convert
4076  ***      1     50             1            22     { my $enc= $_[1] ? $_[1] : $_[0]; # so the method can be called on the twig or directly
4077  ***      1     50                           5       _use( 'Unicode::Map8') or croak "Unicode::Map8 not available, needed for encoding filter: $!";
4078  ***      1     50                           7       _use( 'Unicode::String') or croak "Unicode::String not available, needed for encoding filter: $!";
4079           1                                  8       import Unicode::String qw(utf8);
4080  ***      1     50             1             3       my $sub= eval qq{ { $NO_WARNINGS;
               1                    1             5   
               1                                  8   
               1                                  1   
               1                                  6   
4081                                                                          my \$cnv;
4082                                                                          BEGIN {  \$cnv= Unicode::Map8->new(\$enc) 
4083                                                                                       or croak "Can't create converter to \$enc";
4084                                                                                }
4085                                                                          sub { return  \$cnv->to8 (utf8(\$_[0])->ucs2); } 
4086                                                                        } 
4087                                                                      };
4088  ***      1     50                           6       unless( $sub) { croak $@; }
      ***      0                                  0   
4089           1                                  6       return $sub;
4090                                                    }
4091                                                  
4092                                                  sub iconv_convert
4093  ***      4     50             4            58     { my $enc= $_[1] ? $_[1] : $_[0]; # so the method can be called on the twig or directly
4094  ***      4     50                          17       _use( 'Text::Iconv') or croak "Text::Iconv not available, needed for encoding filter: $!";
4095  ***      4     50             1             9       my $sub= eval qq{ { $NO_WARNINGS;
      ***      1     50             1             9   
               1                    1             2   
               1                    1            12   
               1                                  8   
               1                                  3   
               1                                  6   
               1                                  7   
               1                                  2   
4096                                                                          my \$cnv;
4097                                                                          BEGIN { \$cnv = Text::Iconv->new( 'utf8', \$enc) 
4098                                                                                       or croak "Can't create iconv converter to \$enc";
4099                                                                                }
4100                                                                          sub { return  \$cnv->convert( \$_[0]); } 
4101                                                                        }       
4102                                                                      };
4103           4    100                          23       unless( $sub)
4104  ***      1     50                           7         { if( $@=~ m{^Unsupported conversion: Invalid argument})
4105  ***      0                                  0             { croak "Unsupported encoding: $enc"; }
4106                                                          else
4107           1                                  5             { croak $@; }
4108                                                        }
4109                                                  
4110           3                                 32       return $sub;
4111                                                    }
4112                                                  
4113                                                  sub encode_convert
4114  ***     18     50            18            64     { my $enc= $_[1] ? $_[1] : $_[0]; # so the method can be called on the twig or directly
4115          18                    1            36       my $sub=  eval qq{sub { $NO_WARNINGS; return encode( "$enc", \$_[0]); } };
               1                    1             8   
               1                    1             2   
               1                    1             6   
               1                    1             9   
               1                    1             2   
               1                    1             6   
               1                    1             8   
               1                    1             2   
               1                    1             6   
               1                    1            10   
               1                    1             2   
               1                    1             8   
               1                    1             7   
               1                    1             2   
               1                    1             6   
               1                                  7   
               1                                 10   
               1                                  7   
               1                                  8   
               1                                  2   
               1                                  5   
               1                                  7   
               1                                  2   
               1                                  5   
               1                                  9   
               1                                  2   
               1                                  6   
               1                                  8   
               1                                  2   
               1                                  7   
               1                                  6   
               1                                 10   
               1                                  2   
               1                                  8   
               1                                  6   
               1                                  3   
               1                                  8   
               1                                  2   
               1                                  6   
               1                                  7   
               1                                  3   
               1                                  5   
               1                                  8   
               1                                  2   
               1                                  6   
               1                                  8   
               1                                  1   
               1                                  6   
4116  ***     18     50                          82       croak "can't create Encode-based filter: $@" unless( $sub);
4117          18                                 72       return $sub;
4118                                                    }
4119                                                  
4120                                                  
4121                                                  # XML::XPath compatibility
4122         122                  122        309599   sub getRootNode        { return $_[0]; }
4123          17                   17           372   sub getParentNode      { return undef; }
4124         167    100           167         23764   sub getChildNodes      { my @children= ($_[0]->root); return wantarray ? @children : \@children; }
             167                               1190   
4125                                                  
4126                                                  sub _weakrefs
4127           1                    1           263     { return $weakrefs; }
4128                                                  
4129                                                  sub _dump
4130           5                    5            15     { my $t= shift;
4131           5                                 14       my $dump='';
4132                                                  
4133           5                                 11       $dump="document\n"; # should dump twig level data here
4134  ***      5     50                          19       if( $t->root) { $dump .= $t->root->_dump( @_); }
               5                                 17   
4135                                                  
4136           5                                 33       return $dump;
4137                                                      
4138                                                    }
4139                                                  
4140                                                  
4141                                                  1;
4142                                                  
4143                                                  ######################################################################
4144                                                  package XML::Twig::Entity_list;
4145                                                  ######################################################################
4146          92                   92           901   use UNIVERSAL qw(isa);
              92                                215   
              92                                894   
4147                                                  
4148                                                  sub new
4149        2759                 2759          8410     { my $class = shift;
4150        2759                              15005       my $self={ entities => {}, updated => 0};
4151                                                  
4152        2759                              11837       bless $self, $class;
4153        2759                              13586       return $self;
4154                                                  
4155                                                    }
4156                                                  
4157                                                  sub add_new_ent
4158           5                    5            15     { my $ent_list= shift;
4159           5                                 37       my $ent= XML::Twig::Entity->new( @_);
4160           5                                 21       $ent_list->add( $ent);
4161           5                                 18       return $ent_list;
4162                                                    }
4163                                                  
4164                                                  sub _add_list
4165           5                    5            19     { my( $ent_list, $to_add)= @_;
4166           5                                 20       my $ents_to_add= $to_add->{entities};
4167  ***      5    100     66                   63       return $ent_list unless( $ents_to_add && %$ents_to_add);
4168           3                                 21       @{$ent_list->{entities}}{keys %$ents_to_add}= values %$ents_to_add;
               3                                 17   
4169           3                                 12       $ent_list->{updated}=1;
4170           3                                  8       return $ent_list;
4171                                                    }
4172                                                  
4173                                                  sub add
4174          74                   74           230     { my( $ent_list, $ent)= @_;
4175          74                                413       $ent_list->{entities}->{$ent->{name}}= $ent;
4176          74                                230       $ent_list->{updated}=1;
4177          74                                196       return $ent_list;
4178                                                    }
4179                                                  
4180                                                  sub ent
4181          16                   16          1108     { my( $ent_list, $ent_name)= @_;
4182          16                                111       return $ent_list->{entities}->{$ent_name};
4183                                                    }
4184                                                  
4185                                                  # can be called with an entity or with an entity name
4186                                                  sub delete
4187           4                    4            12     { my $ent_list= shift;
4188           4    100                          29       if( isa( ref $_[0], 'XML::Twig::Entity'))
4189                                                        { # the second arg is an entity
4190           1                                  3           my $ent= shift;
4191           1                                  6           delete $ent_list->{entities}->{$ent->{name}};
4192                                                        }
4193                                                      else
4194                                                        { # the second arg was not entity, must be a string then
4195           3                                  9           my $name= shift;
4196           3                                 14           delete $ent_list->{entities}->{$name};
4197                                                        }
4198           4                                 14       $ent_list->{updated}=1;
4199           4                                 14       return $ent_list;
4200                                                    }
4201                                                  
4202                                                  sub print
4203           2                    2             8     { my ($ent_list, $fh)= @_;
4204  ***      2     50                          12       my $old_select= defined $fh ? select $fh : undef;
4205                                                  
4206           2                                  5       foreach my $ent_name ( sort keys %{$ent_list->{entities}})
               2                                 20   
4207           4                                 46         { my $ent= $ent_list->{entities}->{$ent_name};
4208                                                          # we have to test what the entity is or un-defined entities can creep in
4209  ***      4     50                          29           if( isa( $ent, 'XML::Twig::Entity')) { $ent->print(); }
               4                                 13   
4210                                                        }
4211  ***      2     50                          42       select $old_select if( defined $old_select);
4212           2                                  7       return $ent_list;
4213                                                    }
4214                                                  
4215                                                  sub text
4216          16                   16            50     { my ($ent_list)= @_;
4217          16                                 45       return join "\n", map { $ent_list->{entities}->{$_}->text} sort keys %{$ent_list->{entities}};
              19                                103   
              16                                188   
4218                                                    }
4219                                                  
4220                                                  # return the list of entity names 
4221                                                  sub entity_names($)
4222           6                    6            16     { my $ent_list= shift;
4223           6                                 11       return sort keys %{$ent_list->{entities}} ;
               6                                126   
4224                                                    }
4225                                                  
4226                                                  
4227                                                  sub list
4228           5                    5            20     { my ($ent_list)= @_;
4229           5                                 14       return map { $ent_list->{entities}->{$_} } sort keys %{$ent_list->{entities}};
              10                                 57   
               5                                 44   
4230                                                    }
4231                                                  
4232                                                  1;
4233                                                  
4234                                                  ######################################################################
4235                                                  package XML::Twig::Entity;
4236                                                  ######################################################################
4237          92                   92           819   use UNIVERSAL qw(isa);
              92                                198   
              92                                645   
4238                                                  
4239                                                  sub new
4240          80                   80           501     { my( $class, $name, $val, $sysid, $pubid, $ndata, $param)= @_;
4241  ***     80            33                  687       $class= ref( $class) || $class;
4242                                                  
4243          80                                208       my $self={};
4244                                                      
4245          80                                347       $self->{name}  = $name;
4246          80    100                         342       $self->{val}   = $val   if( defined $val  );
4247          80    100                         298       $self->{sysid} = $sysid if( defined $sysid);
4248          80    100                         217       $self->{pubid} = $pubid if( defined $pubid);
4249          80    100                         236       $self->{ndata} = $ndata if( defined $ndata);
4250          80    100                         207       $self->{param} = $param if( defined $param);
4251                                                  
4252          80                                388       bless $self, $class;
4253          80                                285       return $self;
4254                                                    }
4255                                                  
4256                                                  
4257           8                    8           644   sub name  { return $_[0]->{name}; }
4258           2                    2            15   sub val   { return $_[0]->{val}; }
4259           3    100             3            35   sub sysid { return defined( $_[0]->{sysid}) ? $_[0]->{sysid} : ''; }
4260  ***      2     50             2            20   sub pubid { return defined( $_[0]->{pubid}) ? $_[0]->{pubid} : ''; }
4261           2    100             2            21   sub ndata { return defined( $_[0]->{ndata}) ? $_[0]->{ndata} : ''; }
4262           2    100             2            32   sub param { return defined( $_[0]->{param}) ? $_[0]->{param} : ''; }
4263                                                  
4264                                                  
4265                                                  sub print
4266          14                   14            87     { my ($ent, $fh)= @_;
4267          14                                 47       my $text= $ent->text;
4268  ***     14     50                         102       if( !defined( $text)) { $text=''; }
      ***      0                                  0   
4269  ***     14     50                          44       if( $fh) { print $fh $text . "\n"; }
      ***      0                                  0   
4270          14                                135       else     { print $text . "\n"; }
4271                                                    }
4272                                                  
4273                                                  sub sprint
4274           3                    3             8     { my ($ent)= @_;
4275           3                                 10       my $text= $ent->text;
4276  ***      3     50                          13       if( !defined( $text)) { $text=''; }
      ***      0                                  0   
4277           3                                 30       return $text;
4278                                                    }
4279                                                  sub text
4280         111                  111           312     { my ($ent)= @_;
4281                                                      #warn "text called: '", $ent->_dump, "'\n";
4282         111    100                         628       return '' if( !$ent->{name});
4283         109                                174       my @tokens;
4284         109                                305       push @tokens, '<!ENTITY';
4285                                                     
4286         109    100                         393       push @tokens, '%' if( $ent->{param});
4287         109                                359       push @tokens, $ent->{name};
4288                                                  
4289         109    100    100                 1305       if( defined $ent->{val} && !defined( $ent->{sysid}) && !defined($ent->{pubid}) )
      ***            50     66                        
4290          57                                255         { push @tokens, _quoted_val( $ent->{val});
4291                                                        }
4292                                                      elsif( defined $ent->{sysid})
4293          52    100                         201         { push @tokens, 'PUBLIC', _quoted_val( $ent->{pubid}) if( $ent->{pubid});
4294          52    100                         230           push @tokens, 'SYSTEM' unless( $ent->{pubid});
4295          52                                217           push @tokens, _quoted_val( $ent->{sysid}); 
4296          52    100                         316           push @tokens, 'NDATA', $ent->{ndata} if( $ent->{ndata});
4297                                                        }
4298         109                               1034       return join( ' ', @tokens) . '>';
4299                                                    }
4300                                                  
4301                                                  sub _quoted_val
4302  ***    113     50           113          1056     { my $q= $_[0]=~ m{"} ? q{'} : q{"};
4303         113                                699       return qq{$q$_[0]$q};
4304                                                    }
4305                                                  
4306                                                  sub _dump
4307           1                    1             4     { my( $ent)= @_; return join( " - ", map { "$_ => '$ent->{$_}'" } grep { defined $ent->{$_} } sort keys %$ent); }
               1                                 13   
               2                                 20   
               2                                 10   
4308                                                                  
4309                                                  1;
4310                                                  
4311                                                  ######################################################################
4312                                                  package XML::Twig::Elt;
4313                                                  ######################################################################
4314          92                   92           812   use Carp;
              92                                213   
              92                                802   
4315                                                  
4316          92                   92           718   use UNIVERSAL qw(isa);
              92                                200   
              92                                490   
4317                                                  
4318          92                   92           689   use constant  PCDATA  => '#PCDATA'; 
              92                                194   
              92                               1064   
4319          92                   92           665   use constant  CDATA   => '#CDATA'; 
              92                                177   
              92                                491   
4320          92                   92           659   use constant  PI      => '#PI'; 
              92                                215   
              92                                523   
4321          92                   92           681   use constant  COMMENT => '#COMMENT'; 
              92                                275   
              92                                611   
4322          92                   92           658   use constant  ENT     => '#ENT'; 
              92                                178   
              92                                465   
4323                                                  
4324          92                   92           651   use constant  ASIS    => '#ASIS';    # pcdata elements not to be XML-escaped
              92                                186   
              92                                478   
4325                                                  
4326          92                   92           702   use constant  ELT     => '#ELT'; 
              92                                178   
              92                                456   
4327          92                   92           644   use constant  TEXT    => '#TEXT'; 
              92                                180   
              92                                474   
4328          92                   92           650   use constant  EMPTY   => '#EMPTY'; 
              92                                168   
              92                                529   
4329                                                  
4330          92                   92           628   use constant CDATA_START    => "<![CDATA[";
              92                                166   
              92                                462   
4331          92                   92           631   use constant CDATA_END      => "]]>";
              92                                261   
              92                                463   
4332          92                   92           757   use constant PI_START       => "<?";
              92                                202   
              92                                558   
4333          92                   92           651   use constant PI_END         => "?>";
              92                                173   
              92                                609   
4334          92                   92           668   use constant COMMENT_START  => "<!--";
              92                                163   
              92                                573   
4335          92                   92           621   use constant COMMENT_END    => "-->";
              92                                166   
              92                                472   
4336                                                  
4337          92                   92           653   use constant XMLNS_URI      => 'http://www.w3.org/2000/xmlns/';
              92                                190   
              92                                471   
4338                                                  my $XMLNS_URI               = XMLNS_URI;
4339                                                  
4340                                                  
4341                                                  BEGIN
4342                                                    { # set some aliases for methods
4343          92                   92           633       *tag           = *gi; 
4344          92                                410       *name          = *gi; 
4345          92                                437       *set_tag       = *set_gi; 
4346          92                                418       *set_name      = *set_gi; 
4347          92                                382       *find_nodes    = *get_xpath; # as in XML::DOM
4348          92                                405       *findnodes     = *get_xpath; # as in XML::LibXML
4349          92                                383       *field         = *first_child_text;
4350          92                                409       *trimmed_field = *first_child_trimmed_text;
4351          92                                397       *is_field      = *contains_only_text;
4352          92                                403       *is            = *passes;
4353          92                                421       *matches       = *passes;
4354          92                                625       *has_child     = *first_child;
4355          92                                510       *has_children  = *first_child;
4356          92                                425       *all_children_pass = *all_children_are;
4357          92                                502       *all_children_match= *all_children_are;
4358          92                                427       *getElementsByTagName= *descendants;
4359          92                                384       *find_by_tag_name= *descendants_or_self;
4360          92                                421       *unwrap          = *erase;
4361          92                                383       *inner_xml       = *xml_string;
4362          92                                428       *outer_xml       = *sprint;
4363                                                    
4364          92                                386       *first_child_is  = *first_child_matches;
4365          92                                387       *last_child_is   = *last_child_matches;
4366          92                                504       *next_sibling_is = *next_sibling_matches;
4367          92                                386       *prev_sibling_is = *prev_sibling_matches;
4368          92                                473       *next_elt_is     = *next_elt_matches;
4369          92                                470       *prev_elt_is     = *prev_elt_matches;
4370          92                                383       *parent_is       = *parent_matches;
4371          92                                374       *child_is        = *child_matches;
4372          92                                391       *inherited_att   = *inherit_att;
4373                                                  
4374          92                                387       *sort_children_by_value= *sort_children_on_value;
4375                                                  
4376          92                                457       *has_atts= *att_nb;
4377                                                  
4378                                                      # imports from XML::Twig
4379          92                                425       *_is_fh= *XML::Twig::_is_fh;
4380                                                  
4381                                                      # XML::XPath compatibility
4382          92                                399       *string_value       = *text;
4383          92                                472       *toString           = *sprint;
4384          92                                391       *getName            = *gi;
4385          92                                476       *getRootNode        = *twig;  
4386          92                                395       *getNextSibling     = *_next_sibling;
4387          92                                422       *getPreviousSibling = *_prev_sibling;
4388          92                                395       *isElementNode      = *is_elt;
4389          92                                380       *isTextNode         = *is_text;
4390          92                                412       *isPI               = *is_pi;
4391          92                                395       *isPINode           = *is_pi;
4392          92                                380       *isProcessingInstructionNode= *is_pi;
4393          92                                463       *isComment          = *is_comment;
4394          92                                399       *isCommentNode      = *is_comment;
4395          92                                385       *getTarget          = *target;
4396          92                                381       *getFirstChild      = *_first_child;
4397          92                                398       *getLastChild      = *_last_child;
4398                                                  
4399                                                      # try using weak references
4400                                                      # test whether we can use weak references
4401          92                                256       { local $SIG{__DIE__};
              92                                785   
4402  ***     92     50     33                 3625         if( eval 'require Scalar::Util' && defined( &Scalar::Util::weaken) )
      ***             0                               
4403          92                                677           { import Scalar::Util qw(weaken); }
4404                                                        elsif( eval 'require WeakRef')
4405  ***      0                                  0           { import WeakRef; }
4406                                                      }
4407                                                  }
4408                                                  
4409                                                   
4410                                                  # can be called as XML::Twig::Elt->new( [[$gi, $atts, [@content]])
4411                                                  # - gi is an optional gi given to the element
4412                                                  # - $atts is a hashref to attributes for the element
4413                                                  # - @content is an optional list of text and elements that will
4414                                                  #   be inserted under the element 
4415                                                  sub new 
4416       22162                22162         62323     { my $class= shift;
4417  ***  22162            66               148007       $class= ref $class || $class;
4418       22162                              52724       my $elt  = {};
4419       22162                              81149       bless ($elt, $class);
4420                                                  
4421       22162    100                       61968       return $elt unless @_;
4422                                                  
4423                                                      # if a gi is passed then use it
4424       22158                              54516       my $gi= shift;
4425       22158                              69095       $elt->set_gi( $gi);
4426                                                  
4427                                                  
4428       22158    100                       75522       my $atts= ref $_[0] eq 'HASH' ? shift : undef;
4429                                                  
4430       22158    100    100                77561       if( $atts && defined $atts->{'#CDATA'})
4431           4                                 12         { delete $atts->{'#CDATA'};
4432                                                  
4433           4                                 30           my $cdata= new( $class, '#CDATA', @_);
4434           3                                 11           return new( $class, $gi, $atts, $cdata);
4435                                                        }
4436                                                  
4437       22154    100                      130845       if( $gi eq PCDATA)
                    100                               
                    100                               
                    100                               
                    100                               
4438        6673    100                       21849         { if( grep { ref $_ } @_) { croak "element #PCDATA can only be created from text"; }
             270                               1091   
               1                                  5   
4439        6672                              31392           $elt->_set_pcdata( join( '', @_)); 
4440                                                        }
4441                                                      elsif( $gi eq ENT)
4442          45                                187         { $elt->{ent}=  shift; }
4443                                                      elsif( $gi eq CDATA)
4444         104    100                         370         { if( grep { ref $_ } @_) { croak "element #CDATA can only be created from text"; }
               9                                 40   
               1                                  5   
4445         103                                573           $elt->_set_cdata( join( '', @_)); 
4446                                                        }
4447                                                      elsif( $gi eq COMMENT)
4448        1758    100                        6121         { if( grep { ref $_ } @_) { croak "element #COMMENT can only be created from text"; }
               3                                 14   
               1                                  4   
4449        1757                               8618           $elt->_set_comment( join( '', @_)); 
4450                                                        }
4451                                                      elsif( $gi eq PI)
4452        1469    100                        5541         { if( grep { ref $_ } @_) { croak "element #PI can only be created from text"; }
               3                                 11   
               1                                  5   
4453        1468                               8262           $elt->_set_pi( shift, join( '', @_));
4454                                                        }
4455                                                      else
4456                                                        { # the rest of the arguments are the content of the element
4457       12105    100                       29255           if( @_)
4458          96                                392             { $elt->set_content( @_); }
4459                                                          else
4460       12009                              44309             { $elt->{empty}=  1;    }
4461                                                        }
4462                                                  
4463       22150    100                       53236       if( $atts)
4464                                                        { # the attribute hash can be used to pass the asis status 
4465          71    100                         251           if( defined $atts->{'#ASIS'})  { $elt->set_asis(  $atts->{'#ASIS'} ); delete $atts->{'#ASIS'};  }
               2                                 14   
               2                                  8   
4466          71    100                         230           if( defined $atts->{'#EMPTY'}) { $elt->{empty}=  $atts->{'#EMPTY'}; delete $atts->{'#EMPTY'}; }
               2                                  9   
               2                                  8   
4467          71    100                         259           if( keys %$atts) { $elt->set_atts( $atts); }
              29                                112   
4468          71    100                         397           $elt->_set_id( $atts->{$ID}) if( $atts->{$ID});
4469                                                        }
4470                                                  
4471       22150                              63588       return $elt;
4472                                                    }
4473                                                  
4474                                                  # this function creates an XM:::Twig::Elt from a string
4475                                                  # it is quite clumsy at the moment, as it just creates a
4476                                                  # new twig then returns its root
4477                                                  # there might also be memory leaks there
4478                                                  # additional arguments are passed to new XML::Twig
4479                                                  sub parse
4480          22                   22          3783     { my $class= shift;
4481          22    100                          96       if( ref( $class)) { $class= ref( $class); }
               2                                  7   
4482          22                                 60       my $string= shift;
4483          22                                 89       my %args= @_;
4484          22                                132       my $t= XML::Twig->new(%args);
4485          22                                 89       $t->parse( $string);
4486          22                                 86       my $elt= $t->root;
4487                                                      # clean-up the node 
4488          22                                 79       delete $elt->{twig};         # get rid of the twig data
4489          22                                 53       delete $elt->{twig_current}; # better get rid of this too
4490          22    100                          93       if( $t->{twig_id_list}) { $elt->{twig_id_list}= $t->{twig_id_list}; }
               5                                 23   
4491          22                                 20       return $elt;
4492                                                    }
4493                                                     
4494                                                  sub set_inner_xml
4495           2                    2            11     { my( $elt, $xml, @args)= @_;
4496           2                                 13       my $new_elt= $elt->parse( "<dummy>$xml</dummy>", @args);
4497           2                                 37       $elt->cut_children;
4498           2                                 12       $new_elt->paste_first_child( $elt);
4499           2                                  8       $new_elt->erase;
4500           2                                  2       return $elt;
4501                                                    }
4502                                                    
4503                                                  sub set_inner_html
4504           4                    4            29     { my( $elt, $html)= @_;
4505           4                                 24       my $t= XML::Twig->new->parse_html( "<html>$html</html>");
4506           4                                 18       my $new_elt= $t->root;
4507           4    100                          20       if( $elt->tag eq 'head')
                    100                               
4508           1                                  6         { $new_elt->first_child( 'head')->unwrap;
4509           1                                  1           $new_elt->first_child( 'body')->cut;
4510                                                        }
4511                                                      elsif( $elt->tag ne 'html')
4512           2                                 10         { $new_elt->first_child( 'head')->cut;
4513           2                                  1           $new_elt->first_child( 'body')->unwrap;
4514                                                        }
4515           4                                  8       $new_elt->cut;
4516           4                                 14       $elt->cut_children;
4517           4                                 34       $new_elt->paste_first_child( $elt);
4518           4                                 14       $new_elt->erase;
4519           4                                  3       return $elt;
4520                                                    }
4521                                                  
4522                                                  sub set_gi 
4523       22184                22184         86393     { my ($elt, $gi)= @_;
4524       22184    100                       94930       unless( defined $XML::Twig::gi2index{$gi})
4525                                                        { # new gi, create entries in %gi2index and @index2gi
4526         666                               2911           push  @XML::Twig::index2gi, $gi;
4527         666                               3848           $XML::Twig::gi2index{$gi}= $#XML::Twig::index2gi;
4528                                                        }
4529       22184                              96498       $elt->{gi}= $XML::Twig::gi2index{$gi};
4530       22184                              55664       return $elt; 
4531                                                    }
4532                                                  
4533        7053                 7053         93186   sub gi  { return $XML::Twig::index2gi[$_[0]->{gi}]; }
4534                                                  
4535                                                  sub local_name 
4536         107                  107          2222     { my $elt= shift;
4537         107                                486       return _local_name( $XML::Twig::index2gi[$elt->{'gi'}]);
4538                                                    }
4539                                                  
4540                                                  sub ns_prefix
4541          79                   79           170     { my $elt= shift;
4542          79                                351       return _ns_prefix( $XML::Twig::index2gi[$elt->{'gi'}]);
4543                                                    }
4544                                                  
4545                                                  # namespace prefix for any qname (can be used for elements or attributes)
4546                                                  sub _ns_prefix
4547         125                  125           285     { my $qname= shift;
4548         125    100                         611       if( $qname=~ m{^([^:]*):})
4549          52                                529         { return $1; }
4550                                                      else
4551          73                                362         { return( ''); } # should it be '' ?
4552                                                    }
4553                                                  
4554                                                  # local name for any qname (can be used for elements or attributes)
4555                                                  sub _local_name
4556         120                  120           342     { my $qname= shift;
4557         120                                499       (my $local= $qname)=~ s{^[^:]*:}{};
4558         120                               1336       return $local;
4559                                                    }
4560                                                  
4561                                                  BEGIN 
4562          92                   92         15487     { my %DEFAULT_NS= ( xml   => "http://www.w3.org/XML/1998/namespace",
4563                                                                        xmlns => "http://www.w3.org/2000/xmlns/",
4564                                                                      );
4565                                                   
4566                                                      #sub get_namespace
4567                                                      sub namespace
4568          70                   70           263         { my $elt= shift;
4569          70    100                         278           my $prefix= defined $_[0] ? shift() : $elt->ns_prefix;
4570          70    100                         290           my $ns_att= $prefix ? "xmlns:$prefix" : "xmlns";
4571          70           100                  492           my $expanded= $DEFAULT_NS{$prefix} || $elt->_inherit_att_through_cut( $ns_att) || '';
                           100                        
4572          70                                364           return $expanded;
4573                                                        }
4574                                                  
4575                                                      sub declare_missing_ns
4576  ***      0                    0             0         { my $root= shift;
4577  ***      0                                  0           my %missing_prefix;
4578  ***      0                                  0           my $map= $root->_current_ns_prefix_map;
4579                                                  
4580  ***      0                                  0           foreach my $prefix (keys %$map)
4581  ***      0      0                           0             { my $prefix_att= $prefix eq '#default' ? 'xmlns' : "xmlns:$prefix";
4582  ***      0      0                           0               if( ! $root->{'att'}->{$prefix_att}) 
4583  ***      0                                  0                 { $root->set_att( $prefix_att => $map->{$prefix}); }
4584                                                            }
4585  ***      0                                  0           return $root;
4586                                                        }
4587                                                  
4588                                                    }
4589                                                  
4590                                                  sub _current_ns_prefix_map
4591  ***      0                    0             0     { my( $elt)= shift;
4592  ***      0                                  0       my $map;
4593  ***      0                                  0       while( $elt)
4594  ***      0                                  0         { foreach my $att ($elt->att_names)
4595  ***      0      0                           0             { my $prefix= $att eq 'xmlns'        ? '#default'
      ***             0                               
4596                                                                        : $att=~ m{^xmlns:(.*)$} ? $1
4597                                                                        : next
4598                                                                        ;
4599  ***      0      0                           0               if( ! exists $map->{$prefix}) { $map->{$prefix}= $elt->{'att'}->{$att}; }
      ***      0                                  0   
4600                                                            }
4601  ***      0             0                    0           $elt= $elt->{parent} || $elt->former_parent;
4602                                                        }
4603  ***      0                                  0       return $map;
4604                                                    }
4605                                                   
4606                                                  sub set_ns_decl
4607  ***      0                    0             0     { my( $elt, $uri, $prefix)= @_;
4608  ***      0      0                           0       my $ns_att=  $prefix ? "xmlns:$prefix" : 'xmlns';
4609  ***      0                                  0       $elt->set_att( $ns_att => $uri);
4610  ***      0                                  0       return $elt;
4611                                                    }
4612                                                  
4613                                                  sub set_ns_as_default
4614  ***      0                    0             0     { my( $root, $uri)= @_;
4615  ***      0                                  0       my @ns_decl_to_remove;
4616  ***      0                                  0       foreach my $elt ($root->descendants_or_self)
4617  ***      0      0      0                    0         { if( $elt->_ns_prefix && $elt->namespace eq $uri) 
4618  ***      0                                  0             { $elt->set_tag( $elt->local_name); }
4619                                                          # store any namespace declaration for that uri
4620  ***      0      0                           0           foreach my $ns_decl (grep { $_=~ m{xmlns(:|$)} && $elt->{'att'}->{$_} eq $uri } $elt->att_names)
      ***      0                                  0   
4621  ***      0                                  0             { push @ns_decl_to_remove, [$elt, $ns_decl]; }
4622                                                        }
4623  ***      0                                  0       $root->set_ns_decl( $uri);
4624                                                      # now remove the ns declarations (if done earlier then descendants of an element with the ns declaration
4625                                                      # are not considered being in the namespace
4626  ***      0                                  0       foreach my $ns_decl_to_remove ( @ns_decl_to_remove)
4627  ***      0                                  0         { my( $elt, $ns_decl)= @$ns_decl_to_remove;
4628  ***      0                                  0           $elt->del_att( $ns_decl);
4629                                                        }
4630                                                      
4631  ***      0                                  0       return $root;
4632                                                    }
4633                                                       
4634                                                  
4635                                                  
4636                                                  # return #ELT for an element and #PCDATA... for others
4637                                                  sub get_type
4638           6                    6            30     { my $gi_nb= $_[0]->{gi}; # the number, not the string
4639           6    100                          28       return ELT if( $gi_nb >= $XML::Twig::SPECIAL_GI);
4640           5                                 19       return $_[0]->gi;
4641                                                    }
4642                                                  
4643                                                  # return the gi if it's a "real" element, 0 otherwise
4644                                                  sub is_elt
4645        1727    100          1727         52801     { if(  $_[0]->{gi} >=  $XML::Twig::SPECIAL_GI)
4646        1456                               5514        { return $_[0]->gi; }
4647                                                      else
4648         271                               2083         { return 0; }
4649                                                    }
4650                                                  
4651                                                  
4652                                                  sub is_pcdata
4653        1791                 1791          4119     { my $elt= shift;
4654        1791                               8504       return (exists $elt->{'pcdata'});
4655                                                    }
4656                                                  
4657                                                  sub is_cdata
4658           1                    1             9     { my $elt= shift;
4659           1                                  8       return (exists $elt->{'cdata'});
4660                                                    }
4661                                                  
4662                                                  sub is_pi
4663           9                    9            28     { my $elt= shift;
4664           9                                 51       return (exists $elt->{'target'});
4665                                                    }
4666                                                  
4667                                                  sub is_comment
4668           5                    5            15     { my $elt= shift;
4669           5                                 29       return (exists $elt->{'comment'});
4670                                                    }
4671                                                  
4672                                                  sub is_ent
4673           1                    1             4     { my $elt= shift;
4674  ***      1            33                   25       return (exists $elt->{ent} || $elt->{ent_name});
4675                                                    } 
4676                                                  
4677                                                  
4678                                                  sub is_text
4679        2005                 2005          5243     { my $elt= shift;
4680        2005           100                19597       return (exists( $elt->{'pcdata'}) || (exists $elt->{'cdata'}));
4681                                                    }
4682                                                  
4683                                                  sub is_empty
4684           5           100      5            61     { return $_[0]->{empty} || 0; }
4685                                                  
4686                                                  sub set_empty
4687  ***      1     50             1             8     { $_[0]->{empty}= defined( $_[1]) ? $_[1] : 1; return $_[0]; }
               1                                  4   
4688                                                  
4689                                                  sub set_not_empty
4690  ***      1     50     50      1            13     { delete $_[0]->{empty} if( ($_[0]->{'empty'} || 0)); return $_[0]; }
               1                                  3   
4691                                                  
4692                                                  
4693                                                  sub set_asis
4694          16                   16            57     { my $elt=shift;
4695                                                  
4696          16                                 69       foreach my $descendant ($elt, $elt->_descendants )
4697          23                                 86         { $descendant->{asis}= 1;
4698          23    100                         176           if( (exists $descendant->{'cdata'}))
4699           2                                  6             { $descendant->set_gi( PCDATA);
4700           2                                 10               $descendant->_set_pcdata( $descendant->{cdata});
4701                                                            }
4702                                                  
4703                                                        }
4704          16                                 63       return $elt;
4705                                                    }
4706                                                  
4707                                                  sub set_not_asis
4708           1                    1             4     { my $elt=shift;
4709           1                                  5       foreach my $descendant ($elt, $elt->descendants)
4710  ***      2     50                          15         { delete $descendant->{asis} if $descendant->{asis};}
4711           1                                  4       return $elt;
4712                                                    }
4713                                                  
4714                                                  sub is_asis
4715          64                   64           357     { return $_[0]->{asis}; }
4716                                                  
4717                                                  sub closed 
4718          15                   15           178     { my $elt= shift;
4719  ***     15            33                   77       my $t= $elt->twig || return;
4720          15                                 51       my $curr_elt= $t->{twig_current};
4721          15    100                          62       return 1 unless( $curr_elt);
4722          14                                147       return $curr_elt->in( $elt);
4723                                                    }
4724                                                  
4725                                                  sub set_pcdata 
4726         330                  330          1548     { my( $elt, $pcdata)= @_;
4727                                                    
4728         330    100                        1097       if( $elt->_extra_data_in_pcdata)
4729          12                                 39         { _try_moving_extra_data( $elt, $pcdata);
4730                                                        }
4731         330                                903       delete $elt->{empty};
4732         330                               1136       $elt->{pcdata}= $pcdata;
4733         330                                929       return $elt; 
4734                                                    }
4735                                                  
4736        2308                 2308         17185   sub _extra_data_in_pcdata      { return $_[0]->{extra_data_in_pcdata}; }
4737          12                   12            50   sub _set_extra_data_in_pcdata  { $_[0]->{extra_data_in_pcdata}= $_[1]; return $_[0]; }
              12                                 33   
4738           3                    3            14   sub _del_extra_data_in_pcdata  { delete $_[0]->{extra_data_in_pcdata}; return $_[0]; }
               3                                 12   
4739          14                   14            26   sub _unshift_extra_data_in_pcdata { unshift @{shift()->{extra_data_in_pcdata}}, { text => shift(), offset => shift() }; }
              14                                150   
4740         111                  111           190   sub _push_extra_data_in_pcdata    { push @{shift()->{extra_data_in_pcdata}},    { text => shift(), offset => shift() }; }
             111                               1048   
4741                                                  
4742        5759           100   5759         83638   sub _extra_data_before_end_tag     { return $_[0]->{extra_data_before_end_tag} || ''; }
4743         324                  324          2928   sub _set_extra_data_before_end_tag { $_[0]->{extra_data_before_end_tag}= $_[1]; return $_[0]}
             324                                728   
4744  ***      0                    0             0   sub _del_extra_data_before_end_tag { delete $_[0]->{extra_data_before_end_tag}; return $_[0]}
      ***      0                                  0   
4745                                                  sub _prefix_extra_data_before_end_tag 
4746           9                    9            34     { my( $elt, $data)= @_;
4747           9    100                          38       if($elt->{extra_data_before_end_tag})
4748           2                                 13         { $elt->{extra_data_before_end_tag}= $data . $elt->{extra_data_before_end_tag}; }
4749                                                      else  
4750           7                                 32         { $elt->{extra_data_before_end_tag}= $data; }
4751           9                                 29       return $elt;
4752                                                    }
4753                                                  
4754                                                  # internal, in cases where we know there is no extra_data (inlined anyway!)
4755       13051                13051         64572   sub _set_pcdata { $_[0]->{pcdata}= $_[1]; }
4756                                                  
4757                                                  # try to figure out if we can keep the extra_data around
4758                                                  sub _try_moving_extra_data
4759          12                   12            43     { my( $elt, $modified)=@_;
4760          12                                 43       my $initial= $elt->{pcdata};
4761          12                                 36       my $cpis= $elt->_extra_data_in_pcdata;
4762                                                  
4763          12    100                         104       if( (my $offset= index( $modified, $initial)) != -1) 
                    100                               
4764                                                        { # text has been added
4765           2                                  9           foreach (@$cpis) { $_->{offset}+= $offset; }
               2                                 15   
4766                                                        }
4767                                                      elsif( ($offset= index( $initial, $modified)) != -1)
4768                                                        { # text has been cut
4769           4                                  9           my $len= length( $modified);
4770           4                                 12           foreach my $cpi (@$cpis) { $cpi->{offset} -= $offset; }
               4                                 21   
4771           4    100                          15           $elt->_set_extra_data_in_pcdata( [ grep { $_->{offset} >= 0 && $_->{offset} < $len } @$cpis ]);
               4                                 49   
4772                                                        } 
4773                                                      else
4774           6    100    100                   24         {    _match_extra_data_words( $elt, $initial, $modified)
4775                                                          || _match_extra_data_chars( $elt, $initial, $modified)
4776                                                          || $elt->_del_extra_data_in_pcdata;
4777                                                        }
4778                                                    }
4779                                                  
4780                                                  sub _match_extra_data_words
4781           6                    6            31     { my( $elt, $initial, $modified)= @_;
4782           6                                127       my @initial= split /\b/, $initial; 
4783           6                                 52       my @modified= split /\b/, $modified;
4784                                                         
4785           6                                 41       return _match_extra_data( $elt, length( $initial), \@initial, \@modified);
4786                                                    }
4787                                                    
4788                                                  sub _match_extra_data_chars
4789           4                    4            32     { my( $elt, $initial, $modified)= @_;
4790           4                                 40       my @initial= split //, $initial; 
4791           4                                 32       my @modified= split //, $modified;
4792                                                         
4793           4                                 24       return _match_extra_data( $elt, length( $initial), \@initial, \@modified);
4794                                                    }
4795                                                  
4796                                                  sub _match_extra_data
4797          10                   10            40     { my( $elt, $length, $initial, $modified)= @_;
4798                                                          
4799          10                                 33       my $cpis= $elt->_extra_data_in_pcdata;
4800                                                  
4801          10    100                          42       if( @$initial <= @$modified)
4802                                                        { 
4803           5                                 19           my( $ok, $positions, $offsets)= _pos_offset( $initial, $modified);
4804           5    100                          19           if( $ok) 
4805           2                                  5             { my $offset=0;
4806           2                                  4               my $pos= shift @$positions;
4807           2                                  8               foreach my $cpi (@$cpis)
4808           2                                 10                 { while( $cpi->{offset} >= $pos)
4809           2                                  5                     { $offset= shift @$offsets; 
4810  ***      2            33                   24                       $pos= shift @$positions || $length +1;
4811                                                                    }
4812           2                                 11                   $cpi->{offset} += $offset;
4813                                                                }
4814           2                                 21               return 1;
4815                                                            }
4816                                                        }
4817                                                      else
4818           5                                 16         { my( $ok, $positions, $offsets)= _pos_offset( $modified, $initial);
4819           5    100                          21           if( $ok)
4820                                                            { #print STDERR "pos:    ", join( ':', @$positions), "\n",
4821                                                              #             "offset: ", join( ':', @$offsets), "\n";
4822           1                                  3               my $offset=0;
4823           1                                  3               my $pos= shift @$positions;
4824           1                                  2               my $prev_pos= 0;
4825                                                              
4826           1                                  5               foreach my $cpi (@$cpis)
4827           1                                  6                 { while( $cpi->{offset} >= $pos)
4828           1                                  3                     { $offset= shift @$offsets;
4829           1                                  2                       $prev_pos= $pos;
4830  ***      1            33                   13                       $pos= shift @$positions || $length +1;
4831                                                                    }
4832           1                                  4                   $cpi->{offset} -= $offset;
4833  ***      1     50                           6                   if( $cpi->{offset} < $prev_pos) { delete $cpi->{text}; }
               1                                  5   
4834                                                                }
4835           1                                  3               $elt->_set_extra_data_in_pcdata( [ grep { exists $_->{text} } @$cpis ]);
               1                                  8   
4836           1                                  9               return 1;
4837                                                            }
4838                                                        }
4839           7                                 70       return 0;
4840                                                    }
4841                                                  
4842                                                            
4843                                                  sub _pos_offset
4844          10                   10            32     { my( $short, $long)= @_;
4845          10                                 24       my( @pos, @offset);
4846          10                                 27       my( $s_length, $l_length)=(0,0);
4847          10                                 35       while (@$short)
4848          22                                 61         { my $s_word= shift @$short;
4849          22                                 57           my $l_word= shift @$long;
4850          22    100                          70           if( $s_word ne $l_word)
4851          10           100                   93             { while( @$long && $s_word ne $l_word)
4852          31                                104                 { $l_length += length( $l_word);
4853          31                                230                   $l_word= shift @$long;
4854                                                                }
4855          10    100    100                   92               if( !@$long && $s_word ne $l_word) { return 0; }
               7                                 38   
4856           3                                  7               push @pos, $s_length;
4857           3                                 11               push @offset, $l_length - $s_length;
4858                                                            }
4859          15                                 37           my $length= length( $s_word);
4860          15                                 27           $s_length += $length;
4861          15                                 51           $l_length += $length;
4862                                                        }
4863           3                                 19       return( 1, \@pos, \@offset);
4864                                                    }
4865                                                  
4866                                                  sub append_pcdata
4867           3                    3            11     { delete $_[0]->{empty};
4868           3                                 15       $_[0]->{'pcdata'}.= $_[1];
4869           3                                  9       return $_[0]; 
4870                                                    }
4871                                                  
4872          11                   11            93   sub pcdata        { return $_[0]->{pcdata}; }
4873                                                  
4874                                                  
4875                                                  sub append_extra_data 
4876           1                    1             7     {  $_[0]->{extra_data}.= $_[1];
4877           1                                  4        return $_[0]; 
4878                                                    }
4879                                                    
4880                                                  sub set_extra_data 
4881         695                  695          2803     { $_[0]->{extra_data}= $_[1];
4882         695                               1589       return $_[0]; 
4883                                                    }
4884         157           100    157          1658   sub extra_data { return $_[0]->{extra_data} || ''; }
4885                                                  
4886                                                  sub set_target 
4887           3                    3            18     { my( $elt, $target)= @_;
4888           3                                 14       $elt->{target}= $target;
4889           3                                 11       return $elt; 
4890                                                    }
4891           1                    1            15   sub target { return $_[0]->{target}; }
4892                                                  
4893                                                  sub set_data 
4894           5                    5            29     { $_[0]->{'data'}= $_[1]; 
4895           5                                 21       return $_[0];
4896                                                    }
4897           5                    5            74   sub data { return $_[0]->{data}; }
4898                                                  
4899                                                  sub set_pi
4900           1                    1             3     { my $elt= shift;
4901  ***      1     50                           8       unless( $elt->{gi} == $XML::Twig::gi2index{'#PI'})
4902           1                                  4         { $elt->cut_children;
4903           1                                 51           $elt->set_gi( '#PI');
4904                                                        }
4905           1                                  5       return $elt->_set_pi( @_);
4906                                                    }
4907                                                  
4908                                                  sub _set_pi
4909        2934                 2934         12169     { $_[0]->{target}=  $_[1];
4910        2934                              11346       $_[0]->{data}=  $_[2];
4911        2934                               6805       return $_[0]; 
4912                                                    }
4913                                                  
4914        1464                 1464          6908   sub pi_string { my $string= PI_START . $_[0]->{target};
4915        1464                               4720                   my $data= $_[0]->{data};
4916  ***   1464     50     33                11637                   if( defined( $data) && $data ne '') { $string .= " $data"; }
            1464                               4214   
4917        1464                               3314                   $string .= PI_END ;
4918        1464                               5185                   return $string;
4919                                                                }
4920                                                  
4921                                                  sub set_comment
4922           7                    7            24     { my $elt= shift;
4923           7    100                          43       unless( $elt->{gi} == $XML::Twig::gi2index{'#COMMENT'})
4924           1                                  4         { $elt->cut_children;
4925           1                                  8           $elt->set_gi( '#COMMENT');
4926                                                        }
4927           7                                 29       return $elt->_set_comment( @_);
4928                                                    }
4929                                                  
4930        3518                 3518         15213   sub _set_comment   { $_[0]->{comment}= $_[1]; return $_[0]; }
            3518                               7923   
4931           3                    3            48   sub comment        { return $_[0]->{comment}; }
4932        1764                 1764         12269   sub comment_string { return COMMENT_START . $_[0]->{comment} . COMMENT_END; }
4933                                                  
4934           1                    1             7   sub set_ent  { $_[0]->{ent}= $_[1]; return $_[0]; }
               1                                  3   
4935           2                    2            15   sub ent      { return $_[0]->{ent}; }
4936          12                   12           179   sub ent_name { return substr( $_[0]->{ent}, 1, -1);}
4937                                                  
4938                                                  sub set_cdata 
4939           2                    2            11     { my $elt= shift;
4940           2    100                          20       unless( $elt->{gi} == $XML::Twig::gi2index{'#CDATA'})
4941           1                                  4         { $elt->cut_children;
4942           1                                  6           $elt->insert_new_elt( first_child => '#CDATA', @_);
4943           1                                  3           return $elt;
4944                                                        }
4945           1                                  5       return $elt->_set_cdata( @_);
4946                                                    }
4947                                                    
4948                                                  sub _set_cdata 
4949         214                  214           707     { delete $_[0]->{empty};
4950         214                                844       $_[0]->{cdata}= $_[1]; 
4951         214                                563       return $_[0];
4952                                                    }
4953                                                  
4954                                                  sub append_cdata
4955           1                    1             6     { $_[0]->{cdata}.= $_[1]; 
4956           1                                  4       return $_[0];
4957                                                    }
4958          47                   47           503   sub cdata { return $_[0]->{cdata}; }
4959                                                  
4960                                                  
4961                                                  sub contains_only_text
4962          42                   42            96     { my $elt= shift;
4963          42    100                         110       return 0 unless $elt->is_elt;
4964          24                                 77       foreach my $child ($elt->_children)
4965          25    100                          62         { return 0 if $child->is_elt; }
4966          15                                119       return $elt;
4967                                                    } 
4968                                                    
4969                                                  sub contains_only
4970           5                    5            22     { my( $elt, $exp)= @_;
4971           5                                 18       my @children= $elt->_children;
4972           5                                 16       foreach my $child (@children)
4973           7    100                          21         { return 0 unless $child->is( $exp); }
4974           3           100                   26       return @children || 1;
4975                                                    } 
4976                                                  
4977                                                  sub contains_a_single
4978         156                  156           635     { my( $elt, $exp)= @_;
4979         156    100                        2337       my $child= $elt->{first_child} or return 0;
4980          50    100                         194       return 0 unless $child->passes( $exp);
4981          47    100                         284       return 0 if( $child->{next_sibling});
4982          45                                341       return $child;
4983                                                    } 
4984                                                  
4985                                                  
4986                                                  sub root 
4987        1231                 1231          2670     { my $elt= shift;
4988        1231                               6011       while( $elt->{parent}) { $elt= $elt->{parent}; }
             515                               2790   
4989        1231                               3699       return $elt;
4990                                                    }
4991                                                  
4992                                                  sub _root_through_cut
4993  ***      0                    0             0     { my $elt= shift;
4994  ***      0             0                    0       while( $elt->{parent} || $elt->former_parent) { $elt= $elt->{parent} || $elt->former_parent; }
      ***      0             0                    0   
4995  ***      0                                  0       return $elt;
4996                                                    }
4997                                                  
4998                                                  sub twig 
4999        1209                 1209          4107     { my $elt= shift;
5000        1209                               3666       my $root= $elt->root;
5001        1209                               8525       return $root->{twig};
5002                                                    }
5003                                                  
5004                                                  sub _twig_through_cut
5005  ***      0                    0             0     { my $elt= shift;
5006  ***      0                                  0       my $root= $elt->_root_through_cut;
5007  ***      0                                  0       return $root->{twig};
5008                                                    }
5009                                                  
5010                                                  
5011                                                  # returns undef or the element, depending on whether $elt passes $cond
5012                                                  # $cond can be
5013                                                  # - empty: the element passes the condition
5014                                                  # - ELT ('#ELT'): the element passes the condition if it is a "real" element
5015                                                  # - TEXT ('#TEXT'): the element passes if it is a CDATA or PCDATA element
5016                                                  # - a string with an XPath condition (only a subset of XPath is actually
5017                                                  #   supported).
5018                                                  # - a regexp: the element passes if its gi matches the regexp
5019                                                  # - a code ref: the element passes if the code, applied on the element,
5020                                                  #   returns true
5021                                                  
5022                                                  my %cond_cache; # expression => coderef
5023                                                  
5024           1                    1           237   sub reset_cond_cache { %cond_cache=(); }
5025                                                  
5026                                                  { 
5027                                                     sub _install_cond
5028         314                  314           822       { my $cond= shift;
5029         314                                446         my $test;
5030         314                                695         my $init='';
5031                                                  
5032         314                                595         my $original_cond= $cond;
5033                                                  
5034         314    100                        1375         my $not= ($cond=~ s{^\s*!}{}) ? '!' : '';
5035                                                  
5036         314    100                        1107         if( ref $cond eq 'CODE') { return $cond; }
               1                                  7   
5037                                                      
5038         313    100                        1398         if( ref $cond eq 'Regexp')
5039           3                                 16           { $test = qq{(\$_[0]->gi=~ /$cond/)}; }
5040                                                        else
5041                                                          { # the condition is a string
5042         310    100                       10764             if( $cond eq ELT)     
                    100                               
                    100                               
                    100                               
                    100                               
                    100                               
                    100                               
                    100                               
5043           6                                 20               { $test = qq{\$_[0]->is_elt}; }
5044                                                            elsif( $cond eq TEXT) 
5045          11                                 37               { $test = qq{\$_[0]->is_text}; }
5046                                                            elsif( $cond=~ m{^\s*($REG_NAME_W)\s*$}o)                  
5047                                                              { # gi
5048         128    100                         643                 if( $1 ne '*')
5049                                                                  { # 2 options, depending on whether the gi exists in gi2index
5050                                                                    # start optimization
5051         127                                487                     my $gi= $XML::Twig::gi2index{$1};
5052         127    100                         361                     if( $gi)
5053                                                                      { # the gi exists, use its index as a faster shortcut
5054         102                                525                         $test = qq{ \$_[0]->{gi} == $XML::Twig::gi2index{$1}};
5055                                                                      }
5056                                                                    else
5057                                                                    # end optimization
5058                                                                      { # it does not exist (but might be created later), compare the strings
5059          25                                153                         $test = qq{ \$_[0]->gi eq "$1"}; 
5060                                                                      }
5061                                                                  }
5062                                                                else
5063           1                                  4                   { $test = qq{ (1) } }
5064                                                              }
5065                                                            elsif( $cond=~ m{^\s*($REG_REGEXP)\s*$}o)
5066                                                              { # /regexp/
5067           2                                 12                 $test = qq{ \$_[0]->gi=~ $1 }; 
5068                                                              }
5069                                                            elsif( $cond=~ m{^\s*($REG_NAME_W)?\s*  # $1
5070                                                                             \[\s*(-?)\s*(\d+)\s*\] #   [$2]
5071                                                                             \s*$}xo
5072                                                                 )
5073          47                                280               { my( $gi, $neg, $index)= ($1, $2, $3);
5074          47    100                         148                 my $siblings= $neg ? q{$_[0]->_next_siblings} : q{$_[0]->_prev_siblings};
5075          47    100    100                  382                 if( $gi && ($gi ne '*')) 
5076          30                                215                   { $test= qq{((\$_[0]->gi eq "$gi") && (scalar( grep { \$_->gi eq "$gi" } $siblings) + 1 == $index))}; }
5077                                                                else
5078          17                                 96                   { $test= qq{(scalar( $siblings) + 1 == $index)}; }
5079                                                              }
5080                                                            elsif( $cond=~ m{^\s*\.([\w-]+)\s*$}o)
5081                                                              { # .class
5082           4                                 14                 my $class= $1;
5083           4                                 18                 $test = qq{(\$_[0]->in_class( "$class")) }; 
5084                                                              }
5085                                                            elsif( $cond=~ m{^\s*($REG_NAME_W?)\s*($REG_PREDICATE)\s*$})
5086          93                                528               { my( $tag, $predicate)= ( $1, $2);
5087          93    100    100                  849                 $test= ( $tag && $tag ne '*') ? qq{ (\$_[0]->gi eq "$tag") && } : '';
5088          93                                302                 $test .=   _parse_predicate_in_step( $predicate);
5089                                                              }
5090                                                            elsif( $cond=~ m{^\s*($REG_NAKED_PREDICATE)\s*$})
5091          14                                111               { $test .=   _parse_predicate_in_step( $1); }
5092                                                            else
5093           5                                 34               { croak "wrong navigation condition '$original_cond' ($@)"; }
5094                                                          }
5095                                                  
5096                                                        #warn "init: '$init' - test: '$test'\n";
5097                                                  
5098         308                               2243         my $sub= qq{sub { $NO_WARNINGS; $init; return $not($test) ? \$_[0] : undef; } };
5099         308                   54           685         my $s= eval $sub; 
              54                   23           520   
              54                   27           102   
              54                   32           492   
              23                   21           172   
              23                   25            47   
              23                   19           129   
              27                   17           200   
              27                    4            50   
              27                    4           153   
              32                    4           260   
              32                    4            61   
              32                    4           206   
              21                    4           175   
              21                    4            45   
              21                    4           143   
              25                    4           201   
              25                    4            53   
              25                    4           166   
              19                    1           139   
              19                    2            36   
              19                    1           114   
              17                    1           128   
              17                    1            46   
              17                    1           126   
               4                    1            30   
               4                    1             7   
               4                    1            27   
               4                    1            29   
               4                    1             8   
               4                    1            23   
               4                    1            30   
               4                    2             8   
               4                    2            24   
               4                    2            29   
               4                    2             8   
               4                    2            23   
               4                    2            30   
               4                    2             8   
               4                    2            23   
               4                    1            26   
               4                    1             8   
               4                    1            22   
               4                                 31   
               4                                  8   
               4                                 23   
               4                                 27   
               4                                 13   
               4                                 40   
               4                                 29   
               4                                 11   
               4                                 25   
               4                                 26   
               4                                  9   
               4                                 24   
               4                                 29   
               4                                  8   
               4                                 21   
               1                                  7   
               1                                  2   
               1                                  5   
               2                                 15   
               2                                  4   
               2                                 12   
               1                                  8   
               1                                  2   
               1                                  7   
               1                                  9   
               1                                  3   
               1                                  6   
               1                                  7   
               1                                  2   
               1                                  6   
               1                                  6   
               1                                  2   
               1                                 13   
               1                                  7   
               1                                  1   
               1                                  6   
               1                                  9   
               1                                  2   
               1                                 12   
               1                                 11   
               1                                  2   
               1                                  8   
               1                                  8   
               1                                  2   
               1                                  7   
               1                                 10   
               1                                  2   
               1                                  8   
               1                                  9   
               1                                  2   
               1                                  6   
               1                                  6   
               1                                  2   
               1                                  6   
               2                                 14   
               2                                 12   
               2                                 13   
               2                                 18   
               2                                  4   
               2                                 14   
               2                                 15   
               2                                  4   
               2                                 13   
               2                                 15   
               2                                  3   
               2                                 12   
               2                                 12   
               2                                  5   
               2                                 11   
               2                                 17   
               2                                  4   
               2                                 16   
               2                                 14   
               2                                  4   
               2                                 12   
               2                                 14   
               2                                  4   
               2                                 11   
               2                                 14   
               2                                  3   
               2                                 11   
               2                                 14   
               2                                  4   
               2                                 10   
               1                                  7   
               1                                  2   
               1                                  8   
               1                                  8   
               1                                  2   
               1                                  5   
               1                                  7   
               1                                  2   
               1                                  5   
5100                                                        #warn "cond: $cond\n$sub\n";
5101         308    100                        1711         if( $@) 
5102           4                                 27           { croak "wrong navigation condition '$original_cond' ($@);" }
5103         304                               2207         return $s;
5104                                                      }
5105                                                  
5106                                                    # input: the original predicate
5107                                                    sub _parse_predicate_in_step
5108         107                  107           314       { my $cond= shift; 
5109         107                                993         my %PERL_ALPHA_TEST= ( '=' => ' eq ', '!=' => ' ne ', '>' => ' gt ', '>=' => ' ge ', '<' => ' lt ', '<=' => ' le ');
5110                                                  
5111         107                                422         $cond=~ s{^\s*\[\s*}{};
5112         107                                375         $cond=~ s{\s*\]\s*$}{};
5113         107                               5132         $cond=~ s{(   ($REG_STRING)                        # strings
             279                               2683   
5114                                                                     |\@($REG_NAME)(?=\s*(?:[><=!]|!~|=~)) # @att (followed by a comparison operator)
5115  ***    279    100     66                 2774                      |\@($REG_NAME)                        # @att (not followed by a comparison operator)
      ***     60    100     66                  376   
      ***           100     66                        
      ***            50     66                        
      ***           100     33                        
                    100                               
                    100                               
                    100                               
      ***            50                               
                    100                               
5116          76                                766                      |=~|!~                                # matching operators
5117          11                                 78                      |([><]=?|=|!=)(?=\s*[\d+-])           # test before a number
5118  ***      0                                  0                      |([><]=?|=|!=)                        # test, other cases
5119          60                                527                      |($REG_FUNCTION)                      # no arg functions
5120           7                                 52                      # this bit is a mess, but it is the only solution with this half-baked parser
5121           9                                 88                      |((?:string|text)\(\s*$REG_NAME\s*\)\s*$REG_MATCH\s*$REG_REGEXP) # string( child) =~ /regexp/
              17                                193   
5122                                                                     |((?:string|text)\(\s*$REG_NAME\s*\)\s*!?=\s*$REG_VALUE)         # string( child) = "value" (or !=)
5123  ***      0                                  0                      |((?:string|text)\(\s*$REG_NAME\s*\)\s*[<>]=?\s*$REG_VALUE)      # string( child) > "value"
5124          16    100                         175                      |(and|or)
5125          23                                326                   )}
5126                                                                 { my( $token, $string, $att, $bare_att, $num_test, $alpha_test, $func, $string_regexp, $string_eq, $string_test, $and_or)
5127                                                                   = ( $1,     $2,      $3,   $4,        $5,        $6,          $7,    $8,             $9,         $10,          $11);
5128                                                        
5129                                                                   if( defined $string)   { $token }
5130                                                                   elsif( $att)           { "( \$_[0]->{att} && exists( \$_[0]->{att}->{'$att'}) && \$_[0]->{att}->{'$att'})"; }
5131                                                                   elsif( $bare_att)      { "(\$_[0]->{att} && defined( \$_[0]->{att}->{'$bare_att'}))"; }
5132                                                                   elsif( $num_test && ($num_test eq '=') ) { "==" } # others tests are unchanged
5133                                                                   elsif( $alpha_test)    { $PERL_ALPHA_TEST{$alpha_test} }
5134                                                                   elsif( $func && $func=~ m{^(?:string|text)})
5135                                                                                          { "\$_[0]->text"; }
5136                                                                   elsif( $string_regexp && $string_regexp =~ m{(?:string|text)\(\s*($REG_NAME)\s*\)\s*($REG_MATCH)\s*($REG_REGEXP)})
5137                                                                                          { "(XML::Twig::_first_n { (\$_->gi eq '$1') && (\$_->text $2 $3) } 1, \$_[0]->_children)"; }
5138                                                                   elsif( $string_eq     && $string_eq     =~ m{(?:string|text)\(\s*($REG_NAME)\s*\)\s*(!?=)\s*($REG_VALUE)})
5139                                                                                          {"(XML::Twig::_first_n { (\$_->gi eq '$1') && (\$_->text $PERL_ALPHA_TEST{$2} $3) } 1, \$_[0]->_children)"; }
5140                                                                   elsif( $string_test   && $string_test   =~ m{(?:string|text)\(\s*($REG_NAME)\s*\)\s*([<>]=?)\s*($REG_VALUE)})
5141                                                                                          { "(XML::Twig::_first_n { (\$_->gi eq '$1') && (\$_->text $2 $3) } 1, \$_[0]->_children)"; }
5142                                                                   elsif( $and_or)        { $and_or eq 'and' ? '&&' : '||' ; }
5143                                                                   else                   { $token; }
5144                                                                 }gexs;
5145         107                                965         return "($cond)";
5146                                                      }
5147                                                    
5148                                                  
5149                                                    sub _op
5150          82                   82           277       { my $op= shift;
5151          82    100                         265         if(    $op eq '=')  { $op= 'eq'; }
              78    100                         169   
5152           3                                  8         elsif( $op eq '!=') { $op= 'ne'; }
5153          82                                567         return $op;
5154                                                      }
5155                                                  
5156                                                    sub passes
5157        3786                 3786         11683       { my( $elt, $cond)= @_;
5158        3786    100                       22941         return $elt unless $cond;
5159  ***    605            66                 2697         my $sub= ($cond_cache{$cond} ||= _install_cond( $cond));
5160         605                               2230         return $sub->( $elt);
5161                                                      }
5162                                                  }
5163                                                  
5164                                                  sub set_parent 
5165  ***      0                    0             0     { $_[0]->{parent}= $_[1];
5166  ***      0      0                           0       if( $XML::Twig::weakrefs) { weaken( $_[0]->{parent}); }
      ***      0                                  0   
5167                                                    }
5168                                                  
5169                                                  sub parent
5170          41                   41           291     { my $elt= shift;
5171  ***     41            66                  260       my $cond= shift || return $elt->{parent};
5172  ***     26            66                   47       do { $elt= $elt->{parent} || return; } until (!$elt || $elt->passes( $cond));
      ***     39            66                  425   
5173          22                                110       return $elt;
5174                                                    }
5175                                                  
5176                                                  sub set_first_child 
5177          42                   42           133     { delete $_[0]->{empty};
5178          42                                192       $_[0]->{'first_child'}= $_[1]; 
5179                                                    }
5180                                                  
5181                                                  sub first_child
5182         532                  532          1737     { my $elt= shift;
5183  ***    532            66                 2788       my $cond= shift || return $elt->{first_child};
5184         338                               1098       my $child= $elt->{first_child};
5185  ***    338            66                 2177       my $test_cond= ($cond_cache{$cond} ||= _install_cond( $cond));
5186         329           100                 2207       while( $child && !$test_cond->( $child)) 
5187         501                               4211          { $child= $child->{next_sibling}; }
5188         329                               1610       return $child;
5189                                                    }
5190                                                    
5191        4061                 4061         30586   sub _first_child   { return $_[0]->{first_child};  }
5192          40                   40           819   sub _last_child    { return $_[0]->{last_child};   }
5193          44                   44          1567   sub _next_sibling  { return $_[0]->{next_sibling}; }
5194          76                   76          2844   sub _prev_sibling  { return $_[0]->{prev_sibling}; }
5195         115                  115          1016   sub _parent        { return $_[0]->{parent};       }
5196          76                   76           200   sub _next_siblings { my $elt= shift; my @siblings; while( $elt= $elt->{next_sibling}) { push @siblings, $elt; } return @siblings; }
              76                                114   
              76                                329   
             296                               1301   
              76                                543   
5197          89                   89           282   sub _prev_siblings { my $elt= shift; my @siblings; while( $elt= $elt->{prev_sibling}) { push @siblings, $elt; } return @siblings; }
              89                                125   
              89                                403   
             167                                750   
              89                                741   
5198                                                  
5199                                                  # sets a field
5200                                                  # arguments $record, $cond, @content
5201                                                  sub set_field
5202           3                    3            17     { my $record = shift;
5203           3                                  9       my $cond = shift;
5204           3                                 16       my $child= $record->first_child( $cond);
5205           3    100                          12       if( $child)
5206           1                                  5         { $child->set_content( @_); }
5207                                                      else
5208           2    100                         111         { if( $cond=~ m{^\s*($REG_NAME)})
5209           1                                  5             { my $gi= $1;
5210           1                                  5               $child= $record->insert_new_elt( last_child => $gi, @_); 
5211                                                            }
5212                                                          else
5213           1                                  6             { croak "can't create a field name from $cond"; }
5214                                                        } 
5215           2                                  7       return $child;
5216                                                    }
5217                                                  
5218                                                  sub set_last_child 
5219          29                   29            90     { delete $_[0]->{empty};
5220          29                                110       $_[0]->{'last_child'}= $_[1];
5221  ***     29     50                         102       if( $XML::Twig::weakrefs) { weaken( $_[0]->{'last_child'}); }
              29                                164   
5222                                                    }
5223                                                  
5224                                                  sub last_child
5225          53                   53           151     { my $elt= shift;
5226  ***     53            66                  413       my $cond= shift || return $elt->{last_child};
5227  ***     26            66                  129       my $test_cond= ($cond_cache{$cond} ||= _install_cond( $cond));
5228          26                                 88       my $child= $elt->{last_child};
5229          26           100                  181       while( $child && !$test_cond->( $child) )
5230          24                                195         { $child= $child->{prev_sibling}; }
5231          26                                141       return $child
5232                                                    }
5233                                                  
5234                                                  
5235                                                  sub set_prev_sibling 
5236  ***      0                    0             0     { $_[0]->{'prev_sibling'}= $_[1]; 
5237  ***      0      0                           0       if( $XML::Twig::weakrefs) { weaken( $_[0]->{'prev_sibling'}); } 
      ***      0                                  0   
5238                                                    }
5239                                                  
5240                                                  sub prev_sibling
5241          99                   99           526     { my $elt= shift;
5242  ***     99            66                  562       my $cond= shift || return $elt->{prev_sibling};
5243  ***     57            66                 1383       my $test_cond= ($cond_cache{$cond} ||= _install_cond( $cond));
5244          57                                186       my $sibling= $elt->{prev_sibling};
5245          57           100                  325       while( $sibling && !$test_cond->( $sibling) )
5246          16                                116             { $sibling= $sibling->{prev_sibling}; }
5247          57                                279       return $sibling;
5248                                                    }
5249                                                  
5250  ***      0                    0             0   sub set_next_sibling { $_[0]->{'next_sibling'}= $_[1]; }
5251                                                  
5252                                                  sub next_sibling
5253         490                  490          1069     { my $elt= shift;
5254  ***    490            66                 2954       my $cond= shift || return $elt->{next_sibling};
5255  ***    162            33                  564       my $test_cond= ($cond_cache{$cond} ||= _install_cond( $cond));
5256         162                                508       my $sibling= $elt->{next_sibling};
5257         162           100                  963       while( $sibling && !$test_cond->( $sibling) )
5258          68                                488             { $sibling= $sibling->{next_sibling}; }
5259         162                                840       return $sibling;
5260                                                    }
5261                                                  
5262                                                  # methods dealing with the class attribute, convenient if you work with xhtml
5263          45                   45           147   sub class     { my( $elt)= @_; return $elt->{'att'}->{'class'}; }
              45                                677   
5264          13                   13            52   sub set_class { my( $elt, $class)= @_; $elt->set_att( class => $class); }
              13                                 50   
5265                                                  
5266                                                  # adds a class to an element
5267                                                  sub add_to_class
5268           6                    6            24     { my( $elt, $new_class)= @_;
5269           6    100                          25       return $elt unless $new_class;
5270           5                                 14       my $class= $elt->class;
5271  ***      5     50                          30       my %class= $class ? map { $_ => 1 } split /\s+/, $class : ();
               8                                 43   
5272           5                                 19       $class{$new_class}= 1;
5273           5                                 54       $elt->set_class( join( ' ', sort keys %class));
5274                                                    }
5275                                                  
5276           2                    2             8   sub att_to_class      { my( $elt, $att)= @_; $elt->set_class( $elt->{'att'}->{$att}); }
               2                                 11   
5277           2                    2             9   sub add_att_to_class  { my( $elt, $att)= @_; $elt->add_to_class( $elt->{'att'}->{$att}); }
               2                                 11   
5278           1                    1             5   sub move_att_to_class { my( $elt, $att)= @_; $elt->add_to_class( $elt->{'att'}->{$att});
               1                                  6   
5279           1                                  5                           $elt->del_att( $att); 
5280                                                                        }
5281           2                    2             7   sub tag_to_class      { my( $elt)= @_; $elt->set_class( $elt->tag);    }
               2                                 10   
5282           2                    2             6   sub add_tag_to_class  { my( $elt)= @_; $elt->add_to_class( $elt->tag); }
               2                                  9   
5283           1                    1             5   sub set_tag_class     { my( $elt, $new_tag)= @_; $elt->add_tag_to_class; $elt->set_tag( $new_tag); }
               1                                  4   
               1                                  5   
5284                                                  
5285                                                  sub tag_to_span       
5286           2                    2            15     { my( $elt)= @_; 
5287  ***      2    100     66                    8       $elt->set_class( $elt->tag) unless( $elt->tag eq 'span' && $elt->class); # set class to span unless it would mean replacing it with span
5288           2                                  9       $elt->set_tag( 'span'); 
5289                                                    }
5290                                                  
5291                                                  sub tag_to_div    
5292           2                    2             8     { my( $elt)= @_; 
5293  ***      2    100     66                    7       $elt->set_class( $elt->tag) unless( $elt->tag eq 'div' && $elt->class); # set class to div unless it would mean replacing it with div
5294           2                                  9       $elt->set_tag( 'div');
5295                                                    }
5296                                                  
5297                                                  sub in_class          
5298          14                   14            58     { my( $elt, $class)= @_;
5299          14                                 44       my $elt_class= $elt->class;
5300  ***     14     50                          44       return unless( defined $elt_class);
5301          14    100                          41       return $elt->class=~ m{(?:^|\s)\Q$class\E(?:\s|$)} ? $elt : 0;
5302                                                    }
5303                                                  
5304                                                  
5305                                                  # get or set all attributes
5306                                                  # argument can be a hash or a hashref
5307                                                  sub set_atts 
5308       10439                10439         23115     { my $elt= shift;
5309       10439                              15058       my %atts;
5310       10439    100                       25117       tie %atts, 'Tie::IxHash' if( keep_atts_order());
5311       10439    100    100               108125       %atts= ( isa( $_[0] || '', 'HASH')) ? %{$_[0]} : @_;
              72                                400   
5312       10439                              46471       $elt->{att}= \%atts;
5313       10439    100                       35184       if( exists $atts{$ID}) { $elt->_set_id( $atts{$ID}); }
             507                               2144   
5314       10439                              26288       return $elt;
5315                                                    }
5316                                                  
5317        1684                 1684         13735   sub atts      { return $_[0]->{att};           }
5318         562                  562          1229   sub att_names { return sort keys %{$_[0]->{att}};   }
             562                               5748   
5319           3                    3            17   sub del_atts  { $_[0]->{att}={}; return $_[0]; }
               3                                 13   
5320                                                  
5321                                                  # get or set a single attribute (set works for several atts)
5322                                                  sub set_att 
5323          93                   93           285     { my $elt= shift;
5324                                                  
5325  ***     93     50     33                  817       if( $_[0] && ref( $_[0]) && !$_[1]) 
      ***                   33                        
5326  ***      0                                  0         { croak "improper call to set_att, usage is \$elt->set_att( att1 => 'val1', att2 => 'val2',...)"; }
5327                                                      
5328          93    100                         355       unless( $elt->{att})
5329           4                                 17         { $elt->{att}={};
5330           4    100                          14           tie %{$elt->{att}}, 'Tie::IxHash' if( keep_atts_order());
               2                                  4   
5331                                                        }
5332                                                  
5333          93                                284       while(@_) 
5334          93                                482         { my( $att, $val)= (shift, shift);
5335          93                                580           $elt->{att}->{$att}= $val;
5336          93    100                         411           if( $att eq $ID) { $elt->_set_id( $val); } 
              55                                187   
5337                                                        }
5338          93                                272       return $elt;
5339                                                    }
5340                                                   
5341         404                  404          4964   sub att { return $_[0]->{att}->{$_[1]}; }
5342                                                  sub del_att 
5343          44                   44           108     { my $elt= shift;
5344          44                                139       while( @_) { delete $elt->{'att'}->{shift()}; }
              44                                257   
5345          44                                177       return $elt;
5346                                                    }
5347                                                  
5348  ***      0                    0             0   sub att_exists { return exists  $_[0]->{att}->{$_[1]}; }
5349                                                  
5350                                                  # delete an attribute from all descendants of an element
5351                                                  sub strip_att
5352          13                   13            55     { my( $elt, $att)= @_;
5353          13                                 22       $_->del_att( $att) foreach ($elt->descendants_or_self( qq{*[\@$att]}));
              13                                 73   
5354          13                                 67       return $elt;
5355                                                    }
5356                                                  
5357                                                  sub change_att_name
5358           2                    2           333     { my( $elt, $old_name, $new_name)= @_;
5359           2                                 10       my $value= $elt->{'att'}->{$old_name};
5360           2    100                          10       return $elt unless( defined $value);
5361           1                                  5       $elt->del_att( $old_name)
5362                                                          ->set_att( $new_name => $value);
5363           1                                  3       return $elt;
5364                                                    }
5365                                                  
5366                                                  sub lc_attnames
5367  ***      0                    0             0     { my $elt= shift;
5368  ***      0                                  0       foreach my $att ($elt->att_names)
5369  ***      0      0                           0         { if( $att ne lc $att) { $elt->change_att_name( $att, lc $att); } }
      ***      0                                  0   
5370  ***      0                                  0       return $elt;
5371                                                    }
5372                                                  
5373          47                   47           227   sub set_twig_current { $_[0]->{twig_current}=1; }
5374           1                    1             5   sub del_twig_current { delete $_[0]->{twig_current}; }
5375                                                  
5376                                                  
5377                                                  # get or set the id attribute
5378                                                  sub set_id 
5379          51                   51           221     { my( $elt, $id)= @_;
5380          51    100                         302       $elt->del_id() if( exists $elt->{att}->{$ID});
5381          51                                239       $elt->set_att($ID, $id); 
5382          51                                156       $elt->_set_id( $id);
5383          51                                153       return $elt;
5384                                                    }
5385                                                  
5386                                                  # only set id, does not update the attribute value
5387                                                  sub _set_id
5388         614                  614          2278     { my( $elt, $id)= @_;
5389  ***    614            66                 2102       my $t= $elt->twig || $elt;
5390         614                               3169       $t->{twig_id_list}->{$id}= $elt;
5391         614    100                        1835       if( $XML::Twig::weakrefs) { weaken(  $t->{twig_id_list}->{$id}); }
             611                               3891   
5392         614                               1710       return $elt;
5393                                                    }
5394                                                  
5395         747                  747          6917   sub id { return $_[0]->{att}->{$ID}; }
5396                                                  
5397                                                  # methods used to add ids to elements that don't have one
5398                                                  BEGIN 
5399          92                   92           749   { my $id_nb   = "0001";
5400          92                                514     my $id_seed = "twig_id_";
5401                                                  
5402                                                    sub set_id_seed
5403           2                    2             5       { $id_seed= $_[1]; $id_nb=1; }
               2                                  6   
5404                                                  
5405                                                    sub add_id
5406          40                   40           105       { my $elt= shift; 
5407          40    100                         176         if( defined $elt->{'att'}->{$ID})
5408           1                                  5           { return $elt->{'att'}->{$ID}; }
5409                                                        else
5410  ***     39     50     33                  332           { $elt->set_id( $_[0] && ref( $_[0]) && isa( $_[0], 'CODE') ? $_[0]->( $elt) : $id_seed . $id_nb++); }
      ***                   33                        
5411                                                      }
5412                                                  }
5413                                                  
5414                                                  
5415                                                  
5416                                                  # delete the id attribute and remove the element from the id list
5417                                                  sub del_id 
5418          15                   15            52     { my $elt= shift;
5419  ***     15     50                          64       unless( exists $elt->{'att'}) { return $elt }; 
      ***      0                                  0   
5420          15    100                          75       unless( exists $elt->{'att'}->{$ID}) { return $elt }; 
               5                                 18   
5421          10                                 38       my $id= $elt->{'att'}->{$ID};
5422                                                  
5423          10                                 38       delete $elt->{'att'}->{$ID}; 
5424                                                  
5425  ***     10            66                   79       my $t= shift || $elt->twig;
5426          10    100                          42       unless( $t) { return $elt; }
               2                                  7   
5427  ***      8     50                          44       if( exists $t->{twig_id_list}->{$id}) { delete $t->{twig_id_list}->{$id}; }
               8                                 35   
5428                                                  
5429           8                                 21       return $elt;
5430                                                    }
5431                                                  
5432                                                  # return the list of children
5433                                                  sub children
5434         146                  146           388     { my $elt= shift;
5435         146                                231       my @children;
5436         146                                949       my $child= $elt->first_child( @_);
5437         146                                525       while( $child) 
5438         421                                877         { push @children, $child;
5439         421                               1347           $child= $child->next_sibling( @_);
5440                                                        } 
5441         146                                669       return @children;
5442                                                    }
5443                                                  
5444                                                  sub _children
5445        3993                 3993          9965     { my $elt= shift;
5446        3993                               8539       my @children=();
5447        3993                              11875       my $child= $elt->_first_child();
5448        3993                              14025       while( $child) 
5449        3973                               8404         { push @children, $child;
5450        3973                              17750           $child= $child->{next_sibling};
5451                                                        } 
5452        3993                              15602       return @children;
5453                                                    }
5454                                                  
5455                                                  sub children_copy
5456           1                    1             3     { my $elt= shift;
5457           1                                  2       my @children;
5458           1                                  6       my $child= $elt->first_child( @_);
5459           1                                  5       while( $child) 
5460           2                                  9         { push @children, $child->copy;
5461           2                                  7           $child= $child->next_sibling( @_);
5462                                                        } 
5463           1                                  6       return @children;
5464                                                    }
5465                                                  
5466                                                  
5467                                                  sub children_count
5468         768                  768          1715     { my $elt= shift;
5469         768                               1704       my $cond= shift;
5470         768                               1385       my $count=0;
5471         768                               2248       my $child= $elt->{first_child};
5472         768                               2164       while( $child)
5473        1128    100                        3344         { $count++ if( $child->passes( $cond)); 
5474        1128                               5189           $child= $child->{next_sibling};
5475                                                        }
5476         768                               2770       return $count;
5477                                                    }
5478                                                  
5479                                                  sub children_text
5480           3                    3           346     { my $elt= shift;
5481           4                                 15       return wantarray() ? map { $_->text} $elt->children( @_)
               2                                  7   
5482           3    100                          19                          : join( '', map { $_->text} $elt->children( @_) )
5483                                                                         ;
5484                                                    }
5485                                                  
5486                                                  sub children_trimmed_text
5487           2                    2             5     { my $elt= shift;
5488           2                                  7       return wantarray() ? map { $_->trimmed_text} $elt->children( @_)
               2                                  7   
5489           2    100                          13                          : join( '', map { $_->trimmed_text} $elt->children( @_) )
5490                                                                         ;
5491                                                    }
5492                                                  
5493                                                  sub all_children_are
5494           3                    3            15     { my( $parent, $cond)= @_;
5495           3                                 11       foreach my $child ($parent->_children)
5496           4    100                          14         { return 0 unless( $child->passes( $cond)); }
5497           1                                  7       return 1;
5498                                                    }
5499                                                  
5500                                                  
5501                                                  sub ancestors
5502        1017                 1017          2932     { my( $elt, $cond)= @_;
5503        1017                               1647       my @ancestors;
5504        1017                               3939       while( $elt->{parent})
5505        1992                               5145         { $elt= $elt->{parent};
5506        1992    100                        5457           push @ancestors, $elt if( $elt->passes( $cond));
5507                                                        }
5508        1017                               4615       return @ancestors;
5509                                                    }
5510                                                  
5511                                                  sub ancestors_or_self
5512          12                   12            42     { my( $elt, $cond)= @_;
5513          12                                 22       my @ancestors;
5514          12                                 40       while( $elt)
5515          38    100                         107         { push @ancestors, $elt if( $elt->passes( $cond));
5516          38                                181           $elt= $elt->{parent};
5517                                                        }
5518          12                                 56       return @ancestors;
5519                                                    }
5520                                                  
5521                                                  
5522                                                  sub _ancestors
5523           2                    2             9     { my( $elt, $include_self)= @_;
5524           2    100                          11       my @ancestors= $include_self ? ($elt) : ();
5525           2                                 12       while( $elt= $elt->{parent}) { push @ancestors, $elt; }
               4                                 21   
5526           2                                 11       return @ancestors;
5527                                                    }
5528                                                  
5529                                                  
5530                                                  sub inherit_att
5531        4843                 4843         12659     { my $elt= shift;
5532        4843                              11304       my $att= shift;
5533        4843                              14621       my %tags= map { ($_, 1) } @_;
               4                                 24   
5534                                                  
5535                                                      do 
5536        4843    100    100                 7867         { if(   (defined $elt->{'att'}->{$att})
            6087           100                53331   
5537                                                             && ( !%tags || $tags{$XML::Twig::index2gi[$elt->{'gi'}]})
5538                                                            )
5539           8                                 81             { return $elt->{'att'}->{$att}; }
5540                                                        } while( $elt= $elt->{parent});
5541        4835                              42981       return undef;
5542                                                    }
5543                                                  
5544                                                  sub _inherit_att_through_cut
5545          64                   64           144     { my $elt= shift;
5546          64                                149       my $att= shift;
5547          64                                259       my %tags= map { ($_, 1) } @_;
      ***      0                                  0   
5548                                                  
5549                                                      do 
5550  ***     64    100     66                  101         { if(   (defined $elt->{'att'}->{$att})
      ***    121            33                 1219   
      ***                   66                        
5551                                                             && ( !%tags || $tags{$XML::Twig::index2gi[$elt->{'gi'}]})
5552                                                            )
5553          40                                343             { return $elt->{'att'}->{$att}; }
5554                                                        } while( $elt= $elt->{parent} || $elt->former_parent);
5555          24                                223       return undef;
5556                                                    }
5557                                                  
5558                                                  
5559                                                  sub current_ns_prefixes
5560           3                    3            12     { my $elt= shift;
5561           3                                  5       my %prefix;
5562           3    100                          12       $prefix{''}=1 if( $elt->namespace( ''));
5563           3                                 14       while( $elt)
5564           6                                 38         { my @ns= grep { !m{^xml} } map { m{^([^:]+):} } ($XML::Twig::index2gi[$elt->{'gi'}], $elt->att_names);
               3                                128   
              11                                 48   
5565           6                                 13           $prefix{$_}=1 foreach (@ns);
               6                                 25   
5566           6                                 34           $elt= $elt->{parent};
5567                                                        }
5568                                                  
5569           3                                 33       return sort keys %prefix;
5570                                                    }
5571                                                  
5572                                                  # kinda counter-intuitive actually:
5573                                                  # the next element is found by looking for the next open tag after from the
5574                                                  # current one, which is the first child, if it exists, or the next sibling
5575                                                  # or the first next sibling of an ancestor
5576                                                  # optional arguments are: 
5577                                                  #   - $subtree_root: a reference to an element, when the next element is not 
5578                                                  #                    within $subtree_root anymore then next_elt returns undef
5579                                                  #   - $cond: a condition, next_elt returns the next element matching the condition
5580                                                                   
5581                                                  sub next_elt
5582         412                  412          1377     { my $elt= shift;
5583         412                                774       my $subtree_root= 0;
5584  ***    412    100     66                 5493       $subtree_root= shift if( defined $_[0] and ref( $_[0]) && isa( $_[0], 'XML::Twig::Elt'));
                           100                        
5585         412                               1079       my $cond= shift;
5586         412                                615       my $next_elt;
5587                                                  
5588         412                                559       my $ind;                                                              # optimization
5589         412                                587       my $test_cond;
5590         412    100                        1023       if( $cond)                                                            # optimization
5591         395    100                        1631         { unless( defined( $ind= $XML::Twig::gi2index{$cond}) )             # optimization
5592  ***    290            66                 1217             { $test_cond= ($cond_cache{$cond} ||= _install_cond( $cond)); } # optimization
5593                                                        }                                                                   # optimization
5594                                                      
5595                                                      do
5596  ***    412    100     66                  805         { if( $next_elt= $elt->{first_child})
             599    100    100                 3428   
                           100                        
                           100                        
                           100                        
5597                                                            { # simplest case: the elt has a child
5598                                                            }
5599                                                           elsif( $next_elt= $elt->{next_sibling}) 
5600                                                            { # no child but a next sibling (just check we stay within the subtree)
5601                                                            
5602                                                              # case where elt is subtree_root, is empty and has a sibling
5603          81    100    100                  545               return undef if( $subtree_root && ($elt == $subtree_root));
5604                                                              
5605                                                            }
5606                                                          else
5607                                                            { # case where the element has no child and no next sibling:
5608                                                              # get the first next sibling of an ancestor, checking subtree_root 
5609                                                            
5610                                                              # case where elt is subtree_root, is empty and has no sibling
5611         166    100    100                 1105               return undef if( $subtree_root && ($elt == $subtree_root));
5612                                                               
5613         164                                505               $next_elt= $elt->{parent};
5614                                                  
5615         164                                711               until( $next_elt->{next_sibling})
5616         157    100    100                 1376                 { return undef if( $subtree_root && ($subtree_root == $next_elt));
5617  ***     69            66                  443                   $next_elt= $next_elt->{parent} || return undef;
5618                                                                }
5619          65    100    100                  590               return undef if( $subtree_root && ($subtree_root == $next_elt)); 
5620          61                                201               $next_elt= $next_elt->{next_sibling};   
5621                                                            }  
5622         491                               9295         $elt= $next_elt;                   # just in case we need to loop
5623                                                      } until(    ! defined $elt 
5624                                                               || ! defined $cond 
5625                                                           || (defined $ind       && ($elt->{gi} eq $ind))   # optimization
5626                                                           || (defined $test_cond && ($test_cond->( $elt)))
5627                                                                 );
5628                                                      
5629         304                               1522         return $elt;
5630                                                        }
5631                                                  
5632                                                  # return the next_elt within the element
5633                                                  # just call next_elt with the element as first and second argument
5634          20                   20            83   sub first_descendant { return $_[0]->next_elt( @_); }
5635                                                  
5636                                                  # get the last descendant, # then return the element found or call prev_elt with the condition
5637                                                  sub last_descendant
5638          38                   38           142     { my( $elt, $cond)= @_;
5639          38                                109       my $last_descendant= $elt->_last_descendant;
5640          38    100    100                  244       if( !$cond || $last_descendant->matches( $cond))
5641          23                                 81         { return $last_descendant; }
5642                                                      else
5643          15                                 58         { return $last_descendant->prev_elt( $elt, $cond); }
5644                                                    }
5645                                                  
5646                                                  # no argument allowed here, just go down the last_child recursively
5647                                                  sub _last_descendant
5648          41                   41           100     { my $elt= shift;
5649          41                                196       while( my $child= $elt->{last_child}) { $elt= $child; }
              71                                360   
5650          41                                115       return $elt;
5651                                                    }
5652                                                  
5653                                                  # counter-intuitive too:
5654                                                  # the previous element is found by looking
5655                                                  # for the first open tag backwards from the current one
5656                                                  # it's the last descendant of the previous sibling 
5657                                                  # if it exists, otherwise it's simply the parent
5658                                                  sub prev_elt
5659          37                   37           101     { my $elt= shift;
5660          37                                 67       my $subtree_root= 0;
5661  ***     37    100     66                  492       if( defined $_[0] and (ref( $_[0]) && isa( $_[0], 'XML::Twig::Elt')))
                           100                        
5662          17                                 44         { $subtree_root= shift ;
5663          17    100                          64           return undef if( $elt == $subtree_root);
5664                                                        }
5665          35                                 99       my $cond= shift;
5666                                                      # get prev elt
5667          35                                 55       my $prev_elt;
5668                                                      do
5669          35    100                          58         { return undef if( $elt == $subtree_root);
             105                                397   
5670         102    100                         398           if( $prev_elt= $elt->{prev_sibling})
5671          37                                155             { while( $prev_elt->{last_child})
5672          22                                132                 { $prev_elt= $prev_elt->{last_child}; }
5673                                                            }
5674                                                          else
5675  ***     65            66                  288             { $prev_elt= $elt->{parent} || return undef; }
5676          95                                411           $elt= $prev_elt;     # in case we need to loop 
5677                                                        } until( $elt->passes( $cond));
5678                                                  
5679          25                                135       return $elt;
5680                                                    }
5681                                                  
5682                                                  sub _following_elt
5683           7                    7            20     { my( $elt)= @_;
5684           7           100                   69       while( $elt && !$elt->{next_sibling})
5685          12                                109         { $elt= $elt->{parent}; }
5686           7    100                          48       return $elt ? $elt->{next_sibling} : undef;
5687                                                    }
5688                                                  
5689                                                  sub following_elt
5690           7                    7            24     { my( $elt, $cond)= @_;
5691  ***      7            66                   21       $elt= $elt->_following_elt || return undef;
5692  ***      6    100     66                   42       return $elt if( !$cond || $elt->matches( $cond));
5693           2                                  9       return $elt->next_elt( $cond);
5694                                                    }
5695                                                  
5696                                                  sub following_elts
5697           6                    6            24     { my( $elt, $cond)= @_;
5698           6    100                          26       if( !$cond) { undef $cond; }
               4                                  9   
5699           6                                 17       my $following= $elt->following_elt( $cond);
5700           6    100                          16       if( $following)
5701           5                                 15         { my @followings= $following;
5702           5                                 18           while( $following= $following->next_elt( $cond))
5703           6                                 25             { push @followings, $following; }
5704           5                                 26           return( @followings);
5705                                                        }
5706                                                      else
5707           1                                  5         { return (); }
5708                                                    }
5709                                                  
5710                                                  sub _preceding_elt
5711           7                    7            17     { my( $elt)= @_;
5712           7           100                   66       while( $elt && !$elt->{prev_sibling})
5713          11                                 82         { $elt= $elt->{parent}; }
5714           7    100                          52       return $elt ? $elt->{prev_sibling}->_last_descendant : undef;
5715                                                    }
5716                                                  
5717                                                  sub preceding_elt
5718           7                    7            21     { my( $elt, $cond)= @_;
5719  ***      7            66                   23       $elt= $elt->_preceding_elt || return undef;
5720  ***      3    100     66                   71       return $elt if( !$cond || $elt->matches( $cond));
5721           2                                  9       return $elt->prev_elt( $cond);
5722                                                    }
5723                                                  
5724                                                  sub preceding_elts
5725           7                    7            29     { my( $elt, $cond)= @_;
5726           7    100                          26       if( !$cond) { undef $cond; }
               4                                 10   
5727           7                                 25       my $preceding= $elt->preceding_elt( $cond);
5728           7    100                          18       if( $preceding)
5729           3                                  8         { my @precedings= $preceding;
5730           3                                 11           while( $preceding= $preceding->prev_elt( $cond))
5731           4                                 21             { push @precedings, $preceding; }
5732           3                                 18           return( @precedings);
5733                                                        }
5734                                                      else
5735           4                                 18         { return (); }
5736                                                    }
5737                                                  
5738                                                  # used in get_xpath
5739                                                  sub _self
5740           6                    6            23     { my( $elt, $cond)= @_;
5741           6    100                          33       return $cond ? $elt->matches( $cond) : $elt;
5742                                                    }
5743                                                  
5744                                                  sub next_n_elt
5745           7                    7            22     { my $elt= shift;
5746  ***      7            66                   50       my $offset= shift || return undef;
5747           5                                 19       foreach (1..$offset)
5748  ***      7            66                   30         { $elt= $elt->next_elt( @_) || return undef; }
5749           3                                 16       return $elt;
5750                                                    }
5751                                                  
5752                                                  # checks whether $elt is included in $ancestor, returns 1 in that case
5753                                                  sub in
5754        2475                 2475          7714     { my ($elt, $ancestor)= @_;
5755  ***   2475    100     66                29351       if( ref( $ancestor) && isa( $ancestor, 'XML::Twig::Elt'))
5756                                                        { # element
5757        2473    100                       12494           while( $elt= $elt->{parent}) { return $elt if( $elt ==  $ancestor); } 
            2688                              14950   
5758                                                        }
5759                                                      else
5760                                                        { # condition
5761           2    100                          12           while( $elt= $elt->{parent}) { return $elt if( $elt->matches( $ancestor)); } 
               2                                  8   
5762                                                        }
5763        2110                               9760       return 0;           
5764                                                    }
5765                                                  
5766                                                  sub first_child_text  
5767          13                   13            41     { my $elt= shift;
5768          13    100                          49       my $dest=$elt->first_child(@_) or return '';
5769          11                                 55       return $dest->text;
5770                                                    }
5771                                                  
5772                                                  sub fields  
5773  ***      0                    0             0     { my $elt= shift;
5774  ***      0                                  0       return map { $elt->field( $_) } @_;
      ***      0                                  0   
5775                                                    }
5776                                                  
5777                                                  sub first_child_trimmed_text  
5778           4                    4            16     { my $elt= shift;
5779           4    100                          16       my $dest=$elt->first_child(@_) or return '';
5780           1                                  4       return $dest->trimmed_text;
5781                                                    }
5782                                                    
5783                                                  sub first_child_matches
5784           3                    3            11     { my $elt= shift;
5785           3    100                          32       my $dest= $elt->{first_child} or return undef;
5786           2                                 10       return $dest->passes( @_);
5787                                                    }
5788                                                    
5789                                                  sub last_child_text  
5790           3                    3            17     { my $elt= shift;
5791           3    100                          12       my $dest=$elt->last_child(@_) or return '';
5792           2                                  8       return $dest->text;
5793                                                    }
5794                                                    
5795                                                  sub last_child_trimmed_text  
5796           2                    2             7     { my $elt= shift;
5797           2    100                           7       my $dest=$elt->last_child(@_) or return '';
5798           1                                  5       return $dest->trimmed_text;
5799                                                    }
5800                                                    
5801                                                  sub last_child_matches
5802           6                    6            35     { my $elt= shift;
5803           6    100                          38       my $dest= $elt->{last_child} or return undef;
5804           5                                 22       return $dest->passes( @_);
5805                                                    }
5806                                                    
5807                                                  sub child_text
5808           2                    2             8     { my $elt= shift;
5809           2    100                          10       my $dest=$elt->child(@_) or return '';
5810           1                                  6       return $dest->text;
5811                                                    }
5812                                                    
5813                                                  sub child_trimmed_text
5814           2                    2           251     { my $elt= shift;
5815           2    100                          10       my $dest=$elt->child(@_) or return '';
5816           1                                  5       return $dest->trimmed_text;
5817                                                    }
5818                                                    
5819                                                  sub child_matches
5820           2                    2            13     { my $elt= shift;
5821           2                                  6       my $nb= shift;
5822           2    100                           9       my $dest= $elt->child( $nb) or return undef;
5823           1                                  6       return $dest->passes( @_);
5824                                                    }
5825                                                  
5826                                                  sub prev_sibling_text  
5827           2                    2            11     { my $elt= shift;
5828           2    100                          10       my $dest=$elt->_prev_sibling(@_) or return '';
5829           1                                  6       return $dest->text;
5830                                                    }
5831                                                    
5832                                                  sub prev_sibling_trimmed_text  
5833           2                    2             8     { my $elt= shift;
5834           2    100                           7       my $dest=$elt->_prev_sibling(@_) or return '';
5835           1                                  4       return $dest->trimmed_text;
5836                                                    }
5837                                                    
5838                                                  sub prev_sibling_matches
5839           3                    3            10     { my $elt= shift;
5840           3    100                          22       my $dest= $elt->{prev_sibling} or return undef;
5841           2                                  8       return $dest->passes( @_);
5842                                                    }
5843                                                    
5844                                                  sub next_sibling_text  
5845           3                    3             9     { my $elt= shift;
5846           3    100                          10       my $dest=$elt->next_sibling(@_) or return '';
5847           2                                 10       return $dest->text;
5848                                                    }
5849                                                    
5850                                                  sub next_sibling_trimmed_text  
5851           2                    2             7     { my $elt= shift;
5852           2    100                           8       my $dest=$elt->next_sibling(@_) or return '';
5853           1                                  5       return $dest->trimmed_text;
5854                                                    }
5855                                                    
5856                                                  sub next_sibling_matches
5857           2                    2             8     { my $elt= shift;
5858           2    100                          16       my $dest= $elt->{next_sibling} or return undef;
5859           1                                  5       return $dest->passes( @_);
5860                                                    }
5861                                                    
5862                                                  sub prev_elt_text  
5863           2                    2             9     { my $elt= shift;
5864           2    100                          10       my $dest=$elt->prev_elt(@_) or return '';
5865           1                                  5       return $dest->text;
5866                                                    }
5867                                                    
5868                                                  sub prev_elt_trimmed_text  
5869           2                    2             8     { my $elt= shift;
5870           2    100                           8       my $dest=$elt->prev_elt(@_) or return '';
5871           1                                  3       return $dest->trimmed_text;
5872                                                    }
5873                                                    
5874                                                  sub prev_elt_matches
5875           3                    3             9     { my $elt= shift;
5876           3    100                          14       my $dest= $elt->prev_elt or return undef;
5877           2                                  8       return $dest->passes( @_);
5878                                                    }
5879                                                    
5880                                                  sub next_elt_text  
5881           2                    2             7     { my $elt= shift;
5882           2    100                           8       my $dest=$elt->next_elt(@_) or return '';
5883           1                                  5       return $dest->text;
5884                                                    }
5885                                                    
5886                                                  sub next_elt_trimmed_text  
5887           2                    2             7     { my $elt= shift;
5888           2    100                          10       my $dest=$elt->next_elt(@_) or return '';
5889           1                                  5       return $dest->trimmed_text;
5890                                                    }
5891                                                    
5892                                                  sub next_elt_matches
5893           3                    3            11     { my $elt= shift;
5894           3    100                          13       my $dest= $elt->next_elt or return undef;
5895           2                                 11       return $dest->passes( @_);
5896                                                    }
5897                                                    
5898                                                  sub parent_text  
5899           4                    4            14     { my $elt= shift;
5900           4    100                          15       my $dest=$elt->parent(@_) or return '';
5901           3                                 12       return $dest->text;
5902                                                    }
5903                                                    
5904                                                  sub parent_trimmed_text  
5905           2                    2             8     { my $elt= shift;
5906           2    100                           7       my $dest=$elt->parent(@_) or return '';
5907           1                                  4       return $dest->trimmed_text;
5908                                                    }
5909                                                    
5910                                                  sub parent_matches
5911           8                    8            21     { my $elt= shift;
5912           8    100                          48       my $dest= $elt->{parent} or return undef;
5913           6                                 21       return $dest->passes( @_);
5914                                                    }
5915                                                   
5916                                                  sub is_first_child
5917           9                    9            39     { my $elt= shift;
5918           9    100                          55       my $parent= $elt->{parent} or return 0;
5919           8    100                          32       my $first_child= $parent->first_child( @_) or return 0;
5920           7    100                          47       return ($first_child == $elt) ? $elt : 0;
5921                                                    }
5922                                                   
5923                                                  sub is_last_child
5924           9                    9            29     { my $elt= shift;
5925           9    100                          51       my $parent= $elt->{parent} or return 0;
5926           8    100                          29       my $last_child= $parent->last_child( @_) or return 0;
5927           7    100                          50       return ($last_child == $elt) ? $elt : 0;
5928                                                    }
5929                                                  
5930                                                  # returns the depth level of the element
5931                                                  # if 2 parameter are used then counts the 2cd element name in the
5932                                                  # ancestors list
5933                                                  sub level
5934         349                  349          1047     { my( $elt, $cond)= @_;
5935         349                                669       my $level=0;
5936  ***    349            50                 1222       my $name=shift || '';
5937         349    100    100                 1616       while( $elt= $elt->{parent}) { $level++ if( !$cond || $elt->matches( $cond)); }
             412                               2891   
5938         349                               1183       return $level;           
5939                                                    }
5940                                                  
5941                                                  # checks whether $elt has an ancestor that satisfies $cond, returns the ancestor
5942                                                  sub in_context
5943          18                   18            86     { my ($elt, $cond, $level)= @_;
5944          18    100                          78       $level= -1 unless( $level) ;  # $level-- will never hit 0
5945                                                  
5946          18                                 54       while( $level)
5947          32    100                         170         { $elt= $elt->{parent} or return 0;
5948          24    100                          82           if( $elt->matches( $cond)) { return $elt; }
               8                                179   
5949          16                                258           $level--;
5950                                                        }
5951           2                                 12       return 0;
5952                                                    }
5953                                                  
5954                                                  sub _descendants
5955          43                   43          3438     { my( $subtree_root, $include_self)= @_;
5956          43    100                         162       my @descendants= $include_self ? ($subtree_root) : ();
5957                                                  
5958          43                                 79       my $elt= $subtree_root; 
5959          43                                 60       my $next_elt;   
5960                                                   
5961          43                                 66       MAIN: while( 1)  
5962         121    100                         590         { if( $next_elt= $elt->{first_child})
                    100                               
5963                                                            { # simplest case: the elt has a child
5964                                                            }
5965                                                          elsif( $next_elt= $elt->{next_sibling}) 
5966                                                            { # no child but a next sibling (just check we stay within the subtree)
5967                                                            
5968                                                              # case where elt is subtree_root, is empty and has a sibling
5969           7    100                          26               last MAIN if( $elt == $subtree_root);
5970                                                            }
5971                                                          else
5972                                                            { # case where the element has no child and no next sibling:
5973                                                              # get the first next sibling of an ancestor, checking subtree_root 
5974                                                                  
5975                                                              # case where elt is subtree_root, is empty and has no sibling
5976          55    100                         176               last MAIN if( $elt == $subtree_root);
5977                                                                 
5978                                                              # backtrack until we find a parent with a next sibling
5979  ***     40            33                  148               $next_elt= $elt->{parent} || last;
5980          40                                147               until( $next_elt->{next_sibling})
5981          37    100                         109                 { last MAIN if( $subtree_root == $next_elt);
5982  ***     19            33                  104                   $next_elt= $next_elt->{parent} || last MAIN;
5983                                                                }
5984          22    100                          57               last MAIN if( $subtree_root == $next_elt); 
5985          16                                 47               $next_elt= $next_elt->{next_sibling};   
5986                                                            }  
5987  ***     78            33                  319           $elt= $next_elt || last MAIN;
5988          78                                182           push @descendants, $elt;
5989                                                        }
5990          43                                226       return @descendants;
5991                                                    }
5992                                                  
5993                                                  
5994                                                  sub descendants
5995         203                  203           800     { my( $subtree_root, $cond)= @_;
5996         203                                533       my @descendants=(); 
5997         203                                363       my $elt= $subtree_root;
5998                                                      
5999                                                      # this branch is pure optimization for speed: if $cond is a gi replace it
6000                                                      # by the index of the gi and loop here 
6001                                                      # start optimization
6002         203                                285       my $ind;
6003         203    100    100                 1664       if( !$cond || ( defined ( $ind= $XML::Twig::gi2index{$cond})) )
6004                                                        {
6005         114                                165           my $next_elt;
6006                                                  
6007         114                                175           while( 1)  
6008        1450    100                        7113             { if( $next_elt= $elt->{first_child})
                    100                               
6009                                                                  { # simplest case: the elt has a child
6010                                                                  }
6011                                                               elsif( $next_elt= $elt->{next_sibling}) 
6012                                                                { # no child but a next sibling (just check we stay within the subtree)
6013                                                             
6014                                                                  # case where elt is subtree_root, is empty and has a sibling
6015  ***    118     50     33                  947                   last if( $subtree_root && ($elt == $subtree_root));
6016                                                                }
6017                                                              else
6018                                                                { # case where the element has no child and no next sibling:
6019                                                                  # get the first next sibling of an ancestor, checking subtree_root 
6020                                                                  
6021                                                                  # case where elt is subtree_root, is empty and has no sibling
6022  ***    528    100     66                 3424                   last if( $subtree_root && ($elt == $subtree_root));
6023                                                                 
6024                                                                  # backtrack until we find a parent with a next sibling
6025  ***    525            33                 2136                   $next_elt= $elt->{parent} || last undef;
6026         525                               1920                   until( $next_elt->{next_sibling})
6027  ***    390    100     66                 2519                     { last if( $subtree_root && ($subtree_root == $next_elt));
6028  ***    279            33                 1678                       $next_elt= $next_elt->{parent} || last;
6029                                                                    }
6030  ***    525    100     66                 3271                   last if( $subtree_root && ($subtree_root == $next_elt)); 
6031         414                               1286                   $next_elt= $next_elt->{next_sibling};   
6032                                                                }  
6033  ***   1336            33                 3699               $elt= $next_elt || last;
6034        1336    100    100                 7926               push @descendants, $elt if( !$cond || ($elt->{gi} eq $ind));
6035                                                            }
6036                                                        }
6037                                                      else
6038                                                      # end optimization
6039                                                        { # branch for a complex condition: use the regular (slow but simple) way
6040          89                                380           while( $elt= $elt->next_elt( $subtree_root, $cond))
6041         171                                873             { push @descendants, $elt; }
6042                                                        }
6043         203                               1180       return @descendants;
6044                                                    }
6045                                                  
6046                                                   
6047                                                  sub descendants_or_self
6048          43                   43           178     { my( $elt, $cond)= @_;
6049          43    100                         191       my @descendants= $elt->passes( $cond) ? ($elt) : (); 
6050          43                                312       push @descendants, $elt->descendants( $cond);
6051          43                                250       return @descendants;
6052                                                    }
6053                                                    
6054                                                  sub sibling
6055           9                    9            34     { my $elt= shift;
6056           9                                 21       my $nb= shift;
6057           9    100                          38       if( $nb > 0)
                    100                               
6058           4                                 33         { foreach( 1..$nb)
6059           4    100                          19             { $elt= $elt->next_sibling( @_) or return undef; }
6060                                                        }
6061                                                      elsif( $nb < 0)
6062           3                                 14         { foreach( 1..(-$nb))
6063           3    100                          11             { $elt= $elt->prev_sibling( @_) or return undef; }
6064                                                        }
6065                                                      else # $nb == 0
6066           2                                  8         { return $elt->passes( $_[0]); }
6067           4                                 17       return $elt;
6068                                                    }
6069                                                  
6070                                                  sub sibling_text
6071           3                    3            12     { my $elt= sibling( @_);
6072           3    100                          17       return $elt ? $elt->text : undef;
6073                                                    }
6074                                                  
6075                                                  
6076                                                  sub child
6077          43                   43           110     { my $elt= shift;
6078          43                                179       my $nb= shift;
6079          43    100                         133       if( $nb >= 0)
6080          27    100                         103         { $elt= $elt->first_child( @_) or return undef;
6081          20                                 82           foreach( 1..$nb)
6082          20    100                          73             { $elt= $elt->next_sibling( @_) or return undef; }
6083                                                        }
6084                                                      else
6085          16    100                          56         { $elt= $elt->last_child( @_) or return undef;
6086          13                                 54           foreach( 2..(-$nb))
6087          16    100                          54             { $elt= $elt->prev_sibling( @_) or return undef; }
6088                                                        }
6089          31                                144       return $elt;
6090                                                    }
6091                                                  
6092                                                  sub prev_siblings
6093          24                   24           122     { my $elt= shift;
6094          24                                 50       my @siblings=();
6095          24                                 95       while( $elt= $elt->prev_sibling( @_))
6096          12                                 66         { unshift @siblings, $elt; }
6097          24                                 92       return @siblings;
6098                                                    }
6099                                                  
6100                                                  sub pos
6101          17                   17           107     { my $elt= shift;
6102          17    100    100                  103       return 0 if ($_[0] && !$elt->matches( @_));
6103           9                                 19       my $pos=1;
6104           9                                 35       $pos++ while( $elt= $elt->prev_sibling( @_));
6105           9                                 28       return $pos;
6106                                                    }
6107                                                  
6108                                                  
6109                                                  sub next_siblings
6110           6                    6            17     { my $elt= shift;
6111           6                                 14       my @siblings=();
6112           6                                 21       while( $elt= $elt->next_sibling( @_))
6113           8                                 38         { push @siblings, $elt; }
6114           6                                 30       return @siblings;
6115                                                    }
6116                                                  
6117                                                  
6118                                                  # used by get_xpath: parses the xpath expression and generates a sub that performs the
6119                                                  # search
6120                                                  { my %axis2method;
6121          92                   92          2728     BEGIN { %axis2method= ( child               => 'children',
6122                                                                            descendant          => 'descendants',
6123                                                                           'descendant-or-self' => 'descendants_or_self',
6124                                                                            parent              => 'parent_is',
6125                                                                            ancestor            => 'ancestors',
6126                                                                           'ancestor-or-self'   => 'ancestors_or_self',
6127                                                                           'following-sibling'  => 'next_siblings',
6128                                                                           'preceding-sibling'  => 'prev_siblings',
6129                                                                            following           => 'following_elts',
6130                                                                            preceding           => 'preceding_elts',
6131                                                                            self                => '_self',
6132                                                                          );
6133                                                          }
6134                                                  
6135                                                    sub _install_xpath
6136         167                  167           756       { my( $xpath_exp, $type)= @_;
6137         167                                384         my $original_exp= $xpath_exp;
6138         167                                428         my $sub= 'my $elt= shift; my @results;';
6139                                                        
6140                                                        # grab the root if expression starts with a /
6141         167    100                         860         if( $xpath_exp=~ s{^/}{})
                    100                               
6142         153                                388           { $sub .= '@results= ($elt->twig) || croak "cannot use an XPath query starting with a / on a node not attached to a whole twig";'; }
6143                                                        elsif( $xpath_exp=~ s{^\./}{})
6144           6                                 16           { $sub .= '@results= ($elt);'; }
6145                                                        else
6146           8                                 20           { $sub .= '@results= ($elt);'; }
6147                                                    
6148                                                   
6149                                                       #warn "xpath_exp= '$xpath_exp'\n";
6150         167           100                 5305         while( $xpath_exp &&
6151                                                               $xpath_exp=~s{^\s*(/?)                            
6152                                                                              # the xxx=~/regexp/ is a pain as it includes /  
6153                                                                              (\s*(?:(?:($REG_AXIS)::)?(\*|$REG_NAME|\.\.|\.)\s*)?($REG_PREDICATE_ALT*)
6154                                                                              )
6155                                                                              (/|$)}{}xo)
6156                                                    
6157         290                               2489           { my( $wildcard, $sub_exp, $axis, $gi, $predicates)= ($1, $2, $3, $4, $5);
6158                                                            
6159                                                            # grab a parent
6160         290    100                        1360             if( $sub_exp eq '..')
                    100                               
6161  ***      4     50                          15               { _croak_and_doublecheck_xpath( $original_exp, "error in xpath expression $original_exp") if( $wildcard);
6162           4                                 58                 $sub .= '@results= map { $_->{parent}} @results;';
6163                                                              }
6164                                                            # test the element itself
6165                                                            elsif( $sub_exp=~ m{^\.(.*)$}s)
6166           1                                 12               { $sub .= "\@results= grep { \$_->matches( q{$1}) } \@results;" }
6167                                                                # grab children
6168                                                            else       
6169                                                              { 
6170         285    100                         866                 if( !$axis)             
6171         252    100                         793                   { $axis= $wildcard ? 'descendant' : 'child'; }
6172         285    100    100                 2197                 if( !$gi or $gi eq '*') { $gi=''; }
              81                                195   
6173         285                                430                 my $function;
6174                                                    
6175                                                                # "special" predicates, that return just one element
6176         285    100    100                 2899                 if( $predicates && ($predicates =~ m{^\s*\[\s*((-\s*)?\d+)\s*\]\s*$}))
                    100    100                        
6177                                                                  { # [<nb>]
6178          30                                120                     my $offset= $1;
6179          30    100                         120                     $offset-- if( $offset > 0);
6180  ***     30     50                         240                     $function=  $axis eq 'descendant' ? "next_n_elt( $offset, '$gi')" 
      ***            50                               
6181                                                                             :  $axis eq 'child'      ? "child( $offset, '$gi')"
6182                                                                             :                          _croak_and_doublecheck_xpath( $original_exp, "error [$1] not supported along axis '$axis'")
6183                                                                             ;
6184          30                                410                     $sub .= "\@results= grep { \$_ } map { \$_->$function } \@results;"
6185                                                                  }
6186                                                                elsif( $predicates && ($predicates =~ m{^\s*\[\s*last\s*\(\s*\)\s*\]\s*$}) )
6187                                                                  { # last()
6188  ***      3     50                          10                     _croak_and_doublecheck_xpath( $original_exp, "error in xpath expression $original_exp, usage of // and last() not supported") if( $wildcard);
6189           3                                 31                      $sub .= "\@results= map { \$_->last_child( '$gi') } \@results;";
6190                                                                  }
6191                                                                else
6192                                                                  { # follow the axis
6193                                                                    #warn "axis: '$axis' - method: '$axis2method{$axis}' - gi: '$gi'\n";
6194                                                  
6195         252                               1363                     my $follow_axis= " \$_->$axis2method{$axis}( '$gi')";
6196         252                                503                     my $step= $follow_axis;
6197                                                                    
6198                                                                    # now filter using the predicate
6199         252                               2306                     while( $predicates=~ s{^\s*($REG_PREDICATE_ALT)\s*}{}o)
6200         131                                443                       { my $pred= $1;
6201         131                                447                         $pred=~ s{^\s*\[\s*}{};
6202         131                                464                         $pred=~ s{\s*\]\s*$}{};
6203         131                                260                         my $test="";
6204         131                                186                         my $pos;
6205         131    100                         554                         if( $pred=~ m{^(-?\s*\d+)$})
6206          18                                 50                           { my $pos= $1;
6207          18    100                         210                             if( $step=~ m{^\s*grep(.*) (\$_->\w+\(\s*'[^']*'\s*\))})
6208          16                                247                               { $step= "XML::Twig::_first_n $1 $pos, $2"; }
6209                                                                            else
6210  ***      2     50                          10                               { if( $pos > 0) { $pos--; }
               2                                  5   
6211           2                                 28                                 $step= "($step)[$pos]"; 
6212                                                                              }
6213                                                                            #warn "number predicate '$pos' - generated step '$step'\n";
6214                                                                          }
6215                                                                        else
6216         113                                209                           { my $syntax_error=0;
6217                                                                            do
6218         113    100    100                  177                               { if( $pred =~ s{^string\(\s*\)\s*=\s*($REG_STRING)\s*}{}o)  # string()="string" pred
             153    100                        4359   
                    100                               
                    100                               
                    100                               
                    100                               
                    100                               
                    100                               
6219           6                                 75                                   { $test .= "\$_->text eq $1"; }
6220                                                                               elsif( $pred =~ s{^string\(\s*\)\s*($REG_MATCH)\s*($REG_REGEXP)\s*}{}o)  # string()=~/regex/ pred
6221           8                                 37                                   { my( $match, $regexp)= ($1, $2);
6222           8                                 97                                     $test .= "\$_->text $match $regexp"; 
6223                                                                                  }
6224                                                                               elsif( $pred=~ s{^@($REG_NAME)\s*($REG_OP)\s*($REG_STRING|$REG_NUMBER)}{}o)  # @att="val" pred
6225          82                                395                                   { my( $att, $oper, $val)= ($1, _op( $2), $3);
6226          82                               1244                                     $test .= qq{((defined \$_->{'att'}->{"$att"})  && (\$_->{'att'}->{"$att"} $oper $val))};
6227                                                                                  }
6228                                                                               elsif( $pred =~ s{^@($REG_NAME)\s*($REG_MATCH)\s*($REG_REGEXP)\s*}{}o)  # @att=~/regex/ pred XXX
6229          12                                 68                                   { my( $att, $match, $regexp)= ($1, $2, $3);
6230          12                                173                                     $test .= qq{((defined \$_->{'att'}->{"$att"})  && (\$_->{'att'}->{"$att"} $match $regexp))};; 
6231                                                                                  }
6232                                                                               elsif( $pred=~ s{^@($REG_NAME)\s*}{}o)                      # @att pred
6233          17                                202                                   { $test .= qq{(defined \$_->{'att'}->{"$1"})}; }
6234                                                                               elsif( $pred=~ s{^\s*(?:not|!)\s*@($REG_NAME)\s*}{}o)       # not @att pred
6235           6                                 73                                   { $test .= qq{((\$_->is_elt) && (not defined \$_->{'att'}->{"$1"}))}; }
6236                                                                                elsif( $pred=~ s{^\s*([()])}{})                            # ( or ) (just add to the test)
6237           2                                 19                                   { $test .= qq{$1};           }
6238                                                                                elsif( $pred=~ s{^\s*(and|or)\s*}{})
6239          19                                232                                   { $test .= lc " $1 "; }
6240                                                                                else
6241           1                                  9                                   { $syntax_error=1; }
6242                                                                               
6243                                                                               } while( !$syntax_error && $pred);
6244         113    100                         277                              _croak_and_doublecheck_xpath( $original_exp, "error in xpath expression $original_exp at $pred") if( $pred);
6245         112                                957                              $step= " grep { $test } $step ";
6246                                                                          }
6247                                                                      }
6248                                                                    #warn "step: '$step'";
6249         251                               3186                     $sub .= "\@results= grep { \$_ } map { $step } \@results;"; 
6250                                                                  }
6251                                                              }
6252                                                          }
6253                                                    
6254         166    100                         404         if( $xpath_exp)
6255           1                                  8           { _croak_and_doublecheck_xpath( $original_exp, "error in xpath expression $original_exp around $xpath_exp"); }
6256                                                          
6257         165                                355         $sub .= q{return XML::Twig::_unique_elts( @results); };
6258                                                        #warn "generated: '$sub'\n";
6259         165                    4           370         my $s= eval "sub { $NO_WARNINGS; $sub }";
               3                    3            21   
               3                    3             7   
               3                    3            22   
               3                    3            33   
               3                    3             6   
               3                    3            20   
               3                    3            24   
               3                    3             8   
               3                    5            18   
               3                    3            20   
               3                    2             6   
               3                                 17   
               3                                 26   
               3                                  7   
               3                                 18   
               3                                 23   
               3                                  6   
               3                                 18   
               3                                 22   
               3                                  6   
               3                                 24   
               3                                 25   
               3                                  7   
               3                                 17   
               3                                 23   
               3                                  6   
               3                                 17   
               5                                 42   
               5                                 11   
               5                                 32   
               3                                 24   
               3                                  7   
               3                                 19   
               2                                 14   
               2                                  5   
               2                                106   
6260  ***    165     50                         740         if( $@) 
6261  ***      0                                  0           { _croak_and_doublecheck_xpath( $original_exp, "error in xpath expression $original_exp ($@);") }
6262         165                               1228         return( $s); 
6263                                                      }
6264                                                  }
6265                                                  
6266                                                  sub _croak_and_doublecheck_xpath
6267           2                    2             7     { my $xpath_expression= shift;
6268           2                                 10       my $mess= join( "\n", @_);
6269  ***      2     50     50                   24       if( $XML::Twig::XPath::VERSION || 0) 
6270  ***      0                                  0         { my $check_twig= XML::Twig::XPath->new;
6271  ***      0      0                           0           if( eval { $check_twig->{twig_xp}->_parse( $xpath_expression) })
      ***      0                                  0   
6272  ***      0                                  0             { $mess .= "\nthe expression is a valid XPath statement, and you are using XML::Twig::XPath, but"
6273                                                                     . "\nyou are using either 'find_nodes' or 'get_xpath' where the method you likely wanted"
6274                                                                     . "\nto use is 'findnodes', which is the only one that uses the full XPath engine\n";
6275                                                            }
6276                                                        } 
6277           2                                 15       croak $mess;
6278                                                    }
6279                                                      
6280                                                      
6281                                                             
6282                                                  { # extremely elaborate caching mechanism
6283                                                    my %xpath; # xpath_expression => subroutine_code;  
6284                                                    sub get_xpath
6285         173                  173           855       { my( $elt, $xpath_exp, $offset)= @_;
6286         173           100                 1694         my $sub= ($xpath{$xpath_exp} ||= _install_xpath( $xpath_exp));
6287         171    100                         952         return $sub->( $elt) unless( defined $offset); 
6288          13                                 55         my @res= $sub->( $elt);
6289          13                                 77         return $res[$offset];
6290                                                      }
6291                                                  }
6292                                                  
6293                                                  
6294                                                  sub findvalue
6295          13                   13            30     { my $elt= shift;
6296          13                                 50       return join '', map { $_->text } $elt->get_xpath( @_);
              13                                 50   
6297                                                    }
6298                                                  
6299                                                  
6300                                                  # XML::XPath compatibility
6301           1                    1             7   sub getElementById     { return $_[0]->twig->elt_id( $_[1]); }
6302        1582    100          1582        119356   sub getChildNodes      { my @children= $_[0]->_children; return wantarray ? @children : \@children; }
            1582                              11072   
6303                                                  
6304        2200                 2200         12377   sub _flushed     { return $_[0]->{flushed}; }
6305         107                  107           583   sub _set_flushed { $_[0]->{flushed}=1;      }
6306           1                    1             6   sub _del_flushed { delete $_[0]->{flushed}; }
6307                                                  
6308                                                  sub cut
6309        1318                 1318          3164     { my $elt= shift;
6310        1318                               2902       my( $parent, $prev_sibling, $next_sibling, $last_elt);
6311                                                  
6312                                                      # you can't cut the root, sorry
6313        1318    100                        6260       unless( $parent= $elt->{parent}) { return; }
             961                               2215   
6314                                                  
6315                                                      # save the old links, that'll make it easier for some loops
6316         357                               1099       foreach my $link ( qw(parent prev_sibling next_sibling) )
6317        1071                               5239         { $elt->{former}->{$link}= $elt->{$link};
6318        1071    100                        2901            if( $XML::Twig::weakrefs) { weaken( $elt->{former}->{$link}); }
            1065                               6274   
6319                                                        }
6320                                                  
6321                                                      # it we cut the current element then its parent becomes the current elt
6322         357    100                        1487       if( $elt->{twig_current})
6323          46                                144         { my $twig_current= $elt->{parent};
6324          46                                162           my $t= $elt->twig;
6325          46                                158           $t->{twig_current}= $twig_current;
6326          46                                147           $twig_current->{'twig_current'}=1;
6327          46                                143           delete $elt->{'twig_current'};
6328                                                        }
6329                                                  
6330         357    100                        1510       if( $parent->{first_child} == $elt)
6331         178                                762         { $parent->{first_child}=  $elt->{next_sibling};
6332         178    100                         721           unless( $elt->{next_sibling}) { $parent->{empty}= 1; }
              96                                360   
6333                                                        }
6334         357    100                        1479       if( $parent->{last_child} == $elt) {  delete $parent->{empty}; $parent->{last_child}=$elt->{prev_sibling}; if( $XML::Twig::weakrefs) { weaken( $parent->{last_child});} ; }
             153    100                         452   
             153                                624   
             153                                465   
             152                                769   
6335                                                  
6336         357    100                        1441       if( $prev_sibling= $elt->{prev_sibling})
6337         179                                735         { $prev_sibling->{next_sibling}=  $elt->{next_sibling}; }
6338         357    100                        1383       if( $next_sibling= $elt->{next_sibling})
6339         204    100                         807         { $next_sibling->{prev_sibling}=$elt->{prev_sibling}; if( $XML::Twig::weakrefs) { weaken( $next_sibling->{prev_sibling});} ; }
             204                                598   
             203                                877   
6340                                                  
6341                                                  
6342         357    100                        1093       $elt->{parent}=undef; if( $XML::Twig::weakrefs) { weaken( $elt->{parent});} ;
             357                               1020   
             355                               1335   
6343         357    100                        1067       $elt->{prev_sibling}=undef; if( $XML::Twig::weakrefs) { weaken( $elt->{prev_sibling});} ;
             357                                893   
             355                               1696   
6344         357                               1024       $elt->{next_sibling}=  undef;
6345                                                  
6346         357    100    100                 2753       if( $prev_sibling && $next_sibling && $prev_sibling->is_text && ( $XML::Twig::index2gi[$prev_sibling->{'gi'}] eq $XML::Twig::index2gi[$next_sibling->{'gi'}]))
                           100                        
                           100                        
6347           5                                 44         { $prev_sibling->merge_text( $next_sibling); }
6348                                                  
6349         357                               1045       return $elt;
6350                                                    }
6351                                                  
6352                                                  
6353           4                    4            33   sub former_next_sibling { return $_[0]->{former}->{next_sibling}; }
6354           3                    3            25   sub former_prev_sibling { return $_[0]->{former}->{prev_sibling}; }
6355          27                   27           255   sub former_parent       { return $_[0]->{former}->{parent};       }
6356                                                  
6357                                                  sub cut_children
6358          16                   16            60     { my( $elt, $exp)= @_;
6359          16                                 81       my @children= $elt->children( $exp);
6360          16                                 56       foreach (@children) { $_->cut; }
              32                                109   
6361          16                                 48       return @children;
6362                                                    }
6363                                                  
6364                                                  
6365                                                  sub erase
6366          82                   82           267     { my $elt= shift;
6367                                                      #you cannot erase the current element
6368          82    100                         357       if( $elt->{twig_current})
6369           1                                  4         { croak "trying to erase an element before it has been completely parsed"; }
6370          81    100                         303       unless( $elt->{parent})
6371                                                        { # trying to erase the root (of a twig or of a cut/new element)
6372           5                                 21           my @children= $elt->_children;
6373           5    100                          20           unless( @children == 1)
6374           1                                  5             { croak "can only erase an element with no parent if it has a single child"; }
6375           4                                 17           $elt->_move_extra_data_after_erase;
6376           4                                 75           my $child= shift @children;
6377  ***      4     50                          18           $child->{parent}=undef; if( $XML::Twig::weakrefs) { weaken( $child->{parent});} ;
               4                                 15   
               4                                 20   
6378           4                                 15           my $twig= $elt->twig;
6379           4                                 16           $twig->set_root( $child);
6380                                                        }
6381                                                      else     
6382                                                        { # normal case
6383          76                                256           $elt->_move_extra_data_after_erase;
6384          76                                270           my @children= $elt->_children;
6385          76    100                         244           if( @children)
6386                                                            { # elt has children, move them up
6387                                                  
6388          61                                194               my $first_child= $elt->{first_child};
6389          61                                170               my $prev_sibling=$elt->{prev_sibling};
6390          61    100                         155               if( $prev_sibling)
6391                                                                { # connect first child to previous sibling
6392  ***     19     50                          60                   $first_child->{prev_sibling}=$prev_sibling; if( $XML::Twig::weakrefs) { weaken( $first_child->{prev_sibling});} ;      
              19                                 54   
              19                                 95   
6393          19                                 61                   $prev_sibling->{next_sibling}=  $first_child; 
6394                                                                }
6395                                                              else
6396                                                                { # elt was the first child
6397          42                                190                   $elt->{parent}->set_first_child( $first_child);
6398                                                                }
6399                                                  
6400          61                                217               my $last_child= $elt->{last_child};
6401          61                                178               my $next_sibling= $elt->{next_sibling};
6402          61    100                         144               if( $next_sibling)
6403                                                                { # connect last child to next sibling
6404          32                                101                   $last_child->{next_sibling}=  $next_sibling;      
6405  ***     32     50                          94                   $next_sibling->{prev_sibling}=$last_child; if( $XML::Twig::weakrefs) { weaken( $next_sibling->{prev_sibling});} ; 
              32                                 94   
              32                                144   
6406                                                                }
6407                                                              else
6408                                                                { # elt was the last child
6409          29                                131                   $elt->{parent}->set_last_child( $last_child);
6410                                                                }
6411                                                              # update parent for all siblings
6412          61                                176               foreach my $child (@children)
6413  ***     88     50                         331                 { $child->{parent}=$elt->{parent}; if( $XML::Twig::weakrefs) { weaken( $child->{parent});} ; }
              88                                229   
              88                                522   
6414                                                  
6415                                                              # merge consecutive text elements if need be
6416          61    100    100                  342               if( $prev_sibling && $prev_sibling->is_text && ($XML::Twig::index2gi[$first_child->{'gi'}] eq $XML::Twig::index2gi[$prev_sibling->{'gi'}]) )
                           100                        
6417          12                                 57                 { $prev_sibling->merge_text( $first_child); }
6418          61    100    100                  324               if( $next_sibling && $next_sibling->is_text && ($XML::Twig::index2gi[$last_child->{'gi'}] eq $XML::Twig::index2gi[$next_sibling->{'gi'}]) )
                           100                        
6419          10                                 46                 { $last_child->merge_text( $next_sibling); }
6420                                                  
6421                                                              # if parsing and have now a PCDATA text, mark so we can normalize later on if need be
6422  ***     61    100     66                  388               if( $elt->{parent}->{twig_current} && $elt->{last_child}->is_text) {  $elt->{parent}->{twig_to_be_normalized}=1; }
               9                                 43   
6423                                                  
6424                                                              # elt is not referenced any more, so it will be DESTROYed
6425                                                              # so we'd better break the links to its children
6426          61                                181               undef $elt->{first_child};
6427          61                                166               undef $elt->{last_child};
6428          61                                161               undef $elt->{parent};
6429          61                                592               undef $elt->{prev_sibling};
6430          61                                179               undef $elt->{next_sibling};
6431                                                   
6432                                                            }
6433                                                            { # elt had no child, delete it
6434          76                                185                $elt->delete;
              76                                247   
6435                                                            }
6436                                                                
6437                                                        }
6438          80                                330       return $elt;
6439                                                  
6440                                                    }
6441                                                  
6442                                                  sub _move_extra_data_after_erase
6443          80                   80           233     { my( $elt)= @_;
6444                                                      # extra_data
6445          80    100                         363       if( my $extra_data= $elt->{extra_data}) 
6446          20           100                  115         { my $target= $elt->{first_child} || $elt->{next_sibling};
6447          20    100                          55           if( $target)
6448                                                            {
6449          14    100                          44               if( $target->is( '#ELT'))
      ***            50                               
6450           7           100                   32                 { $target->set_extra_data( $extra_data . ($target->extra_data || '')); }
6451                                                              elsif( $target->is( '#TEXT'))
6452           7                                 30                 { $target->_unshift_extra_data_in_pcdata( $extra_data, 0); }  # TO CHECK
6453                                                            }
6454                                                          else
6455           6                                 17             { my $parent= $elt->{parent}; # always exists or the erase cannot be performed
6456           6                                 22               $parent->_prefix_extra_data_before_end_tag( $extra_data); 
6457                                                            }
6458                                                        }
6459                                                        
6460                                                       # extra_data_before_end_tag
6461          80    100                         259       if( my $extra_data= $elt->_extra_data_before_end_tag) 
6462          13    100                          65         { if( my $target= $elt->{next_sibling})
      ***            50                               
6463          10    100                          35             { if( $target->is( '#ELT'))
      ***            50                               
6464           3           100                   13                 { $target->set_extra_data( $extra_data . ($target->extra_data || '')); }
6465                                                              elsif( $target->is( '#TEXT'))
6466                                                                { 
6467           7                                 31                   $target->_unshift_extra_data_in_pcdata( $extra_data, 0);
6468                                                               }
6469                                                            }
6470                                                          elsif( my $parent= $elt->{parent})
6471           3                                 10             { $parent->_prefix_extra_data_before_end_tag( $extra_data); }
6472                                                         }
6473                                                  
6474          80                                212       return $elt;
6475                                                  
6476                                                    }
6477                                                  BEGIN
6478          92                   92          2377     { my %method= ( before      => \&paste_before,
6479                                                                    after       => \&paste_after,
6480                                                                    first_child => \&paste_first_child,
6481                                                                    last_child  => \&paste_last_child,
6482                                                                    within      => \&paste_within,
6483                                                          );
6484                                                      
6485                                                      # paste elt somewhere around ref
6486                                                      # pos can be first_child (default), last_child, before, after or within
6487                                                      sub paste
6488         503                  503          1801         { my $elt= shift;
6489         503    100                        2051           if( $elt->{parent}) 
6490           1                                  3             { croak "cannot paste an element that belongs to a tree"; }
6491         502                                690           my $pos;
6492         502                                667           my $ref;
6493         502    100                        1346           if( ref $_[0]) 
6494          32                                 69             { $pos= 'first_child'; 
6495          32    100                         120               croak "wrong argument order in paste, should be $_[1] first" if($_[1]); 
6496                                                            }
6497                                                          else
6498         470                               1264             { $pos= shift; }
6499                                                  
6500         501    100                        1777           if( my $method= $method{$pos})
6501                                                            {
6502         500    100    100                 5923               unless( ref( $_[0]) && isa( $_[0], 'XML::Twig::Elt'))
6503           4    100                          17                 { if( ! defined( $_[0]))
                    100                               
6504           1                                  4                     { croak "missing target in paste"; }
6505                                                                  elsif( ! ref( $_[0]))
6506           1                                  4                     { croak "wrong target type in paste (not a reference), should be XML::Twig::Elt or a subclass"; }
6507                                                                  else
6508           2                                  7                     { my $ref= ref $_[0];
6509           2                                  9                       croak "wrong target type in paste: '$ref', should be XML::Twig::Elt or a subclass";
6510                                                                    }
6511                                                                }
6512         496                               1177               $ref= $_[0];
6513                                                              # check here so error message lists the caller file/line
6514         496    100    100                 4610               if( !$ref->{parent} && ($pos=~ m{^(before|after)$}) && !(exists $elt->{'target'}) && !(exists $elt->{'comment'})) 
                           100                        
                           100                        
6515           6                                 46                 { croak "cannot paste $1 root"; }
6516         490                               1912               $elt->$method( @_); 
6517                                                            }
6518                                                          else
6519           1                                  8             { croak "tried to paste in wrong position '$pos', allowed positions " . 
6520                                                                " are 'first_child', 'last_child', 'before', 'after' and "    .
6521                                                                "'within'";
6522                                                            }
6523  ***    490    100     66                 2434           if( (my $ids= $elt->{twig_id_list}) && (my $t= $ref->twig) )
6524  ***     22            50                   87             { $t->{twig_id_list}||={};
6525          22                                109               foreach my $id (keys %$ids)
6526          24                                119                 { $t->{twig_id_list}->{$id}= $ids->{$id}; 
6527  ***     24     50                          67                   if( $XML::Twig::weakrefs) { weaken( $t->{twig_id_list}->{$id}); }
              24                                170   
6528                                                                }
6529                                                            }
6530         490                               1642           return $elt;
6531                                                        }
6532                                                    
6533                                                  
6534                                                      sub paste_before
6535          91                   91           316         { my( $elt, $ref)= @_;
6536          91                                232           my( $parent, $prev_sibling, $next_sibling );
6537                                                          
6538                                                          # trying to paste before an orphan (root or detached wlt)
6539          91    100                         362           unless( $ref->{parent}) 
6540  ***      4     50                          19             { if( my $t= $ref->twig)
6541           4    100    100                   45                 { if( (exists $elt->{'comment'}) || (exists $elt->{'target'})) # we can still do this
6542           2                                  8                     { $t->_add_cpi_outside_of_root( leading_cpi => $elt); return; }
               2                                  6   
6543                                                                  else
6544           2                                  9                     { croak "cannot paste before root"; }
6545                                                                }
6546                                                              else
6547  ***      0                                  0                 { croak "cannot paste before an orphan element"; }
6548                                                            }
6549          87                                246           $parent= $ref->{parent};
6550          87                                232           $prev_sibling= $ref->{prev_sibling};
6551          87                                149           $next_sibling= $ref;
6552                                                  
6553  ***     87     50                         263           $elt->{parent}=$parent; if( $XML::Twig::weakrefs) { weaken( $elt->{parent});} ;
              87                                238   
              87                                428   
6554          87    100                         344           if( $parent->{first_child} == $ref) { $parent->{first_child}=  $elt; }
               3                                 12   
6555                                                  
6556          87    100                         227           if( $prev_sibling) { $prev_sibling->{next_sibling}=  $elt; }
              84                                325   
6557  ***     87     50                         350           $elt->{prev_sibling}=$prev_sibling; if( $XML::Twig::weakrefs) { weaken( $elt->{prev_sibling});} ;
              87                                235   
              87                                421   
6558                                                  
6559  ***     87     50                         262           $next_sibling->{prev_sibling}=$elt; if( $XML::Twig::weakrefs) { weaken( $next_sibling->{prev_sibling});} ;
              87                                248   
              87                                379   
6560          87                                326           $elt->{next_sibling}=  $ref;
6561          87                                243           return $elt;
6562                                                        }
6563                                                       
6564                                                       sub paste_after
6565         176                  176           591         { my( $elt, $ref)= @_;
6566         176                                424           my( $parent, $prev_sibling, $next_sibling );
6567                                                  
6568                                                          # trying to paste after an orphan (root or detached wlt)
6569         176    100                         659           unless( $ref->{parent}) 
6570  ***      4     50                          16               { if( my $t= $ref->twig)
6571           4    100    100                   46                   { if( (exists $elt->{'comment'}) || (exists $elt->{'target'})) # we can still do this
6572           2                                  8                       { $t->_add_cpi_outside_of_root( trailing_cpi => $elt); return; }
               2                                  7   
6573                                                                    else
6574           2                                  9                       { croak "cannot paste after root"; }
6575                                                                  }
6576                                                                else
6577  ***      0                                  0                   { croak "cannot paste after an orphan element"; }
6578                                                              }
6579         172                                449           $parent= $ref->{parent};
6580         172                                307           $prev_sibling= $ref;
6581         172                                462           $next_sibling= $ref->{next_sibling};
6582                                                  
6583  ***    172     50                         511           $elt->{parent}=$parent; if( $XML::Twig::weakrefs) { weaken( $elt->{parent});} ;
             172                                481   
             172                                757   
6584  ***    172     50                         766           if( $parent->{last_child}== $ref) {  delete $parent->{empty}; $parent->{last_child}=$elt; if( $XML::Twig::weakrefs) { weaken( $parent->{last_child});} ; }
             142    100                         429   
             142                                429   
             142                                369   
             142                                698   
6585                                                  
6586         172                                506           $prev_sibling->{next_sibling}=  $elt;
6587  ***    172     50                         477           $elt->{prev_sibling}=$prev_sibling; if( $XML::Twig::weakrefs) { weaken( $elt->{prev_sibling});} ;
             172                                456   
             172                                638   
6588                                                  
6589  ***    172     50                         499           if( $next_sibling) { $next_sibling->{prev_sibling}=$elt; if( $XML::Twig::weakrefs) { weaken( $next_sibling->{prev_sibling});} ; }
              30    100                          93   
              30                                 77   
              30                                151   
6590         172                                517           $elt->{next_sibling}=  $next_sibling;
6591         172                                473           return $elt;
6592                                                  
6593                                                        }
6594                                                  
6595                                                      sub paste_first_child
6596          52                   52           177         { my( $elt, $ref)= @_;
6597          52                                138           my( $parent, $prev_sibling, $next_sibling );
6598          52                                106           $parent= $ref;
6599          52                                166           $next_sibling= $ref->{first_child};
6600          52                                141           delete $ref->{empty};
6601                                                  
6602  ***     52     50                         164           $elt->{parent}=$parent; if( $XML::Twig::weakrefs) { weaken( $elt->{parent});} ;
              52                                161   
              52                                321   
6603          52                                160           $parent->{first_child}=  $elt;
6604  ***     52     50                         212           unless( $parent->{last_child}) {  delete $parent->{empty}; $parent->{last_child}=$elt; if( $XML::Twig::weakrefs) { weaken( $parent->{last_child});} ; }
              31    100                          80   
              31                                 87   
              31                                 91   
              31                                152   
6605                                                  
6606  ***     52     50                         165           $elt->{prev_sibling}=undef; if( $XML::Twig::weakrefs) { weaken( $elt->{prev_sibling});} ;
              52                                156   
              52                                217   
6607                                                  
6608  ***     52     50                         147           if( $next_sibling) { $next_sibling->{prev_sibling}=$elt; if( $XML::Twig::weakrefs) { weaken( $next_sibling->{prev_sibling});} ; }
              21    100                          62   
              21                                 72   
              21                                112   
6609          52                                164           $elt->{next_sibling}=  $next_sibling;
6610          52                                146           return $elt;
6611                                                        }
6612                                                        
6613                                                      sub paste_last_child
6614        3404                 3404         11197         { my( $elt, $ref)= @_;
6615        3404                               7730           my( $parent, $prev_sibling, $next_sibling );
6616        3404                               6011           $parent= $ref;
6617        3404                               9756           $prev_sibling= $ref->{last_child};
6618        3404                               8805           delete $ref->{empty};
6619                                                  
6620  ***   3404     50                        9905           $elt->{parent}=$parent; if( $XML::Twig::weakrefs) { weaken( $elt->{parent});} ;
            3404                               9262   
            3404                              16370   
6621  ***   3404     50                        7792            delete $parent->{empty}; $parent->{last_child}=$elt; if( $XML::Twig::weakrefs) { weaken( $parent->{last_child});} ;
            3404                              10052   
            3404                               8540   
            3404                              15543   
6622        3404    100                       12905           unless( $parent->{first_child}) { $parent->{first_child}=  $elt; }
            1986                               6443   
6623                                                  
6624  ***   3404     50                       10167           $elt->{prev_sibling}=$prev_sibling; if( $XML::Twig::weakrefs) { weaken( $elt->{prev_sibling});} ;
            3404                               8172   
            3404                              13214   
6625        3404    100                        8343           if( $prev_sibling) { $prev_sibling->{next_sibling}=  $elt; }
            1418                               4233   
6626                                                  
6627        3404                               9870           $elt->{next_sibling}=  undef;
6628        3404                               8298           return $elt;
6629                                                        }
6630                                                  
6631                                                      sub paste_within
6632           2                    2            18         { my( $elt, $ref, $offset)= @_;
6633           2    100                           9           my $text= $ref->is_text ? $ref : $ref->next_elt( '#TEXT', $ref);
6634           2                                 10           my $new= $text->split_at( $offset);
6635           2                                  8           $elt->paste_before( $new);
6636           2                                  7           return $elt;
6637                                                        }
6638                                                    }
6639                                                  
6640                                                  # load an element into a structure similar to XML::Simple's
6641                                                  sub simplify
6642         121                  121           320     { my $elt= shift;
6643                                                  
6644                                                      # normalize option names
6645         121                                657       my %options= @_;
6646         121                                532       %options= map { my ($key, $val)= ($_, $options{$_});
             117                                587   
6647         117                                871                          $key=~ s{(\w)([A-Z])}{$1_\L$2}g;
6648         117                                946                          $key => $val
6649                                                                       } keys %options;
6650                                                  
6651                                                      # check options
6652         121                               1134       my @allowed_options= qw( keyattr forcearray noattr content_key
6653                                                                               var var_regexp variables var_attr 
6654                                                                               group_tags forcecontent
6655                                                                               normalise_space normalize_space
6656                                                                     );
6657         121                                304       my %allowed_options= map { $_ => 1 } @allowed_options;
            1452                               5722   
6658         121                               1038       foreach my $option (keys %options)
6659  ***    117     50                         662         { warn "invalid option $option\n" unless( $allowed_options{$option}); }
6660                                                  
6661         121           100                 1341       $options{normalise_space} ||= $options{normalize_space} || 0;
      ***                   66                        
6662                                                      
6663         121           100                  610       $options{content_key} ||= 'content';
6664         121    100                         766       if( $options{content_key}=~ m{^-})
6665                                                        { # need to remove the - and to activate extra folding
6666           5                                 21           $options{content_key}=~ s{^-}{};
6667           5                                 20           $options{extra_folding}= 1;
6668                                                        }
6669                                                      else
6670         116                                406         { $options{extra_folding}= 0; }
6671                                                     
6672         121           100                  520       $options{forcearray} ||=0; 
6673         121    100                         604       if( isa( $options{forcearray}, 'ARRAY'))
6674           5                                 12         { my %forcearray_tags= map { $_ => 1 } @{$options{forcearray}};
               5                                 28   
               5                                 22   
6675           5                                 24           $options{forcearray_tags}= \%forcearray_tags;
6676           5                                 18           $options{forcearray}= 0;
6677                                                        }
6678                                                  
6679         121           100                  747       $options{keyattr}     ||= ['name', 'key', 'id'];
6680         121    100                         653       if( ref $options{keyattr} eq 'ARRAY')
      ***            50                               
6681         106                                206         { foreach my $keyattr (@{$options{keyattr}})
             106                                454   
6682         293                               1823             { my( $prefix, $att)= ($keyattr=~ m{^([+-])?(.*)});
6683  ***    293            50                 1083               $prefix ||= '';
6684         293                               1315               $options{key_for_all}->{$att}= 1;
6685  ***    293     50                        1766               $options{remove_key_for_all}->{$att}=1 unless( $prefix eq '+');
6686  ***    293     50                        1252               $options{prefix_key_for_all}->{$att}=1 if( $prefix eq '-');
6687                                                            }
6688                                                        }
6689                                                      elsif( ref $options{keyattr} eq 'HASH')
6690          15                                 40         { while( my( $elt, $keyattr)= each %{$options{keyattr}})
              30                                231   
6691          15                                123            { my( $prefix, $att)= ($keyattr=~ m{^([+-])?(.*)});
6692          15           100                   63              $prefix ||='';
6693          15                                 83              $options{key_for_elt}->{$elt}= $att;
6694          15    100                          71              $options{remove_key_for_elt}->{"$elt#$att"}=1 unless( $prefix);
6695          15    100                         107              $options{prefix_key_for_elt}->{"$elt#$att"}=1 if( $prefix eq '-');
6696                                                           }
6697                                                        }
6698                                                         
6699                                                  
6700  ***    121            33                  767       $options{var}||= $options{var_attr}; # for compat with XML::Simple
6701         121    100                         405       if( $options{var}) { $options{var_values}= {}; }
              11                                 50   
6702         110                                379       else               { $options{var}='';         }
6703                                                  
6704         121    100                         402       if( $options{variables}) 
6705           7           100                   33         { $options{var}||= 1;
6706           7                                 33           $options{var_values}= $options{variables};
6707                                                        }
6708                                                  
6709  ***    121     50     66                  498       if( $options{var_regexp} and !$options{var})
6710  ***      0                                  0         { warn "var option not used, var_regexp option ignored\n"; }
6711         121           100                  522       $options{var_regexp} ||= '\$\{?(\w+)\}?';
6712                                                        
6713         121                                538       $elt->_simplify( \%options);
6714                                                   
6715                                                   }
6716                                                  
6717                                                  sub _simplify
6718         762                  762          2352     { my( $elt, $options)= @_;
6719                                                  
6720         762                               1282       my $data;
6721                                                  
6722         762                               2703       my $gi= $XML::Twig::index2gi[$elt->{'gi'}];
6723         762                               2295       my @children= $elt->_children;
6724  ***    762    100     66                 5537       my %atts= $options->{noattr} || !$elt->atts ? () : %{$elt->atts};
             730                               2061   
6725         762                               2461       my $nb_atts= keys %atts;
6726         762                               2258       my $nb_children= $elt->children_count + $nb_atts;
6727                                                  
6728         762                               1179       my %nb_children;
6729         762                               2246       foreach (@children)   { $nb_children{$_->tag}++; }
            1116                               3698   
6730         762                               3370       foreach (keys %atts)  { $nb_children{$_}++;      }
             576                               2361   
6731                                                  
6732         762                               1491       my $arrays; # tag => array where elements are stored
6733                                                  
6734                                                  
6735                                                      # store children
6736         762                               2124       foreach my $child (@children)
6737        1116    100                        3496         { if( $child->is_text)
6738                                                            { # generate with a content key
6739         475                               1458               my $text= $elt->_text_with_vars( $options);
6740         475    100                        2211               if( $options->{normalise_space} >= 2) { $text= _normalize_space( $text); }
              20                                 59   
6741  ***    475    100     66                 5107               if(    $options->{force_content}
                           100                        
6742                                                                  || $nb_atts 
6743                                                                  || (scalar @children > 1)
6744                                                                )
6745         201                               1513                 { $data->{$options->{content_key}}= $text; }
6746                                                              else
6747         274                               1296                 { $data= $text; }
6748                                                            }
6749                                                          else
6750                                                            { # element with sub elements
6751         641                               2307               my $child_gi= $XML::Twig::index2gi[$child->{'gi'}];
6752                                                  
6753         641                               2194               my $child_data= $child->_simplify( $options);
6754                                                  
6755                                                              # first see if we need to simplify further the child data
6756                                                              # simplify because of grouped tags
6757         641    100                        3405               if( my $grouped_tag= $options->{group_tags}->{$child_gi})
6758                                                                { # check that the child data is a hash with a single field
6759  ***      9    100     66                  141                   unless(    (ref( $child_data) eq 'HASH')
      ***                   66                        
6760                                                                          && (keys %$child_data == 1)
6761                                                                          && defined ( my $grouped_child_data= $child_data->{$grouped_tag})
6762                                                                        )
6763           3                                 15                     { croak "error in grouped tag $child_gi"; }
6764                                                                  else
6765           6                                 19                     { $child_data=  $grouped_child_data; }
6766                                                                }
6767                                                              # simplify because of extra folding
6768         638    100                        2237               if( $options->{extra_folding})
6769          27    100    100                  312                 { if(    (ref( $child_data) eq 'HASH')
                           100                        
6770                                                                      && (keys %$child_data == 1)
6771                                                                      && defined( my $content= $child_data->{$options->{content_key}})
6772                                                                    )
6773           8                                 24                     { $child_data= $content; }
6774                                                                }
6775                                                  
6776         638    100    100                 2126               if( my $keyatt= $child->_key_attr( $options))
                    100    100                        
6777                                                                { # simplify element with key
6778         207                                943                   my $key= $child->{'att'}->{$keyatt};
6779         207    100                         903                   if( $options->{normalise_space} >= 1) { $key= _normalize_space( $key); }
              22                                 64   
6780         207                               1603                   $data->{$child_gi}->{$key}= $child_data;
6781                                                                }
6782                                                              elsif(      $options->{forcearray}
6783                                                                     ||   $options->{forcearray_tags}->{$child_gi}
6784                                                                     || ( $nb_children{$child_gi} > 1)
6785                                                                   )
6786                                                                { # simplify element to store in an array
6787         239           100                 1073                   $data->{$child_gi} ||= [];
6788         239                                423                   push @{$data->{$child_gi}}, $child_data;
             239                               1579   
6789                                                                }
6790                                                              else
6791                                                                { # simplify element to store as a hash field
6792         192                               1555                   $data->{$child_gi}= $child_data;
6793                                                                }
6794                                                            }
6795                                                      }
6796                                                  
6797                                                      # store atts
6798                                                      # TODO: deal with att that already have an element by that name
6799         759                               3135       foreach my $att (keys %atts)
6800                                                        { # do not store if the att is a key that needs to be removed
6801         576    100    100                 5823           if(    $options->{remove_key_for_all}->{$att}
6802                                                              || $options->{remove_key_for_elt}->{"$gi#$att"}
6803                                                            )
6804         201                                690             { next; }
6805                                                  
6806         375    100                        1921           my $att_text= $options->{var} ?  _replace_vars_in_text( $atts{$att}, $options) : $atts{$att} ;
6807         375    100                        1569           if( $options->{normalise_space} >= 2) { $att_text= _normalize_space( $att_text); }
              15                                 39   
6808                                                          
6809  ***    375    100     66                 4378           if(    $options->{prefix_key_for_all}->{$att}
6810                                                              || $options->{prefix_key_for_elt}->{"$gi#$att"}
6811                                                            )
6812                                                            { # prefix the att
6813           3                                 22               $data->{"-$att"}= $att_text;
6814                                                            } 
6815                                                          else
6816                                                            { # normal case
6817         372                               2126               $data->{$att}= $att_text; 
6818                                                            }
6819                                                        }
6820                                                      
6821         759                               4501       return $data;
6822                                                    }
6823                                                  
6824                                                  sub _key_attr
6825         638                  638          1915     { my( $elt, $options)=@_;
6826         638    100                        2738       return if( $options->{noattr});
6827         611    100                        2101       if( $options->{key_for_all})
      ***            50                               
6828         530                               1506         { foreach my $att ($elt->att_names)
6829         238    100                        1229             { if( $options->{key_for_all}->{$att})
6830         198                                990                 { return $att; }
6831                                                            }
6832                                                        }
6833                                                      elsif( $options->{key_for_elt})
6834          81    100                         520         { if( my $key_for_elt= $options->{key_for_elt}->{$XML::Twig::index2gi[$elt->{'gi'}]} )
6835          12    100                          84             { return $key_for_elt if( defined( $elt->{'att'}->{$key_for_elt})); }
6836                                                        }
6837         404                               6664       return;
6838                                                    }
6839                                                  
6840                                                  sub _text_with_vars
6841         475                  475          1541     { my( $elt, $options)= @_;
6842         475                                807       my $text;
6843         475    100                        1640       if( $options->{var}) 
6844          68                                273         { $text= _replace_vars_in_text( $elt->text, $options); 
6845          68                                226           $elt->_store_var( $options);
6846                                                        }
6847                                                       else
6848         407                               1265         { $text= $elt->text; }
6849         475                               1605       return $text;
6850                                                    }
6851                                                  
6852                                                  
6853                                                  sub _normalize_space
6854          57                   57           141     { my $text= shift;
6855          57                                246       $text=~ s{\s+}{ }sg;
6856          57                                183       $text=~ s{^\s}{};
6857          57                                187       $text=~ s{\s$}{};
6858          57                                202       return $text;
6859                                                    }
6860                                                  
6861                                                  
6862                                                  sub att_nb
6863  ***     14     50            14            53     { return 0 unless( my $atts= $_[0]->atts);
6864          14                                 70       return scalar keys %$atts;
6865                                                    }
6866                                                      
6867                                                  sub has_no_atts
6868  ***      3     50             3            13     { return 1 unless( my $atts= $_[0]->atts);
6869           3    100                          27       return scalar keys %$atts ? 0 : 1;
6870                                                    }
6871                                                      
6872                                                  sub _replace_vars_in_text
6873         117                  117           442     { my( $text, $options)= @_;
6874                                                  
6875         117    100                         905       $text=~ s{($options->{var_regexp})}
              14                                158   
               8                                 43   
6876                                                               { if( defined( my $value= $options->{var_values}->{$2}))
6877           6                                 13                    { $value }
6878           6                                 87                  else
6879                                                                   { warn "unknown variable $2\n";
6880                                                                     $1
6881                                                                   }
6882                                                               }gex;
6883         117                                410       return $text;
6884                                                    }
6885                                                  
6886                                                  sub _store_var
6887          68                   68           199     { my( $elt, $options)= @_;
6888          68    100                         497       if( defined (my $var_name= $elt->{'att'}->{$options->{var}}))
6889           3                                 18          { $options->{var_values}->{$var_name}= $elt->text; 
6890                                                         }
6891                                                    }
6892                                                  
6893                                                  
6894                                                  # split a text element at a given offset
6895                                                  sub split_at
6896          84                   84           345     { my( $elt, $offset)= @_;
6897  ***     84    100     33                  386       my $text_elt= $elt->is_text ? $elt : $elt->first_child( TEXT) || return '';
6898          84                                295       my $string= $text_elt->text; 
6899          84                                292       my $left_string= substr( $string, 0, $offset);
6900          84                                210       my $right_string= substr( $string, $offset);
6901          84                                288       $text_elt->set_pcdata( $left_string);
6902          84                                447       my $new_elt= $elt->new( $XML::Twig::index2gi[$elt->{'gi'}], $right_string);
6903          84                                310       $new_elt->paste( after => $elt);
6904          84                                252       return $new_elt;
6905                                                    }
6906                                                  
6907                                                      
6908                                                  # split an element or its text descendants into several, in place
6909                                                  # all elements (new and untouched) are returned
6910                                                  sub split    
6911           6                    6            30     { my $elt= shift;
6912           6                                  9       my @text_chunks;
6913           6                                 12       my @result;
6914           6    100                          24       if( $elt->is_text) { @text_chunks= ($elt); }
               1                                  4   
6915           5                                 23       else               { @text_chunks= $elt->descendants( '#TEXT'); }
6916           6                                 20       foreach my $text_chunk (@text_chunks)
6917           6                                 29         { push @result, $text_chunk->_split( 1, @_); }
6918           6                                 24       return @result;
6919                                                    }
6920                                                  
6921                                                  # split an element or its text descendants into several, in place
6922                                                  # created elements (those which match the regexp) are returned
6923                                                  sub mark
6924          26                   26            59     { my $elt= shift;
6925          26                                 42       my @text_chunks;
6926          26                                 35       my @result;
6927          26    100                          89       if( $elt->is_text) { @text_chunks= ($elt); }
               1                                  3   
6928          25                                 87       else               { @text_chunks= $elt->descendants( '#TEXT'); }
6929          26                                 92       foreach my $text_chunk (@text_chunks)
6930          26                                118         { push @result, $text_chunk->_split( 0, @_); }
6931          26                                124       return @result;
6932                                                    }
6933                                                  
6934                                                  # split a single text element
6935                                                  # return_all defines what is returned: if it is true 
6936                                                  # only returns the elements created by matches in the split regexp
6937                                                  # otherwise all elements (new and untouched) are returned
6938                                                  
6939                                                  { 
6940                                                   
6941                                                    sub _split
6942          32                   32            79       { my $elt= shift;
6943          32                                 67         my $return_all= shift;
6944          32                                 74         my $regexp= shift;
6945          32                                153         my @tags;
6946                                                  
6947          32                                125         while( my $tag= shift())
6948          30    100                          82           { if( ref $_[0]) 
6949           5                                 54               { push @tags, { tag => $tag, atts => shift }; }
6950                                                            else
6951          25                                221               { push @tags, { tag => $tag }; }
6952                                                          }
6953                                                  
6954          32    100                          85         unless( @tags) { @tags= { tag => $elt->parent( '#ELT')->gi }; }
               2                                 11   
6955                                                            
6956          32                                 56         my @result;                                 # the returned list of elements
6957          32                                115         my $text= $elt->text;
6958          32                                141         my $gi= $XML::Twig::index2gi[$elt->{'gi'}];
6959                                                    
6960                                                        # 2 uses: if split matches then the first substring reuses $elt
6961                                                        #         once a split has occured then the last match needs to be put in
6962                                                        #         a new element      
6963          32                                 62         my $previous_match= 0;
6964                                                  
6965          32                               1125         while( my( $pre_match, @matches)= $text=~ /^(.*?)$regexp(.*)$/gcs)
6966          43                                312           { $text= pop @matches;
6967          43    100                         113             if( $previous_match)
6968                                                              { # match, not the first one, create a new text ($gi) element
6969          15                                 39                 _utf8_ify( $pre_match);
6970          15                                 58                 $elt= $elt->insert_new_elt( after => $gi, $pre_match);
6971          15    100                          50                 push @result, $elt if( $return_all);
6972                                                              }
6973                                                            else
6974                                                              { # first match in $elt, re-use $elt for the first sub-string
6975          28                                 98                  _utf8_ify( $pre_match);
6976          28                                112                 $elt->set_text( $pre_match);
6977          28                                 45                 $previous_match++;                # store the fact that there was a match
6978          28    100                          84                 push @result, $elt if( $return_all);
6979                                                              }
6980                                                  
6981                                                            # now deal with matches captured in the regexp
6982          43    100                         108             if( @matches)
6983                                                              { # match, with capture
6984          31                                 57                 my $i=0;
6985          31                                 82                 foreach my $match (@matches)
6986                                                                  { # create new element, text is the match
6987          33                                 82                     _utf8_ify( $match);
6988          33                                138                     my $tag  = $tags[$i]->{tag};
6989  ***     33            50                   56                     my $atts = \%{$tags[$i]->{atts}} || {};
              33                                198   
6990          33                                138                     $elt= $elt->insert_new_elt( after => $tag, $atts, $match);
6991          33                                 83                     push @result, $elt;
6992          33                                513                     $i= ($i + 1) % @tags;
6993                                                                  }
6994                                                              }
6995                                                            else
6996                                                              { # match, no captures
6997          12                                 41                 my $tag  = $tags[0]->{tag};
6998  ***     12            50                   22                 my $atts = \%{$tags[0]->{atts}} || {};
              12                                 72   
6999          12                                 48                 $elt=  $elt->insert_new_elt( after => $tag, $atts);
7000          12                                153                 push @result, $elt;
7001                                                              }
7002                                                          }
7003          32    100    100                  219         if( $previous_match && $text)
7004                                                          { # there was at least 1 match, and there is text left after the match
7005          13                                 51             $elt= $elt->insert_new_elt( after => $gi, $text);
7006                                                          }
7007                                                  
7008          32    100                          81         push @result, $elt if( $return_all);
7009                                                  
7010          32                                266         return @result; # return all elements
7011                                                     }
7012                                                  
7013                                                    # evil hack needed as sometimes 
7014                                                    my $encode_is_loaded=0;   # so we only load Encode once
7015                                                    sub _utf8_ify
7016          77                   77           186       { my $string= shift;
7017  ***     77     50     33                  498         if( $] >= 5.008 and !_keep_encoding()) 
7018          77    100                         191           { unless( $encode_is_loaded) { require Encode; import Encode; $encode_is_loaded++; }
               3                                 22   
               3                                 35   
               3                                739   
7019          77                                311             Encode::_utf8_on( $string); # the flag should be set but is not
7020                                                          }
7021                                                      }
7022                                                  
7023                                                  
7024                                                  }
7025                                                  
7026                                                  { my %replace_sub; # cache for complex expressions (expression => sub)
7027                                                  
7028                                                    sub subs_text
7029          23                   23           141       { my( $elt, $regexp, $replace)= @_;
7030                                                    
7031          23                                 50         my $replacement_string;
7032          23                                 70         my $is_string= _is_string( $replace);
7033          23                                124         foreach my $text_elt ($elt->descendants_or_self( '#TEXT'))
7034          54    100                         340           { if( $is_string)
7035          15                                 53               { my $text= $text_elt->text;
7036          15                                217                 $text=~ s{$regexp}{ _replace_var( $replace, $1, $2, $3, $4, $5, $6, $7, $8, $9)}egx;
              27                                130   
7037          15                                 65                 $text_elt->set_text( $text);
7038                                                             }
7039                                                            else
7040                                                              { 
7041  ***     39            66                  238                 my $replace_sub= ( $replace_sub{$replace} ||= _install_replace_sub( $replace)); 
7042          39                                152                 my $text= $text_elt->text;
7043          39                                 82                 my $pos=0;  # used to skip text that was previously matched
7044          39                                883                 while( my( $pre_match_string, $match_string, @var)= ($text=~ m{(.*?)($regexp)}sg))
7045          39                                562                   { my $match_start  = length( $pre_match_string);
7046          39                                189                     my $match        = $text_elt->split_at( $match_start + $pos);
7047          39                                103                     my $match_length = length( $match_string);
7048          39                                131                     my $post_match   = $match->split_at( $match_length);
7049          39                                174                     $replace_sub->( $match, @var);
7050                                                                    # merge previous text with current one
7051          38                                 67                     my $next_sibling;
7052  ***     38     50     33                  468                     if(    ($next_sibling= $text_elt->{next_sibling})
7053                                                                        && ($XML::Twig::index2gi[$text_elt->{'gi'}] eq $XML::Twig::index2gi[$next_sibling->{'gi'}])
7054                                                                      )
7055          38                                149                       { $text_elt->merge_text( $next_sibling); }
7056                                                                      
7057                                                                    # if the match is at the beginning of the text an empty #PCDATA is left: remove it 
7058          38    100                         171                     if( !$text_elt->text) { $text_elt->delete; } 
              18                                 58   
7059                                                                    
7060                                                                    # go to next 
7061          38                                 95                     $text_elt= $post_match;
7062          38                                 73                     $text= $post_match->text;
7063                                                                    # merge last text element with next one if needed,
7064                                                                    # the match will be against the non-matched text,
7065                                                                    # so $pos is used to skip the merged part
7066          38                                129                     my $prev_sibling;
7067  ***     38     50     66                  464                     if(    ($prev_sibling=  $post_match->{prev_sibling})
7068                                                                        && ($XML::Twig::index2gi[$post_match->{'gi'}] eq $XML::Twig::index2gi[$prev_sibling->{'gi'}])
7069                                                                      )
7070  ***      0                                  0                       { $pos= length( $prev_sibling->text);
7071  ***      0                                  0                         $prev_sibling->merge_text( $post_match); 
7072                                                                      }
7073                                                  
7074                                                                    # if the match is at the end of the text an empty #PCDATA is left: remove it 
7075          38    100                         119                     if( !$text_elt->text) { $text_elt->delete; } 
              18                                185   
7076                                                                    
7077                                                                  }
7078                                                                
7079                                                              }
7080                                                          }
7081          22                                 52         return $elt;
7082                                                      }
7083                                                  
7084                                                  
7085                                                    sub _is_string
7086          23    100            23           172       { return ($_[0]=~ m{&e[ln]t}) ? 0: 1 }
7087                                                  
7088                                                    sub _replace_var
7089          27                   27           261       { my( $string, @var)= @_;
7090          27                                106         unshift @var, undef;
7091          27                                166         $string=~ s{\$(\d)}{$var[$1]}g;
7092          27                                189         return $string;
7093                                                      }
7094                                                  
7095                                                    sub _install_replace_sub
7096          13                   13            42       { my $replace_exp= shift;
7097          13                                154         my @item= split m{(&e[ln]t\s*\([^)]*\))}, $replace_exp;
7098          13                                 45         my $sub= q{ my( $match, @var)= @_; unshift @var, undef; my $new; };
7099          13                                 35         my( $gi, $exp);
7100          13                                 44         foreach my $item (@item)
7101          28    100                         159           { if(    $item=~ m{^&elt\s*\(([^)]*)\)})
                    100                               
7102          10                                 47               { $exp= $1;
7103                                                              }
7104                                                            elsif( $item=~ m{^&ent\s*\(\s*([^\s)]*)\s*\)})
7105           3                                 17               { $exp= " '#ENT' => $1"; }
7106                                                            else
7107          15                                 70               { $exp= qq{ '#PCDATA' => "$item"}; }
7108          28                                156             $exp=~ s{\$(\d)}{\$var[$1]}g; # replace references to matches
7109          28                                104             $sub.= qq{ \$new= \$match->new( $exp); };
7110          28                                 98             $sub .= q{ $new->paste( before => $match); };
7111                                                          }
7112          13                                 33         $sub .= q{ $match->delete; };
7113                                                        #$sub=~ s/;/;\n/g;
7114          13                    1            31         my $coderef= eval "sub { $NO_WARNINGS; $sub }";
               1                    1             7   
               1                    1             2   
               1                    1             6   
               1                                  7   
               1                                  2   
               1                                  6   
               1                                  7   
               1                                  2   
               1                                  5   
               1                                  7   
               1                                  2   
               1                                  5   
7115  ***     13     50                          86         if( $@) { croak( "invalid replacement expression $replace_exp: ",$@); }
      ***      0                                  0   
7116          13                                108         return $coderef;
7117                                                      }
7118                                                  
7119                                                    }
7120                                                  
7121                                                  
7122                                                  sub merge_text
7123          69                   69           312     { my( $e1, $e2)= @_;
7124          69    100                         428       croak "invalid merge: can only merge 2 elements" 
7125                                                          unless( isa( $e2, 'XML::Twig::Elt'));
7126  ***     68    100     66                  218       croak "invalid merge: can only merge 2 text elements" 
                           100                        
7127                                                          unless( $e1->is_text && $e2->is_text && ($e1->gi eq $e2->gi));
7128          66                                286       my $text1= $e1->text;
7129          66                                214       my $text2= $e2->text;
7130          66                                309       $e1->set_text( $text1 . $text2);
7131                                                  
7132          66                                199       my $extra_data= $e1->_extra_data_before_end_tag . $e2->extra_data;
7133  ***     66     50                         230       if( $extra_data) 
7134  ***      0                                  0         { $e1->_del_extra_data_before_end_tag;
7135  ***      0                                  0           $e1->_push_extra_data_in_pcdata( $extra_data, length( $text1)); 
7136                                                        }
7137                                                  
7138          66    100                         188       if( $extra_data= $e2->_extra_data_in_pcdata)
7139          10                                 30         { foreach my $data (@$extra_data) { $e1->_push_extra_data_in_pcdata( $data->{text}, $data->{offset} + length( $text1)); } }
              16                                112   
7140                                                  
7141  ***     66     50                         200       if( my $extra_data_before_end_tag= $e2->_extra_data_before_end_tag) 
7142  ***      0                                  0         { $e1->_set_extra_data_before_end_tag( $extra_data_before_end_tag); }
7143                                                  
7144          66                                225       $e2->delete;
7145                                                  
7146          66                                191       return $e1;
7147                                                    }
7148                                                  
7149                                                  sub merge
7150           2                    2             7     { my( $e1, $e2)= @_;
7151           2                                 10       my @e2_children= $e2->_children;
7152  ***      2     50     33                   10       if(     $e1->_last_child && $e1->_last_child->is_pcdata
      ***                   33                        
      ***                   33                        
7153                                                          &&  @e2_children && $e2_children[0]->is_pcdata
7154                                                        )
7155           2                                 15         { $e1->_last_child->{pcdata} .= $e2_children[0]->{pcdata}; shift @e2_children; }
               2                                  5   
7156           2                                 11       foreach my $e (@e2_children) { $e->move( last_child => $e1); } 
      ***      0                                  0   
7157           2                                  9       $e2->delete;
7158           2                                  7       return $e1;
7159                                                    }
7160                                                  
7161                                                  
7162                                                  # recursively copy an element and returns the copy (can be huge and long)
7163                                                  sub copy
7164          61                   61           151     { my $elt= shift;
7165          61                                315       my $copy= $elt->new( $XML::Twig::index2gi[$elt->{'gi'}]);
7166                                                  
7167          61    100                         219       if( $elt->extra_data) { $copy->set_extra_data( $elt->extra_data); }
               4                                 13   
7168          61    100                         218       if( $elt->_extra_data_before_end_tag) { $copy->_set_extra_data_before_end_tag( $elt->_extra_data_before_end_tag); }
               7                                 22   
7169                                                  
7170          61    100                         225       if( $elt->is_asis)   { $copy->set_asis; }
               2                                  7   
7171          61           100                  601       $copy->{empty}=  ($elt->{'empty'} || 0); # do not swap or speedup will mess up this                         
7172                                                  
7173          61    100                         440       if( (exists $elt->{'pcdata'})) 
                    100                               
                    100                               
                    100                               
                    100                               
7174          25                                122         { $copy->set_pcdata( $elt->{pcdata}); 
7175          25    100                          70           if( $elt->_extra_data_in_pcdata) { $copy->_set_extra_data_in_pcdata( $elt->_extra_data_in_pcdata); }
               7                                 25   
7176                                                        }
7177                                                      elsif( (exists $elt->{'cdata'}))
7178           2                                  9         { $copy->_set_cdata( $elt->{cdata}); 
7179  ***      2     50                           6           if( $elt->_extra_data_in_pcdata) { $copy->_set_extra_data_in_pcdata( $elt->_extra_data_in_pcdata); }
      ***      0                                  0   
7180                                                        }
7181                                                      elsif( (exists $elt->{'target'}))
7182           1                                  7         { $copy->_set_pi( $elt->{target}, $elt->{data}); }
7183                                                      elsif( (exists $elt->{'comment'}))
7184           1                                  5         { $copy->_set_comment( $elt->{comment}); }
7185                                                      elsif( (exists $elt->{'ent'}))
7186           1                                  5         { $copy->{ent}=  $elt->{ent}; }
7187                                                      else
7188          31                                106         { my @children= $elt->_children;
7189          31    100                         118           if( my $atts= $elt->atts)
7190          26                                 44             { my %atts;
7191  ***     26     50                          73               tie %atts, 'Tie::IxHash' if (keep_atts_order());
7192          26                                 49               %atts= %{$atts}; # we want to do a real copy of the attributes
              26                                110   
7193          26                                119               $copy->set_atts( \%atts);
7194                                                            }
7195          31                                126           foreach my $child (@children)
7196          48                                249             { my $child_copy= $child->copy;
7197          48                                165               $child_copy->paste( 'last_child', $copy);
7198                                                            }
7199                                                        }
7200                                                      # save links to the original location, which can be convenient and is used for namespace resolution
7201          61                                197       foreach my $link ( qw(parent prev_sibling next_sibling) )
7202         183                                925         { $copy->{former}->{$link}= $elt->{$link};
7203  ***    183     50                         532           if( $XML::Twig::weakrefs) { weaken( $copy->{former}->{$link}); }
             183                               1042   
7204                                                        }
7205                                                  
7206          61                                222       return $copy;
7207                                                    }
7208                                                  
7209                                                  
7210                                                  sub delete
7211        1191                 1191          2778     { my $elt= shift;
7212        1191                               3671       $elt->cut;
7213  ***   1191     50                        2968       $elt->DESTROY unless( $XML::Twig::weakrefs);
7214        1191                               2698       return undef;
7215                                                    }
7216                                                  
7217                                                  { 
7218                                                    sub DESTROY
7219       22004                22004         58660       { my $elt= shift;
7220       22004    100                       61268         return if( $XML::Twig::weakrefs);
7221  ***      4            33                   26         my $t= shift || $elt->twig; # optional argument, passed in recursive calls
7222                                                  
7223           4                                  9         foreach( @{[$elt->_children]}) { $_->DESTROY( $t); }
               4                                 14   
               2                                 10   
7224                                                  
7225                                                        # the id reference needs to be destroyed
7226                                                        # lots of tests to avoid warnings during the cleanup phase
7227  ***      4     50     33                   41         $elt->del_id( $t) if( $ID && $t && defined( $elt->{att}) && exists( $elt->{att}->{$ID}));
      ***                   33                        
      ***                   33                        
7228           4                                 14         undef $elt;
7229                                                      }
7230                                                  }
7231                                                  
7232                                                  
7233                                                  # ignores the element
7234                                                  sub ignore
7235          30                   30           121     { my $elt= shift;
7236          30                                111       my $t= $elt->twig;
7237          30                                140       $t->ignore( $elt, @_);
7238                                                    }
7239                                                  
7240                                                  BEGIN {
7241          92                   92           507     my $pretty                    = 0;
7242          92                                378     my $quote                     = '"';
7243          92                                276     my $INDENT                    = '  ';
7244          92                                239     my $empty_tag_style           = 0;
7245          92                                231     my $remove_cdata              = 0;
7246          92                                447     my $keep_encoding             = 0;
7247          92                                259     my $expand_external_entities  = 0;
7248          92                                312     my $keep_atts_order           = 0;
7249          92                                232     my $do_not_escape_amp_in_atts = 0;
7250          92                                264     my $WRAP                      = '80';
7251          92                                265     my $REPLACED_ENTS             = qq{&<};
7252                                                  
7253          92                                625     my ($NSGMLS, $NICE, $INDENTED, $INDENTEDCT, $INDENTEDC, $WRAPPED, $RECORD1, $RECORD2, $INDENTEDA)= (1..9);
7254          92                                429     my %KEEP_TEXT_TAG_ON_ONE_LINE= map { $_ => 1 } ( $INDENTED, $INDENTEDCT, $INDENTEDC, $INDENTEDA, $WRAPPED);
             460                               2129   
7255                                                  
7256          92                               2168     my %pretty_print_style=
7257                                                      ( none       => 0,          # no added \n
7258                                                        nsgmls     => $NSGMLS,    # nsgmls-style, \n in tags
7259                                                        # below this line styles are UNSAFE (the generated XML can be well-formed but invalid)
7260                                                        nice       => $NICE,      # \n after open/close tags except when the 
7261                                                                                  # element starts with text
7262                                                        indented   => $INDENTED,  # nice plus idented
7263                                                        indented_close_tag   => $INDENTEDCT,  # nice plus idented
7264                                                        indented_c => $INDENTEDC, # slightly more compact than indented (closing
7265                                                                                  # tags are on the same line)
7266                                                        wrapped    => $WRAPPED,   # text is wrapped at column 
7267                                                        record_c   => $RECORD1,   # for record-like data (compact)
7268                                                        record     => $RECORD2,   # for record-like data  (not so compact)
7269                                                        indented_a => $INDENTEDA, # nice, indented, and with attributes on separate
7270                                                                                  # lines as the nsgmls style, as well as wrapped
7271                                                                                  # lines - to make the xml friendly to line-oriented tools
7272                                                        cvs        => $INDENTEDA, # alias for indented_a
7273                                                      );
7274                                                  
7275          92                                508     my ($HTML, $EXPAND)= (1..2);
7276          92                                877     my %empty_tag_style=
7277                                                      ( normal => 0,        # <tag/>
7278                                                        html   => $HTML,    # <tag />
7279                                                        xhtml  => $HTML,    # <tag />
7280                                                        expand => $EXPAND,  # <tag></tag>
7281                                                      );
7282                                                  
7283          92                                600     my %quote_style=
7284                                                      ( double  => '"',    
7285                                                        single  => "'", 
7286                                                        # smart  => "smart", 
7287                                                      );
7288                                                  
7289          92                                190     my $xml_space_preserve; # set when an element includes xml:space="preserve"
7290                                                  
7291          92                                170     my $output_filter;      # filters the entire output (including < and >)
7292          92                                162     my $output_text_filter; # filters only the text part (tag names, attributes, pcdata)
7293                                                  
7294          92                                229     my $replaced_ents= $REPLACED_ENTS;
7295                                                  
7296                                                  
7297                                                    # returns those pesky "global" variables so you can switch between twigs 
7298                                                    sub global_state
7299                                                      { return
7300          11                   11           294          { pretty                    => $pretty,
7301                                                           quote                     => $quote,
7302                                                           indent                    => $INDENT,
7303                                                           empty_tag_style           => $empty_tag_style,
7304                                                           remove_cdata              => $remove_cdata,
7305                                                           keep_encoding             => $keep_encoding,
7306                                                           expand_external_entities  => $expand_external_entities,
7307                                                           output_filter             => $output_filter,
7308                                                           output_text_filter        => $output_text_filter,
7309                                                           keep_atts_order           => $keep_atts_order,
7310                                                           do_not_escape_amp_in_atts => $do_not_escape_amp_in_atts,
7311                                                           wrap                      => $WRAP,
7312                                                           replaced_ents             => $replaced_ents,
7313                                                          };
7314                                                      }
7315                                                  
7316                                                    # restores the global variables
7317                                                    sub set_global_state
7318          22                   22            57       { my $state= shift;
7319          22                                 79         $pretty                    = $state->{pretty};
7320          22                                 67         $quote                     = $state->{quote};
7321          22                                 63         $INDENT                    = $state->{indent};
7322          22                                 65         $empty_tag_style           = $state->{empty_tag_style};
7323          22                                 60         $remove_cdata              = $state->{remove_cdata};
7324          22                                 65         $keep_encoding             = $state->{keep_encoding};
7325          22                                 62         $expand_external_entities  = $state->{expand_external_entities};
7326          22                                 62         $output_filter             = $state->{output_filter};
7327          22                                 88         $output_text_filter        = $state->{output_text_filter};
7328          22                                 62         $keep_atts_order           = $state->{keep_atts_order};
7329          22                                 60         $do_not_escape_amp_in_atts = $state->{do_not_escape_amp_in_atts};
7330          22                                 64         $WRAP                      = $state->{wrap};
7331          22                                 91         $replaced_ents             = $state->{replaced_ents},
7332                                                      }
7333                                                  
7334                                                    # sets global state to defaults
7335                                                    sub init_global_state
7336           5                    5           783       { set_global_state(
7337                                                         { pretty                    => 0,
7338                                                           quote                     => '"',
7339                                                           indent                    => $INDENT,
7340                                                           empty_tag_style           => 0,
7341                                                           remove_cdata              => 0,
7342                                                           keep_encoding             => 0,
7343                                                           expand_external_entities  => 0,
7344                                                           output_filter             => undef,
7345                                                           output_text_filter        => undef,
7346                                                           keep_atts_order           => undef,
7347                                                           do_not_escape_amp_in_atts => 0,
7348                                                           wrap                      => $WRAP,
7349                                                           replaced_ents             => $REPLACED_ENTS,
7350                                                          });
7351                                                      }
7352                                                  
7353                                                  
7354                                                    # set the pretty_print style (in $pretty) and returns the old one
7355                                                    # can be called from outside the package with 2 arguments (elt, style)
7356                                                    # or from inside with only one argument (style)
7357                                                    # the style can be either a string (one of the keys of %pretty_print_style
7358                                                    # or a number (presumably an old value saved)
7359                                                    sub set_pretty_print
7360        1661    100          1661          6189       { my $style= lc( defined $_[1] ? $_[1] : $_[0]); # so we cover both cases 
7361        1661                               3170         my $old_pretty= $pretty;
7362        1661    100                        7233         if( $style=~ /^\d+$/)
7363        1571    100                        6328           { croak "invalid pretty print style $style" unless( $style < keys %pretty_print_style);
7364        1570                               3445             $pretty= $style;
7365                                                          }
7366                                                        else
7367          90    100                         396           { croak "invalid pretty print style '$style'" unless( exists $pretty_print_style{$style});
7368          89                                260             $pretty= $pretty_print_style{$style};
7369                                                          }
7370        1659    100    100                12773         if( ($pretty == $WRAPPED) || ($pretty == $INDENTEDA) )
7371  ***      6     50                          20           { XML::Twig::_use( 'Text::Wrap') or croak( "Text::Wrap not available, cannot use 'wrapped' style"); }
7372        1659                               6947         return $old_pretty;
7373                                                      }
7374                                                   
7375  ***      0                    0             0     sub _pretty_print { return $pretty; } 
7376                                                    
7377                                                    # set the empty tag style (in $empty_tag_style) and returns the old one
7378                                                    # can be called from outside the package with 2 arguments (elt, style)
7379                                                    # or from inside with only one argument (style)
7380                                                    # the style can be either a string (one of the keys of %empty_tag_style
7381                                                    # or a number (presumably an old value saved)
7382                                                    sub set_empty_tag_style
7383          95    100            95          1027       { my $style= lc( defined $_[1] ? $_[1] : $_[0]); # so we cover both cases 
7384          95                                204         my $old_style= $empty_tag_style;
7385          95    100                         451         if( $style=~ /^\d+$/)
7386          25    100                         117           { croak "invalid empty tag style $style"
7387                                                          unless( $style < keys %empty_tag_style);
7388          24                                 64           $empty_tag_style= $style;
7389                                                          }
7390                                                        else
7391          70    100                         364           { croak "invalid empty tag style '$style'"
7392                                                              unless( exists $empty_tag_style{$style});
7393          69                                230             $empty_tag_style= $empty_tag_style{$style};
7394                                                          }
7395          93                                276         return $old_style;
7396                                                      }
7397                                                  
7398                                                    sub _pretty_print_styles
7399  ***      0      0             0             0       { return sort { $pretty_print_style{$a} <=> $pretty_print_style{$b} || $a cmp $b } keys %pretty_print_style; }
      ***      0                                  0   
7400                                                        
7401                                                    sub set_quote
7402  ***      4            33      4            22       { my $style= $_[1] || $_[0];
7403           4                                 10         my $old_quote= $quote;
7404           4    100                          21         croak "invalid quote '$style'" unless( exists $quote_style{$style});
7405           3                                  9         $quote= $quote_style{$style};
7406           3                                 10         return $old_quote;
7407                                                      }
7408                                                      
7409                                                    sub set_remove_cdata
7410  ***   2760     50          2760          7661       { my $new_value= defined $_[1] ? $_[1] : $_[0];
7411        2760                               4713         my $old_value= $remove_cdata;
7412        2760                               4651         $remove_cdata= $new_value;
7413        2760                               7608         return $old_value;
7414                                                      }
7415                                                        
7416                                                        
7417                                                    sub set_indent
7418           5    100             5            21       { my $new_value= defined $_[1] ? $_[1] : $_[0];
7419           5                                 12         my $old_value= $INDENT;
7420           5                                  8         $INDENT= $new_value;
7421           5                                 12         return $old_value;
7422                                                      }
7423                                                  
7424                                                    sub set_wrap
7425           9    100             9            35       { my $new_value= defined $_[1] ? $_[1] : $_[0];
7426           9                                 19         my $old_value= $WRAP;
7427           9                                 18         $WRAP= $new_value;
7428           9                                 40         return $old_value;
7429                                                      }
7430                                                         
7431                                                         
7432                                                    sub set_keep_encoding
7433  ***   2764     50          2764          9062       { my $new_value= defined $_[1] ? $_[1] : $_[0];
7434        2764                               5056         my $old_value= $keep_encoding;
7435        2764                               5055         $keep_encoding= $new_value;
7436        2764                               7762         return $old_value;
7437                                                     }
7438                                                  
7439                                                    sub set_replaced_ents
7440  ***      0      0             0             0       { my $new_value= defined $_[1] ? $_[1] : $_[0];
7441  ***      0                                  0         my $old_value= $replaced_ents;
7442  ***      0                                  0         $replaced_ents= $new_value;
7443  ***      0                                  0         return $old_value;
7444                                                     }
7445                                                  
7446                                                    sub do_not_escape_gt
7447  ***      0                    0             0       { my $old_value= $replaced_ents;
7448  ***      0                                  0         $replaced_ents= q{&<}; # & needs to be first
7449  ***      0                                  0         return $old_value;
7450                                                      }
7451                                                  
7452                                                    sub escape_gt
7453  ***      0                    0             0       { my $old_value= $replaced_ents;
7454  ***      0                                  0         $replaced_ents= qq{&<>}; # & needs to be first
7455  ***      0                                  0         return $old_value;
7456                                                      }
7457                                                  
7458          81                   81           734     sub _keep_encoding { return $keep_encoding; } # so I can use elsewhere in the module
7459                                                  
7460                                                    sub set_do_not_escape_amp_in_atts
7461  ***   2770     50          2770          8398       { my $new_value= defined $_[1] ? $_[1] : $_[0];
7462        2770                               4983         my $old_value= $do_not_escape_amp_in_atts;
7463        2770                               4708         $do_not_escape_amp_in_atts= $new_value;
7464        2770                               6761         return $old_value;
7465                                                     }
7466                                                  
7467         119                  119           425     sub output_filter      { return $output_filter; }
7468           2                    2             9     sub output_text_filter { return $output_text_filter; }
7469                                                  
7470                                                    sub set_output_filter
7471  ***   2783     50          2783          8506       { my $new_value= defined $_[1] ? $_[1] : $_[0]; # can be called in object/non-object mode
7472                                                        # if called in object mode with no argument, the filter is undefined
7473  ***   2783    100     66                30144         if( isa( $new_value, 'XML::Twig::Elt') || isa( $new_value, 'XML::Twig')) { undef $new_value; }
               1                                  3   
7474        2783                               5543         my $old_value= $output_filter;
7475        2783    100    100                10266         if( !$new_value || isa( $new_value, 'CODE') )
                    100                               
                    100                               
7476        2776                               5780           { $output_filter= $new_value; }
7477                                                        elsif( $new_value eq 'latin1')
7478           1                                  4           { $output_filter= XML::Twig::latin1();
7479                                                          }
7480                                                        elsif( $XML::Twig::filter{$new_value})
7481           5                                 17           {  $output_filter= $XML::Twig::filter{$new_value}; }
7482                                                        else
7483           1                                  6           { croak "invalid output filter '$new_value'"; }
7484                                                        
7485        2782                               8507         return $old_value;
7486                                                      }
7487                                                         
7488                                                    sub set_output_text_filter
7489        2769    100          2769          7650       { my $new_value= defined $_[1] ? $_[1] : $_[0]; # can be called in object/non-object mode
7490                                                        # if called in object mode with no argument, the filter is undefined
7491  ***   2769    100     66                26868         if( isa( $new_value, 'XML::Twig::Elt') || isa( $new_value, 'XML::Twig')) { undef $new_value; }
               1                                  4   
7492        2769                               5212         my $old_value= $output_text_filter;
7493        2769    100    100                10012         if( !$new_value || isa( $new_value, 'CODE') )
      ***            50                               
                    100                               
7494        2761                               5596           { $output_text_filter= $new_value; }
7495                                                        elsif( $new_value eq 'latin1')
7496  ***      0                                  0           { $output_text_filter= XML::Twig::latin1();
7497                                                          }
7498                                                        elsif( $XML::Twig::filter{$new_value})
7499           7                                 22           {  $output_text_filter= $XML::Twig::filter{$new_value}; }
7500                                                        else
7501           1                                  6           { croak "invalid output text filter '$new_value'"; }
7502                                                        
7503        2768                               7893         return $old_value;
7504                                                      }
7505                                                         
7506                                                    sub set_expand_external_entities
7507        2771    100          2771         10394       { my $new_value= defined $_[1] ? $_[1] : $_[0];
7508        2771                               5767         my $old_value= $expand_external_entities;
7509        2771                               5075         $expand_external_entities= $new_value;
7510        2771                               8666         return $old_value;
7511                                                      }
7512                                                         
7513                                                    sub set_keep_atts_order
7514  ***   2761     50          2761          8233       { my $new_value= defined $_[1] ? $_[1] : $_[0];
7515        2761                               4818         my $old_value= $keep_atts_order;
7516        2761                               4919         $keep_atts_order= $new_value;
7517        2761                               7577         return $old_value;
7518                                                      
7519                                                     }
7520                                                  
7521       10471                10471         38397     sub keep_atts_order { return $keep_atts_order; } # so I can use elsewhere in the module
7522                                                  
7523          92                                214     my %html_empty_elt;
7524          92                   92           925     BEGIN { %html_empty_elt= map { $_ => 1} qw( base meta link hr br param img area input col); }
             920                               4606   
7525                                                  
7526                                                    sub start_tag
7527        4415                 4415         14814       { my( $elt, $option)= @_;
7528                                                    
7529        4415    100                       20193         return if( $elt->{gi} < $XML::Twig::SPECIAL_GI);
7530                                                  
7531        4414           100                30023         my $extra_data= $elt->{extra_data} || '';
7532                                                  
7533        4414                              17835         my $gi= $XML::Twig::index2gi[$elt->{'gi'}];
7534        4414                              13111         my $att= $elt->{att}; # should be $elt->atts, optimized into a pure hash look-up
7535                                                  
7536  ***   4414     50                       14486         my $ns_map= $att ? $att->{'#original_gi'} : '';
7537        4414    100                       10608         if( $ns_map) { $gi= _restore_original_prefix( $ns_map, $gi); }
              11                                 34   
7538        4414                               9280         $gi=~ s{^#default:}{}; # remove default prefix
7539                                                   
7540        4414    100                       11075         if( $output_text_filter) { $gi= $output_text_filter->( $gi); }
              17                                184   
7541                                                    
7542                                                        # get the attribute and their values
7543        4414    100                       19820         my $att_sep = $pretty==$NSGMLS    ? "\n"
                    100                               
7544                                                                    : $pretty==$INDENTEDA ? "\n" . $INDENT x ($elt->level+1) . '  '
7545                                                                    :                       ' '
7546                                                                    ;
7547                                                  
7548        4414                               8609         my $replace_in_att_value= $replaced_ents;
7549  ***   4414    100     66                18278         if( $option->{escape_gt} && $replaced_ents !~ m{>}) { $replace_in_att_value.= '>'; }
              37                                 91   
7550                                                  
7551        4414                               6119         my $tag;
7552  ***   4414    100     66                11768         my @att_names= grep { !( (substr( $_, 0, 1) eq '#') && (substr( $_, 0, 9) ne '#default:') ) } $keep_atts_order ?  keys %{$att} : sort keys %{$att};
            1188                               8634   
              51                                135   
            4363                              28327   
7553        4414    100                       12743         if( @att_names)
7554         664    100                        1750           { my $atts= join $att_sep, map  { my $output_att_name= $ns_map ? _restore_original_prefix( $ns_map, $_) : $_;
            1171                               3319   
7555        1171    100                        2875                                             if( $output_text_filter)
7556           4                                 11                                               { $output_att_name=  $output_text_filter->( $output_att_name); }
7557        1171                               5573                                             sprintf( "%s=%s%s%s", $output_att_name, 
7558                                                                                                                  $quote,
7559                                                                                                                   _att_xml_string( $att->{$_}, $replace_in_att_value), 
7560                                                                                                                   $quote
7561                                                                                                   );
7562                                                                                          } 
7563                                                                                          @att_names
7564                                                                                     ;
7565         664    100    100                 3364              if( $pretty==$INDENTEDA && @att_names == 1) { $att_sep= ' '; }
               1                                  2   
7566         664                               2850              $tag= "<$gi$att_sep$atts";
7567                                                          }
7568                                                        else
7569        3750                               9745           { $tag= "<$gi"; }
7570                                                    
7571        4414    100                       13377         $tag .= "\n" if($pretty==$NSGMLS);
7572                                                  
7573                                                        # force empty if suitable HTML tag, otherwise use the value from the input tree
7574        4414    100    100                24630         if( ($empty_tag_style eq $HTML) && !$elt->{first_child} && !$elt->_extra_data_before_end_tag && $html_empty_elt{$gi})
      ***                   66                        
                           100                        
7575          21                                 72           { $elt->{empty}= 1; }
7576                                                  
7577  ***   4414    100     66                28909         $tag .= (!$elt->{empty} || $elt->_extra_data_before_end_tag)  ? '>'            # element has content
                    100    100                        
                    100    100                        
      ***           100     66                        
                    100                               
7578                                                              : (($empty_tag_style eq $HTML) && $html_empty_elt{$gi}) ? ' />'          # html empty element 
7579                                                                                                                                       # cvs-friendly format
7580                                                              : ( $pretty == $INDENTEDA && @att_names > 1)            ? "\n" .  $INDENT x $elt->level . "/>"  
7581                                                              : ( $pretty == $INDENTEDA && @att_names == 1)           ? " />"  
7582                                                              : $empty_tag_style                                      ? "></" . $XML::Twig::index2gi[$elt->{'gi'}] . ">" # $empty_tag_style is $HTML or $EXPAND
7583                                                              :                                                         '/>'
7584                                                              ;
7585                                                  
7586  ***   4414    100     66                30766         if( ( (substr( $XML::Twig::index2gi[$elt->{'gi'}], 0, 1) eq '#') && (substr( $XML::Twig::index2gi[$elt->{'gi'}], 0, 9) ne '#default:') )) { $tag= ''; }
               3                                  7   
7587                                                  
7588  ***   4414     50                       12205         unless( $pretty) { return defined( $extra_data) ? $extra_data . $tag : $tag;  }
            4194    100                       23504   
7589                                                  
7590         220                                437         my $prefix='';
7591         220                                403         my $return='';   # '' or \n is to be printed before the tag
7592         220                                370         my $indent=0;    # number of indents before the tag
7593                                                  
7594         220    100                        2706         if( $pretty==$RECORD1)
                    100                               
                    100                               
                    100                               
7595          29                                 93           { my $level= $elt->level;
7596          29    100                          87             $return= "\n" if( $level < 2);
7597          29    100                          88             $indent= 1 if( $level == 1);
7598                                                          }
7599                                                  
7600                                                       elsif( $pretty==$RECORD2)
7601           4                                 10           { $return= "\n";
7602           4                                 15             $indent= $elt->level;
7603                                                          }
7604                                                  
7605                                                        elsif( $pretty==$NICE)
7606           3                                 10           { my $parent= $elt->{parent};
7607  ***      3    100     66                   25             unless( !$parent || $parent->{contains_text}) 
7608           2                                  6               { $return= "\n"; }
7609  ***      3    100     66                   32             $elt->{contains_text}= 1 if( ($parent && $parent->{contains_text})
      ***                   66                        
7610                                                                                       || $elt->contains_text);
7611                                                          }
7612                                                  
7613                                                        elsif( $KEEP_TEXT_TAG_ON_ONE_LINE{$pretty})
7614         179                                646           { my $parent= $elt->{parent};
7615  ***    179    100     66                 1289             unless( !$parent || $parent->{contains_text}) 
7616         132                                267               { $return= "\n"; 
7617         132                                415                 $indent= $elt->level; 
7618                                                              }
7619  ***    179    100     66                 1716             $elt->{contains_text}= 1 if( ($parent && $parent->{contains_text})
      ***                   66                        
7620                                                                                       || $elt->contains_text);
7621                                                          }
7622                                                  
7623  ***    220    100     66                 1226         if( $return || $indent)
7624                                                          { # check for elements in which spaces should be kept
7625         149                                507             my $t= $elt->twig;
7626  ***    149     50                         407             return $extra_data . $tag if( $xml_space_preserve);
7627  ***    149    100     66                 1137             if( $t && $t->{twig_keep_spaces_in})
7628           3                                 13               { foreach my $ancestor ($elt->ancestors)
7629  ***      3     50                          26                   { return $extra_data . $tag if( $t->{twig_keep_spaces_in}->{$XML::Twig::index2gi[$ancestor->{'gi'}]}) }
7630                                                              }
7631                                                          
7632         149                                808             $prefix= $INDENT x $indent;
7633         149    100                         394             if( $extra_data)
7634           5                                 64               { $extra_data=~ s{\s+$}{};
7635           5                                 23                 $extra_data=~ s{^\s+}{};
7636           5                                 29                 $extra_data= $prefix .  $extra_data . $return;
7637                                                              }
7638                                                          }
7639                                                  
7640                                                  
7641         220                               1505         return $return . $extra_data . $prefix . $tag;
7642                                                      }
7643                                                    
7644                                                    sub end_tag
7645        4364                 4364         10267       { my $elt= shift;
7646        4364    100    100                58444         return  '' if(    ($elt->{gi}<$XML::Twig::SPECIAL_GI) 
      ***                   66                        
      ***                   66                        
7647                                                                       || (($elt->{'empty'} || 0) && !$elt->_extra_data_before_end_tag)
7648                                                                     );
7649        3334                               7329         my $tag= "<";
7650        3334                              11925         my $gi= $XML::Twig::index2gi[$elt->{'gi'}];
7651                                                  
7652        3334    100                       14075         if( my $map= $elt->{'att'}->{'#original_gi'}) { $gi= _restore_original_prefix( $map, $gi); }
              11                                 33   
7653        3334                               6676         $gi=~ s{^#default:}{}; # remove default prefix
7654                                                  
7655        3334    100                        7128         if( $output_text_filter) { $gi= $output_text_filter->( $XML::Twig::index2gi[$elt->{'gi'}]); } 
              16                                 74   
7656        3334                              12888         $tag .=  "/$gi>";
7657                                                  
7658        3334           100                11406         $tag = ($elt->_extra_data_before_end_tag || '') . $tag;
7659                                                  
7660  ***   3334    100     66                23668         if( ( (substr( $XML::Twig::index2gi[$elt->{'gi'}], 0, 1) eq '#') && (substr( $XML::Twig::index2gi[$elt->{'gi'}], 0, 9) ne '#default:') )) { $tag= ''; }
               3                                  8   
7661                                                  
7662        3334    100                       14151         return $tag unless $pretty;
7663                                                  
7664         123                                255         my $prefix='';
7665         123                                279         my $return=0;    # 1 if a \n is to be printed before the tag
7666         123                                219         my $indent=0;    # number of indents before the tag
7667                                                  
7668         123    100                         687         if( $pretty==$RECORD1)
                    100                               
                    100                               
                    100                               
7669          29    100                          84           { $return= 1 if( $elt->level == 0);
7670                                                          }
7671                                                  
7672                                                       elsif( $pretty==$RECORD2)
7673           4    100                          15           { unless( $elt->contains_text)
7674           2                                  5               { $return= 1 ;
7675           2                                  7                 $indent= $elt->level;
7676                                                              }
7677                                                          }
7678                                                  
7679                                                        elsif( $pretty==$NICE)
7680           3                                 10           { my $parent= $elt->{parent};
7681  ***      3    100     66                   55             if( (    ($parent && !$parent->{contains_text}) || !$parent )
      ***                   66                        
      ***                   33                        
      ***                   66                        
      ***                   66                        
7682                                                              && ( !$elt->{contains_text}  
7683                                                               && ($elt->{has_flushed_child} || $elt->_first_child())           
7684                                                             )
7685                                                           )
7686           1                                  3               { $return= 1; }
7687                                                          }
7688                                                  
7689                                                        elsif( $KEEP_TEXT_TAG_ON_ONE_LINE{$pretty})
7690          83                                254           { my $parent= $elt->{parent};
7691  ***     83    100     66                 1400             if( (    ($parent && !$parent->{contains_text}) || !$parent )
      ***                   66                        
                           100                        
                           100                        
      ***                   66                        
7692                                                              && ( !$elt->{contains_text}  
7693                                                               && ($elt->{has_flushed_child} || $elt->_first_child())           
7694                                                             )
7695                                                           )
7696          40                                 78               { $return= 1; 
7697          40                                115                 $indent= $elt->level; 
7698                                                              }
7699                                                          }
7700                                                  
7701  ***    123    100     66                  780         if( $return || $indent)
7702                                                          { # check for elements in which spaces should be kept
7703          45                                127             my $t= $elt->twig;
7704  ***     45     50                         138             return $tag if( $xml_space_preserve);
7705  ***     45    100     66                  374             if( $t && $t->{twig_keep_spaces_in})
7706           1                                  5               { foreach my $ancestor ($elt, $elt->ancestors)
7707  ***      1     50                          11                   { return $tag if( $t->{twig_keep_spaces_in}->{$XML::Twig::index2gi[$ancestor->{'gi'}]}) }
7708                                                              }
7709                                                        
7710  ***     45     50                         164             if( $return) { $prefix= ($pretty== $INDENTEDCT) ? "\n$INDENT" : "\n"; }
      ***     45     50                         176   
7711          45                                136             $prefix.= $INDENT x $indent;
7712                                                      }
7713                                                  
7714                                                        # add a \n at the end of the document (after the root element)
7715         123    100                         548         $tag .= "\n" unless( $elt->{parent});
7716                                                    
7717         123                                686         return $prefix . $tag;
7718                                                      }
7719                                                  
7720                                                    sub _restore_original_prefix
7721          33                   33           130       { my( $map, $name)= @_;
7722          33                                103         my $prefix= _ns_prefix( $name);
7723          33    100                         235         if( my $original_prefix= $map->{$prefix})
7724          26    100                          77           { if( $original_prefix eq '#default')
7725           8                                 70               { $name=~ s{^$prefix:}{}; }
7726                                                            else
7727          18                                273               { $name=~ s{^$prefix(?=:)}{$original_prefix}; }
7728                                                          }
7729          33                                134         return $name;
7730                                                      }
7731                                                  
7732                                                    # buffer used to hold the text to print/sprint, to avoid passing it back and forth between methods
7733          92                                200     my @sprint;
7734                                                  
7735                                                    # $elt is an element to print
7736                                                    # $fh is an optional filehandle to print to
7737                                                    # $pretty is an optional value, if true a \n is printed after the < of the
7738                                                    # opening tag
7739                                                    sub print
7740          43                   43           210       { my $elt= shift;
7741                                                    
7742          43                                 70         my $pretty;
7743          43    100                         179         my $fh= _is_fh( $_[0]) ? shift : undef;
7744          43    100                         211         my $old_select= defined $fh ? select $fh : undef;
7745          43    100                         184         my $old_pretty= defined ($pretty= shift) ? set_pretty_print( $pretty) : undef;
7746          43           100                  159         $pretty ||=0;
7747  ***     43            66                  382         $pretty = $pretty_print_style{$pretty} || $pretty;
7748                                                  
7749  ***     43            50                  578         $xml_space_preserve= ( ($elt->inherit_att( 'xml:space') || '') eq 'preserve');
7750                                                   
7751                                                        #$elt->_print;       # no need to duplicate logic in _sprint
7752                                                        #print $elt->sprint; # but that's too slow
7753                                                  
7754          43                                191         @sprint=();
7755          43                                192         $elt->_sprint(@_);
7756  ***     43     50     33                  655         if( $output_filter || ((($pretty== $WRAPPED) || ($pretty==$INDENTEDC)) && !$xml_space_preserve))
      ***                   33                        
      ***                   33                        
7757  ***      0                                  0           { my $sprint= join( '', @sprint);
7758  ***      0      0                           0             if( $output_filter) { $sprint= $output_filter->( $sprint); }
      ***      0                                  0   
7759                                                  
7760  ***      0      0      0                    0             if( ( ($pretty== $WRAPPED) || ($pretty==$INDENTEDC)) && !$xml_space_preserve)
      ***                    0                        
7761  ***      0                                  0               { $sprint= _wrap_text( $sprint); }
7762                                                  
7763  ***      0                                  0             print $sprint;
7764                                                          }
7765                                                        else
7766          43                                450           { print @sprint; }
7767                                                  
7768          43                                360         $xml_space_preserve= 0;
7769                                                      
7770          43    100                         181         select $old_select if( defined $old_select);
7771          43    100                         214         set_pretty_print( $old_pretty) if( defined $old_pretty);
7772                                                      }
7773                                                        
7774                                                    
7775                                                    # same as print but does not output the start tag if the element
7776                                                    # is marked as flushed
7777                                                    sub flush 
7778          14                   14            90       { my $elt= shift; 
7779  ***     14     50     66                   99         my $up_to= $_[0] && isa( $_[0], 'XML::Twig::Elt') ? shift : $elt;
7780          14                                151         $elt->twig->flush_up_to( $up_to, @_); 
7781                                                      }
7782                                                    sub purge
7783           4                    4            16       { my $elt= shift; 
7784  ***      4    100     66                   40         my $up_to= $_[0] && isa( $_[0], 'XML::Twig::Elt') ? shift : $elt;
7785           4                                 17         $elt->twig->purge_up_to( $up_to, @_); 
7786                                                      }
7787                                                    
7788                                                    sub _flush
7789        1689                 1689          4015       { my $elt= shift;
7790                                                    
7791        1689                               2281         my $pretty;
7792  ***   1689     50                        5786         my $fh=  _is_fh( $_[0]) ? shift : undef;
7793  ***   1689     50                        5762         my $old_select= defined $fh ? select $fh : undef;
7794        1689    100                        7899         my $old_pretty= defined ($pretty= shift) ? set_pretty_print( $pretty) : undef;
7795                                                  
7796  ***   1689     50     50                 5489         $xml_space_preserve= 1 if( ($elt->inherit_att( 'xml:space') || '') eq 'preserve');
7797                                                  
7798        1689                               5521         $elt->__flush();
7799                                                  
7800        1689                              16810         $xml_space_preserve= 0;
7801                                                  
7802  ***   1689     50                        4563         select $old_select if( defined $old_select);
7803        1689    100                        6139         set_pretty_print( $old_pretty) if( defined $old_pretty);
7804                                                      }
7805                                                  
7806                                                    sub __flush
7807        1689                 1689          4093       { my $elt= shift;
7808                                                    
7809        1689    100                        7255         if( $elt->{gi} >= $XML::Twig::SPECIAL_GI)
7810  ***   1214            50                 9686           { my $preserve= ($elt->{'att'}->{'xml:space'} || '') eq 'preserve';
7811  ***   1214     50                        3008             $xml_space_preserve++ if $preserve;
7812        1214    100                        3222             unless( $elt->_flushed)
7813        1202                               4051               { print $elt->start_tag();
7814                                                              }
7815                                                        
7816                                                            # flush the children
7817        1214                              39494             my @children= $elt->_children;
7818        1214                               3995             foreach my $child (@children)
7819         769                               2964               { $child->_flush( $pretty); }
7820  ***   1214     50                        5447             unless( $elt->{end_tag_flushed}) { print $elt->end_tag; }
            1214                               4071   
7821  ***   1214     50                       37010             $xml_space_preserve-- if $preserve;
7822                                                            # used for pretty printing
7823        1214    100                        6733             if( my $parent= $elt->{parent}) { $parent->{has_flushed_child}= 1; }
             337                               1694   
7824                                                          }
7825                                                        else # text or special element
7826         475                                708           { my $text;
7827         475    100                        2267             if( (exists $elt->{'pcdata'}))     { $text= $elt->pcdata_xml_string; 
             325    100                        1033   
                    100                               
      ***            50                               
      ***             0                               
7828  ***    325     50                        1553                                        if( my $parent= $elt->{parent}) 
7829         325                               1456                                          { $parent->{contains_text}= 1; }
7830                                                                                     }
7831           2                                 11             elsif( (exists $elt->{'cdata'}))   { $text= $elt->cdata_string;        
7832  ***      2     50                          13                                        if( my $parent= $elt->{parent}) 
7833           2                                 10                                          { $parent->{contains_text}= 1; }
7834                                                                                     }
7835           2                                 10             elsif( (exists $elt->{'target'}))      { $text= $elt->pi_string;          }
7836         146                                425             elsif( (exists $elt->{'comment'})) { $text= $elt->comment_string;     }
7837  ***      0                                  0             elsif( (exists $elt->{'ent'}))     { $text= $elt->ent_string;         }
7838                                                  
7839  ***    475     50                        1552             print $output_filter ? $output_filter->( $text) : $text;
7840                                                          }
7841                                                      }
7842                                                    
7843                                                  
7844                                                    sub xml_text
7845          26                   26           121       { my( $elt, @options)= @_;
7846                                                  
7847  ***     26    100     66                  109         if( @options && grep { lc( $_) eq 'no_recurse' } @options) { return $elt->xml_text_only; }
               1                                  9   
               1                                  4   
7848                                                  
7849          25                                 56         my $string='';
7850                                                  
7851          25    100                         155         if( ($elt->{gi} >= $XML::Twig::SPECIAL_GI) )
                    100                               
                    100                               
      ***            50                               
7852                                                          { # sprint the children
7853           9           100                   47             my $child= $elt->{first_child} || '';
7854           9                                 31             while( $child)
7855          14                                 61               { $string.= $child->xml_text;
7856          14                                 77               } continue { $child= $child->{next_sibling}; }
7857                                                          }
7858          13    100                          91         elsif( (exists $elt->{'pcdata'}))  { $string .= $output_filter ?  $output_filter->($elt->pcdata_xml_string) 
7859                                                                                                             : $elt->pcdata_xml_string; 
7860                                                                                 }
7861  ***      1     50                           7         elsif( (exists $elt->{'cdata'}))   { $string .= $output_filter ?  $output_filter->($elt->cdata_string)  
7862                                                                                                             : $elt->cdata_string;      
7863                                                                                 }
7864           2                                  8         elsif( (exists $elt->{'ent'}))     { $string .= $elt->ent_string; }
7865                                                  
7866          25                                149         return $string;
7867                                                      }
7868                                                  
7869                                                    sub xml_text_only
7870           1    100    100      1             6       { return join '', map { $_->xml_text if( $_->is_text || (exists $_->{'ent'})) } $_[0]->_children; }
               5                                 15   
7871                                                  
7872                                                    # same as print but except... it does not print but rather returns the string
7873                                                    # if the second parameter is set then only the content is returned, not the
7874                                                    # start and end tags of the element (but the tags of the included elements are
7875                                                    # returned)
7876                                                  
7877                                                    sub sprint
7878        3104                 3104          8360       { my $elt= shift;
7879        3104                               6081         my( $old_pretty, $old_empty_tag_style);
7880                                                  
7881        3104    100    100                20970         if( $_[0] && isa( $_[0], 'HASH'))
7882           6                                 13           { my %args= XML::Twig::_normalize_args( %{shift()}); 
               6                                 32   
7883           6    100                          34             if( defined $args{PrettyPrint}) { $old_pretty          = set_pretty_print( $args{PrettyPrint});  }
               3                                 14   
7884           6    100                          28              if( defined $args{EmptyTags})  { $old_empty_tag_style = set_empty_tag_style( $args{EmptyTags}); }
               3                                 13   
7885                                                          }
7886                                                  
7887        3104    100    100                10706         $xml_space_preserve= 1 if( ($elt->inherit_att( 'xml:space') || '') eq 'preserve');
7888                                                  
7889        3104                               9528         @sprint=();
7890        3104                              11715         $elt->_sprint( @_);
7891        3104                              12932         my $sprint= join( '', @sprint);
7892        3104    100                        7970         if( $output_filter) { $sprint= $output_filter->( $sprint); }
              23                                 85   
7893                                                  
7894  ***   3104    100     66                26594         if( ( ($pretty== $WRAPPED) || ($pretty==$INDENTEDC)) && !$xml_space_preserve)
      ***                   66                        
7895           5                                 11           { $sprint= _wrap_text( $sprint); }
7896        3104                               5753         $xml_space_preserve= 0;
7897                                                  
7898                                                  
7899        3104    100                        8297         if( defined $old_pretty)          { set_pretty_print( $old_pretty);             } 
               3                                 10   
7900        3104    100                        7628         if( defined $old_empty_tag_style) { set_empty_tag_style( $old_empty_tag_style); }
               3                                  9   
7901                                                  
7902        3104                              17735         return $sprint;
7903                                                      }
7904                                                    
7905                                                    sub _wrap_text
7906           5                    5            22       { my( $string)= @_;
7907           5                                  9         my $wrapped;
7908           5                                 70         foreach my $line (split /\n/, $string)
7909          19                                114           { my( $initial_indent)= $line=~ m{^(\s*)};
7910          19                                104             my $wrapped_line= Text::Wrap::wrap(  '',  $initial_indent . $INDENT, $line) . "\n";
7911                                                            
7912                                                            # fix glitch with Text::wrap when the first line is long and does not include spaces
7913                                                            # the first line ends up being too short by 2 chars, but we'll have to live with it!
7914          19                                 90             $wrapped_line=~ s{^ +\n  }{}s; # this prefix needs to be removed
7915                                                        
7916          19                                 68             $wrapped .= $wrapped_line;
7917                                                          }
7918                                                       
7919           5                                 29         return $wrapped;
7920                                                      }
7921                                                        
7922                                                    
7923                                                    sub _sprint
7924        9295                 9295         21069       { my $elt= shift;
7925        9295           100                56586         my $no_tag= shift || 0;
7926                                                        # in case there's some comments or PI's piggybacking
7927                                                  
7928        9295    100                       38440         if( $elt->{gi} >= $XML::Twig::SPECIAL_GI)
7929                                                          {
7930        4711           100                36373             my $preserve= ($elt->{'att'}->{'xml:space'} || '') eq 'preserve';
7931        4711    100                       12343             $xml_space_preserve++ if $preserve;
7932                                                  
7933        4711    100                       18365             push @sprint, $elt->start_tag unless( $no_tag);
7934                                                        
7935                                                            # sprint the children
7936        4711                              16079             my $child= $elt->{first_child};
7937        4711                              13857             while( $child)
7938        6148                              19314               { $child->_sprint;
7939        6148                              31350                 $child= $child->{next_sibling};
7940                                                              }
7941        4711    100                       19095             push @sprint, $elt->end_tag unless( $no_tag);
7942        4711    100                       13746             $xml_space_preserve-- if $preserve;
7943                                                          }
7944                                                        else
7945        4584    100                       17385           { push @sprint, $elt->{extra_data} if( $elt->{extra_data}) ;
7946        4584    100                       23524             if(    (exists $elt->{'pcdata'}))  { push @sprint, $elt->pcdata_xml_string; }
            1421    100                        5149   
                    100                               
                    100                               
      ***            50                               
7947          45                                179             elsif( (exists $elt->{'cdata'}))   { push @sprint, $elt->cdata_string;      }
7948        1460                               5046             elsif( (exists $elt->{'target'}))      { push @sprint, $elt->pi_string;
7949  ***   1460     50     66                 6208                                        if( ($pretty >= $INDENTED) && !$elt->{parent}->{contains_text}) { push @sprint, "\n"; }
      ***      0                                  0   
7950                                                                                     }
7951        1616                               5370             elsif( (exists $elt->{'comment'})) { push @sprint, $elt->comment_string;    
7952  ***   1616     50     66                 7629                                        if( ($pretty >= $INDENTED) && !$elt->{parent}->{contains_text}) { push @sprint, "\n"; }
      ***      0                                  0   
7953                                                                                     }
7954          42                                149             elsif( (exists $elt->{'ent'}))     { push @sprint, $elt->ent_string;        }
7955                                                          }
7956                                                  
7957        9295                              19961         return;
7958                                                      }
7959                                                  
7960                                                    # just a shortcut to $elt->sprint( 1)
7961                                                    sub xml_string
7962        1558                 1558          3998       { my $elt= shift;
7963        1558    100                       12493         isa( $_[0], 'HASH') ?  $elt->sprint( shift(), 1) : $elt->sprint( 1);
7964                                                      }
7965                                                  
7966                                                    sub pcdata_xml_string 
7967        1760                 1760          4002       { my $elt= shift;
7968        1760    100                        7473         if( defined( my $string= $elt->{pcdata}) )
7969                                                          { 
7970        1759    100                        5702             if( $elt->_extra_data_in_pcdata)
7971          83                                248               { _gen_mark( $string); # used by _(un)?protect_extra_data
7972          83                                133                 foreach my $data (reverse @{$elt->_extra_data_in_pcdata})
              83                                293   
7973         118                                622                   { my $substr= substr( $string, $data->{offset});
7974  ***    118    100     66                  872                     if( $keep_encoding || $elt->{asis})
7975          30                                179                       { substr( $string, $data->{offset}, 0, $data->{text}); }
7976                                                                    else
7977          88                                499                       { substr( $string, $data->{offset}, 0, _protect_extra_data( $data->{text})); }
7978                                                                  }
7979  ***     83    100     66                  785                 unless( $keep_encoding || $elt->{asis})
7980                                                                  { 
7981          63                                468                     $string=~ s{([$replaced_ents])}{$XML::Twig::base_ent{$1}}g ;
7982          63                                192                     $string=~ s{\Q]]>}{]]&gt;}g;
7983          63                                183                     _unprotect_extra_data( $string);
7984                                                                  }
7985                                                              }
7986                                                            else
7987                                                              { 
7988        1676    100    100                17457                 $string=~ s/([$replaced_ents])/$XML::Twig::base_ent{$1}/g unless( $keep_encoding || $elt->{asis});  
7989        1676                               5115                 $string=~ s{\Q]]>}{]]&gt;}g;
7990                                                              }
7991        1759    100                        9361             return $output_text_filter ? $output_text_filter->( $string) : $string;
7992                                                          }
7993                                                        else
7994           1                                  7           { return ''; }
7995                                                      }
7996                                                  
7997          92                                227     { my $mark;
              92                                401   
7998          92                               1344       my( %char2ent, %ent2char);
7999                                                      BEGIN
8000          92                   92          1016         { %char2ent= ( '<' => 'lt', '&' => 'amp', '>' => 'gt');
8001          92                                577           %ent2char= map { $char2ent{$_} => $_ } keys %char2ent;
             276                               1789   
8002                                                        }
8003                                                  
8004                                                      # generate a unique mark (a string) not found in the string, 
8005                                                      # used to mark < and & in the extra data
8006                                                      sub _gen_mark
8007          83                   83           173         { $mark="AAAA";
8008          83                                457           $mark++ while( index( $_[0], $mark) > -1);
8009          83                                175           return $mark;
8010                                                        }
8011                                                        
8012                                                      sub _protect_extra_data
8013          88                   88           338         { my( $extra_data)= @_;
8014          88                               2136           $extra_data=~ s{([<&>])}{:$mark:$char2ent{$1}:}g;
8015          88                                682           return $extra_data;
8016                                                        }
8017                                                  
8018                                                      sub _unprotect_extra_data
8019          63                   63          1987         { $_[0]=~ s{:$mark:(\w+):}{$ent2char{$1}}g; }
8020                                                  
8021                                                    } 
8022                                                    
8023                                                    sub cdata_string
8024          50                   50           208       { my $cdata= $_[0]->{cdata};
8025          50    100                         152         unless( defined $cdata) { return ''; }
               1                                  6   
8026          49    100                         125         if( $remove_cdata)
8027           1                                 45           { $cdata=~ s/([$replaced_ents])/$XML::Twig::base_ent{$1}/g; }
8028                                                        else
8029          48                                227           { $cdata= CDATA_START . $cdata . CDATA_END; }
8030          49                                200         return $cdata;
8031                                                     }
8032                                                  
8033                                                    sub att_xml_string 
8034           1                    1             4       { my $elt= shift;
8035           1                                  3         my $att= shift;
8036                                                  
8037           1                                  5         my $replace= $replaced_ents . $quote;
8038  ***      1     50     33                   10         if($_[0] && $_[0]->{escape_gt} && ($replace!~ m{>}) ) { $replace .='>'; }
      ***      0            33                    0   
8039                                                  
8040  ***      1     50                           8         if( defined (my $string= $elt->{att}->{$att}))
8041  ***      0                                  0           { return _att_xml_string( $string, $replace); }
8042                                                        else
8043           1                                  6           { return ''; }
8044                                                      }
8045                                                      
8046                                                    # escaped xml string for an attribute value
8047                                                    sub _att_xml_string 
8048        1171                 1171          4285       { my( $string, $escape)= @_;
8049        1171    100                        4597         if( !defined( $string)) { return ''; }
               1                                 10   
8050        1170    100                        2955         unless( $keep_encoding)
8051                                                          { 
8052         994    100                        1983             if( $do_not_escape_amp_in_atts)
8053           3                                 11               { $escape=~ s{^.}{}; # seems like the most backward compatible way to remove & from the list
8054           3                                 35                 $string=~ s{([$escape])}{$XML::Twig::base_ent{$1}}g; 
8055           3                                 12                 $string=~ s{&(?!(\w+|#\d+|[xX][0-9a-fA-F]+);)}{&amp;}g; # dodgy: escape & that do not start an entity
8056                                                              }
8057                                                            else
8058         991                               5505               { $string=~ s{([$escape])}{$XML::Twig::base_ent{$1}}g; 
8059         991                               2798                 $string=~ s{\Q]]>}{]]&gt;}g;
8060                                                              }
8061                                                          }
8062                                                  
8063        1170    100                       10172         return $output_text_filter ? $output_text_filter->( $string) : $string;
8064                                                      }
8065                                                  
8066                                                    sub ent_string 
8067          44                   44           100       { my $ent= shift;
8068          44                                137         my $ent_text= $ent->{ent};
8069          44                                 95         my( $t, $el, $ent_string);
8070  ***     44    100     66                  260         if(    $expand_external_entities
      ***                   66                        
      ***                   66                        
8071                                                            && ($t= $ent->twig) 
8072                                                            && ($el= $t->entity_list)
8073                                                            && ($ent_string= $el->{entities}->{$ent->ent_name}->{val})
8074                                                          )
8075           9                                 38           { return $ent_string; }
8076                                                         else
8077          35                                144            { return $ent_text;  }
8078                                                      }
8079                                                  
8080                                                    # returns just the text, no tags, for an element
8081                                                    sub text
8082        2801                 2801         11726       { my( $elt, @options)= @_;
8083                                                  
8084  ***   2801    100     66                10022         if( @options && grep { lc( $_) eq 'no_recurse' } @options) { return $elt->text_only; }
               2                                 19   
               2                                  8   
8085                                                   
8086        2799                               4239         my $string;
8087                                                    
8088        2799    100                       14969         if( (exists $elt->{'pcdata'}))     { return  $elt->{pcdata};   }
            1619    100                        8316   
                    100                               
                    100                               
                    100                               
8089          12                                 97         elsif( (exists $elt->{'cdata'}))   { return  $elt->{cdata};    }
8090           2                                  6         elsif( (exists $elt->{'target'}))      { return  $elt->pi_string;}
8091           2                                 19         elsif( (exists $elt->{'comment'})) { return  $elt->{comment};  }
8092           2                                 14         elsif( (exists $elt->{'ent'}))     { return  $elt->{ent} ;     }
8093                                                    
8094        1162           100                 4843         my $child= $elt->{first_child} ||'';
8095        1162                               3534         while( $child)
8096                                                          {
8097        1263                               3790             my $child_text= $child->text;
8098  ***   1263     50                        5047             $string.= defined( $child_text) ? $child_text : '';
8099        1263                               6311           } continue { $child= $child->{next_sibling}; }
8100                                                  
8101        1162    100                        2936         unless( defined $string) { $string=''; }
              16                                 36   
8102                                                   
8103  ***   1162     50                        7249         return $output_text_filter ? $output_text_filter->( $string) : $string;
8104                                                      }
8105                                                  
8106                                                    sub text_only
8107           4    100    100      4            20       { return join '', map { $_->text if( $_->is_text || (exists $_->{'ent'})) } $_[0]->_children; }
              12                                 41   
8108                                                  
8109                                                    sub trimmed_text
8110          14                   14            39       { my $elt= shift;
8111          14                                 46         my $text= $elt->text( @_);
8112          14                                 97         $text=~ s{\s+}{ }sg;
8113          14                                 52         $text=~ s{^\s*}{};
8114          14                                 96         $text=~ s{\s*$}{};
8115          14                                 94         return $text;
8116                                                      }
8117                                                  
8118                                                    sub trim
8119          18                   18            49       { my( $elt)= @_;
8120          18                                 57         my $pcdata= $elt->first_descendant( '#TEXT');
8121          18                                 54         (my $pcdata_text= $pcdata->text)=~ s{^\s+}{}s;
8122          18                                 75         $pcdata->set_text( $pcdata_text);
8123          18                                 56         $pcdata= $elt->last_descendant( '#TEXT');
8124          18                                 69         ($pcdata_text= $pcdata->text)=~ s{\s+$}{};
8125          18                                 70         $pcdata->set_text( $pcdata_text);
8126          18                                 63         foreach $pcdata ($elt->descendants( '#TEXT'))
8127          31                                 92           { ($pcdata_text= $pcdata->text)=~ s{\s+}{ }g;
8128          31                                118             $pcdata->set_text( $pcdata_text);
8129                                                          }
8130          18                                 85         return $elt;
8131                                                      }
8132                                                    
8133                                                  
8134                                                    # remove cdata sections (turns them into regular pcdata) in an element 
8135                                                    sub remove_cdata 
8136           2                    2            17       { my $elt= shift;
8137           2                                 10         foreach my $cdata ($elt->descendants_or_self( CDATA))
8138           2    100                           5           { if( $keep_encoding)
8139           1                                  5               { my $data= $cdata->{cdata};
8140           1                                 17                 $data=~ s{([&<"'])}{$XML::Twig::base_ent{$1}}g;
8141           1                                  6                 $cdata->set_pcdata( $data);
8142                                                              }
8143                                                            else
8144           1                                  6               { $cdata->set_pcdata( $cdata->{cdata}); }
8145           2                                  8             $cdata->set_gi( PCDATA);
8146           2                                 17             undef $cdata->{cdata};
8147                                                          }
8148                                                      }
8149                                                  
8150           2                    2            16   sub _is_private      { return _is_private_name( $_[0]->gi); }
8151           4                    4            32   sub _is_private_name { return $_[0]=~ m{^#(?!default:)};                }
8152                                                  
8153                                                  
8154                                                  } # end of block containing package globals ($pretty_print, $quotes, keep_encoding...)
8155                                                  
8156                                                  sub normalize
8157           6                    6            27     { my( $elt)= @_;
8158           6                                 23       my @descendants= $elt->descendants( '#PCDATA');
8159           6                                 29       while( my $desc= shift @descendants)
8160          15           100                  229         { while( @descendants && $desc->{next_sibling} && $desc->{next_sibling}== $descendants[0])
                           100                        
8161           3                                  7             { my $to_merge= shift @descendants;
8162           3                                 15               $desc->{pcdata}.= $to_merge->{pcdata};
8163           3                                 11               $to_merge->delete;
8164                                                            }
8165                                                        }
8166           6                                 25       return $elt;
8167                                                    }
8168                                                  
8169                                                  # SAX export methods
8170                                                  sub toSAX1
8171           2                    2            11     { _toSAX(@_, \&_start_tag_data_SAX1, \&_end_tag_data_SAX1); }
8172                                                  
8173                                                  sub toSAX2
8174           2                    2            11     { _toSAX(@_, \&_start_tag_data_SAX2, \&_end_tag_data_SAX2); }
8175                                                  
8176                                                  sub _toSAX
8177          72                   72           273     { my( $elt, $handler, $start_tag_data, $end_tag_data)= @_;
8178          72    100                         344       if( $elt->{gi} >= $XML::Twig::SPECIAL_GI)
8179          43                                120         { my $data= $start_tag_data->( $elt);
8180          43                                147           _start_prefix_mapping( $elt, $handler, $data);
8181  ***     43    100     66                  441           if( $data && (my $start_element = $handler->can( 'start_element')))
8182          39    100                         122             { unless( $elt->_flushed) { $start_element->( $handler, $data); } }
              35                                153   
8183                                                        
8184          43                                271           foreach my $child ($elt->_children)
8185          51                                246             { $child->_toSAX( $handler, $start_tag_data, $end_tag_data); }
8186                                                  
8187  ***     43    100     66                  162           if( (my $data= $end_tag_data->( $elt)) && (my $end_element = $handler->can( 'end_element')) )
8188          39                                166             { $end_element->( $handler, $data); }
8189          43                                249           _end_prefix_mapping( $elt, $handler);
8190                                                        }
8191                                                      else # text or special element
8192          29    100    100                  528         { if( (exists $elt->{'pcdata'}) && (my $characters= $handler->can( 'characters')))
      ***           100     66                        
      ***           100     66                        
                    100                               
                    100                               
8193          20                                222             { $characters->( $handler, { Data => $elt->{pcdata} });  }
8194                                                          elsif( (exists $elt->{'cdata'}))  
8195  ***      2     50                          24             { if( my $start_cdata= $handler->can( 'start_cdata'))
8196           2                                 10                 { $start_cdata->( $handler); }
8197  ***      2     50                          16               if( my $characters= $handler->can( 'characters'))
8198           2                                 16                 { $characters->( $handler, {Data => $elt->{cdata} });  }
8199  ***      2     50                          24               if( my $end_cdata= $handler->can( 'end_cdata'))
8200           2                                 11                 { $end_cdata->( $handler); }
8201                                                            }
8202                                                          elsif( ((exists $elt->{'target'}))  && (my $pi= $handler->can( 'processing_instruction')))
8203           2                                 24             { $pi->( $handler, { Target =>$elt->{target}, Data => $elt->{data} });  }
8204                                                          elsif( ((exists $elt->{'comment'}))  && (my $comment= $handler->can( 'comment')))
8205           2                                 20             { $comment->( $handler, { Data => $elt->{comment} });  }
8206                                                          elsif( ((exists $elt->{'ent'})))
8207                                                            { 
8208  ***      1     50                          17               if( my $se=   $handler->can( 'skipped_entity'))
      ***             0                               
8209           1                                  6                 { $se->( $handler, { Name => $elt->ent_name });  }
8210                                                              elsif( my $characters= $handler->can( 'characters'))
8211  ***      0      0                           0                 { if( defined $elt->ent_string)
8212  ***      0                                  0                     { $characters->( $handler, {Data => $elt->ent_string});  }
8213                                                                  else
8214  ***      0                                  0                     { $characters->( $handler, {Data => $elt->ent_name});  }
8215                                                                }
8216                                                            }
8217                                                        
8218                                                        }
8219                                                    }
8220                                                    
8221                                                  sub _start_tag_data_SAX1
8222          15                   15            40     { my( $elt)= @_;
8223          15                                 60       my $name= $XML::Twig::index2gi[$elt->{'gi'}];
8224  ***     15    100     66                  190       return if( ( (substr( $XML::Twig::index2gi[$elt->{'gi'}], 0, 1) eq '#') && (substr( $XML::Twig::index2gi[$elt->{'gi'}], 0, 9) ne '#default:') ));
8225          13                                 30       my $attributes={};
8226          13                                 41       my $atts= $elt->atts;
8227          13                                 81       while( my( $att, $value)= each %$atts)
8228  ***      4    100     66                   63         { $attributes->{$att}= $value unless( ( (substr( $att, 0, 1) eq '#') && (substr( $att, 0, 9) ne '#default:') )); }
8229          13                                 69       my $data= { Name => $name, Attributes => $attributes};
8230          13                                 46       return $data;
8231                                                    }
8232                                                  
8233                                                  sub _end_tag_data_SAX1
8234          13                   13            39     { my( $elt)= @_;
8235  ***     13    100     66                  112       return if( ( (substr( $XML::Twig::index2gi[$elt->{'gi'}], 0, 1) eq '#') && (substr( $XML::Twig::index2gi[$elt->{'gi'}], 0, 9) ne '#default:') ));
8236          11                                175       return  { Name => $XML::Twig::index2gi[$elt->{'gi'}] };
8237                                                    } 
8238                                                    
8239                                                  sub _start_tag_data_SAX2
8240          32                   32            92     { my( $elt)= @_;
8241          32                                 78       my $data={};
8242                                                      
8243          32                                135       my $name= $XML::Twig::index2gi[$elt->{'gi'}];
8244  ***     32    100     66                  231       return if( ( (substr( $XML::Twig::index2gi[$elt->{'gi'}], 0, 1) eq '#') && (substr( $XML::Twig::index2gi[$elt->{'gi'}], 0, 9) ne '#default:') ));
8245          30                                119       $data->{Name}         = $name;
8246          30                                100       $data->{Prefix}       = $elt->ns_prefix; 
8247          30                                100       $data->{LocalName}    = $elt->local_name;
8248          30                                102       $data->{NamespaceURI} = $elt->namespace;
8249                                                  
8250                                                      # save a copy of the data so we can re-use it for the end tag
8251          30                                382       my %sax2_data= %$data;
8252          30                                165       $elt->{twig_elt_SAX2_data}= \%sax2_data;
8253                                                     
8254                                                      # add the attributes
8255          30                                183       $data->{Attributes}= $elt->_atts_to_SAX2;
8256                                                  
8257          30                                164       return $data;
8258                                                    }
8259                                                  
8260                                                  sub _atts_to_SAX2
8261          30                   30            69     { my $elt= shift;
8262          30                                 66       my $SAX2_atts= {};
8263          30                                 51       foreach my $att (keys %{$elt->atts})
              30                                 86   
8264                                                        { 
8265  ***     15    100     66                  105           next if( ( (substr( $att, 0, 1) eq '#') && (substr( $att, 0, 9) ne '#default:') ));
8266          13                                 29           my $SAX2_att={};
8267          13                                 52           $SAX2_att->{Name}         = $att;
8268          13                                 35           $SAX2_att->{Prefix}       = _ns_prefix( $att); 
8269          13                                 39           $SAX2_att->{LocalName}    = _local_name( $att);
8270          13                                 62           $SAX2_att->{NamespaceURI} = $elt->namespace( $SAX2_att->{Prefix});
8271          13                                 66           $SAX2_att->{Value}        = $elt->{'att'}->{$att};
8272          13                                 86           my $SAX2_att_name= "{$SAX2_att->{NamespaceURI}}$SAX2_att->{LocalName}";
8273                                                  
8274          13                                 84           $SAX2_atts->{$SAX2_att_name}= $SAX2_att;
8275                                                        }
8276          30                                141       return $SAX2_atts;
8277                                                    }
8278                                                  
8279                                                  sub _start_prefix_mapping
8280          43                   43           154     { my( $elt, $handler, $data)= @_;
8281          43    100    100                  358       if( my $start_prefix_mapping= $handler->can( 'start_prefix_mapping')
              13    100                         229   
8282          30                                247           and my @new_prefix_mappings= grep { /^\{[^}]*\}xmlns/ || /^\{$XMLNS_URI\}/ } keys %{$data->{Attributes}}
8283                                                        )
8284           7                                132         { foreach my $prefix (@new_prefix_mappings)
8285           7                                 41             { my $prefix_string= $data->{Attributes}->{$prefix}->{LocalName};
8286           7    100                          26               if( $prefix_string eq 'xmlns') { $prefix_string=''; }
               3                                  7   
8287           7                                 56               my $prefix_data=
8288                                                                {  Prefix       => $prefix_string,
8289                                                                   NamespaceURI => $data->{Attributes}->{$prefix}->{Value}
8290                                                                };
8291           7                                 29               $start_prefix_mapping->( $handler, $prefix_data);
8292           7           100                  102               $elt->{twig_end_prefix_mapping} ||= [];
8293           7                                 14               push @{$elt->{twig_end_prefix_mapping}}, $prefix_string;
               7                                 60   
8294                                                            }
8295                                                        }
8296                                                    }
8297                                                  
8298                                                  sub _end_prefix_mapping
8299          43                   43           145     { my( $elt, $handler)= @_;
8300          43    100                         327       if( my $end_prefix_mapping= $handler->can( 'end_prefix_mapping'))
8301          30                                 50         { foreach my $prefix (@{$elt->{twig_end_prefix_mapping}})
              30                                299   
8302           9                                 51             { $end_prefix_mapping->( $handler, { Prefix => $prefix} ); }
8303                                                        }
8304                                                    }
8305                                                               
8306                                                  sub _end_tag_data_SAX2
8307          30                   30            91     { my( $elt)= @_;
8308  ***     30    100     66                  229       return if( ( (substr( $XML::Twig::index2gi[$elt->{'gi'}], 0, 1) eq '#') && (substr( $XML::Twig::index2gi[$elt->{'gi'}], 0, 9) ne '#default:') ));
8309          28                                364       return $elt->{twig_elt_SAX2_data};
8310                                                    } 
8311                                                  
8312                                                  sub contains_text
8313         186                  186           507     { my $elt= shift;
8314         186                                561       my $child= $elt->{first_child};
8315         186                                549       while ($child)
8316  ***    168    100     66                  549         { return 1 if( $child->is_text || (exists $child->{'ent'})); 
8317         131                                603           $child= $child->{next_sibling};
8318                                                        }
8319         149                                860       return 0;
8320                                                    }
8321                                                  
8322                                                  # creates a single pcdata element containing the text as child of the element
8323                                                  # options: 
8324                                                  #   - force_pcdata: when set to a true value forces the text to be in a #PCDATA
8325                                                  #                   even if the original element was a #CDATA
8326                                                  sub set_text
8327         220                  220          1253     { my( $elt, $string, %option)= @_;
8328                                                  
8329         220    100                        1409       if( $XML::Twig::index2gi[$elt->{'gi'}] eq PCDATA) 
                    100                               
                    100                               
8330         169                                711         { return $elt->set_pcdata( $string); }
8331                                                      elsif( $XML::Twig::index2gi[$elt->{'gi'}] eq CDATA)  
8332          12    100                          36         { if( $option{force_pcdata})
8333           2                                  7             { $elt->set_gi( PCDATA);
8334           2                                  8               $elt->_set_cdata('');
8335           2                                 10               return $elt->set_pcdata( $string);
8336                                                            }
8337                                                          else
8338          10                                 35             { return $elt->_set_cdata( $string); }
8339                                                        }
8340                                                      elsif( $elt->contains_a_single( PCDATA) )
8341                                                        { # optimized so we have a slight chance of not loosing embedded comments and pi's
8342          32                                273           $elt->{first_child}->set_pcdata( $string);
8343          32                                189           return $elt;
8344                                                        }
8345                                                  
8346           7                                402       foreach my $child (@{[$elt->_children]})
               7                                 45   
8347           4                                 26         { $child->delete; }
8348                                                  
8349           7                                 29       my $pcdata= $elt->new( PCDATA, $string);
8350           7                                 53       $pcdata->paste( $elt);
8351                                                  
8352           7                                 22       delete $elt->{empty};
8353                                                  
8354           7                                 27       return $elt;
8355                                                    }
8356                                                  
8357                                                  # set the content of an element from a list of strings and elements
8358                                                  sub set_content
8359         119                  119           311     { my $elt= shift;
8360                                                  
8361         119    100                         361       return $elt unless defined $_[0];
8362                                                  
8363                                                      # attributes can be given as a hash (passed by ref)
8364         118    100                         468       if( ref $_[0] eq 'HASH')
8365           1                                  3         { my $atts= shift;
8366           1                                  4           $elt->del_atts; # usually useless but better safe than sorry
8367           1                                  4           $elt->set_atts( $atts);
8368  ***      1     50                           6           return $elt unless defined $_[0];
8369                                                        }
8370                                                  
8371                                                      # check next argument for #EMPTY
8372         118    100    100                  950       if( !(ref $_[0]) && ($_[0] eq EMPTY) ) 
8373           5                                 20         { $elt->{empty}= 1; return $elt; }
               5                                 13   
8374                                                  
8375                                                      # case where we really want to do a set_text, the element is '#PCDATA'
8376                                                      # or contains a single PCDATA and we only want to add text in it
8377         113    100    100                 1010       if( ($XML::Twig::index2gi[$elt->{'gi'}] eq PCDATA || $elt->contains_a_single( PCDATA)) 
                    100    100                        
      ***                   66                        
      ***                   66                        
      ***                   66                        
8378                                                          && (@_ == 1) && !( ref $_[0]))
8379          12                                 53         { $elt->set_text( $_[0]);
8380          12                                 44           return $elt;
8381                                                        }
8382                                                      elsif( ($XML::Twig::index2gi[$elt->{'gi'}] eq CDATA) && (@_ == 1) && !( ref $_[0]))
8383           1                                  5         { $elt->_set_cdata( $_[0]);
8384           1                                  3           return $elt;
8385                                                        }
8386                                                  
8387                                                      # delete the children
8388                                                      # WARNING: potential problem here if the children are used
8389                                                      # somewhere else (where?). Will be solved when I use weak refs
8390         100                                200       foreach my $child (@{[$elt->_children]})
             100                                355   
8391           1                                  5         { $child->delete; }
8392                                                  
8393         100                                749       foreach my $child (@_)
8394  ***    120    100     66                  698         { if( ref( $child) && isa( $child, 'XML::Twig::Elt'))
8395                                                            { # argument is an element
8396          25                                161               $child->paste( 'last_child', $elt);
8397                                                            }
8398                                                          else
8399                                                            { # argument is a string
8400          95    100    100                  516               if( (my $pcdata= $elt->{last_child}) && $elt->{last_child}->is_pcdata)
8401                                                                { # previous child is also pcdata: just concatenate
8402           2                                 14                   $pcdata->set_pcdata( $pcdata->{pcdata} . $child) 
8403                                                                }
8404                                                              else
8405                                                                { # previous child is not a string: creat a new pcdata element
8406          93                                446                   $pcdata= $elt->new( PCDATA, $child);
8407          93                                417                   $pcdata->paste( 'last_child', $elt);  
8408                                                                }
8409                                                            }
8410                                                        }
8411                                                  
8412         100                                265       delete $elt->{empty};
8413                                                  
8414         100                                288       return $elt;
8415                                                    }
8416                                                  
8417                                                  # inserts an element (whose gi is given) as child of the element
8418                                                  # all children of the element are now children of the new element
8419                                                  # returns the new element
8420                                                  sub insert
8421           7                    7            45     { my ($elt, @args)= @_;
8422                                                      # first cut the children
8423           7                                 33       my @children= $elt->_children;
8424           7                                 25       foreach my $child (@children)
8425           4                                 32         { $child->cut; }
8426                                                      # insert elements
8427           7                                 35       while( my $gi= shift @args)
8428           7                                 30         { my $new_elt= $elt->new( $gi);
8429                                                          # add attributes if needed
8430  ***      7    100     66                   55           if( defined( $args[0]) && ( isa( $args[0], 'HASH')) )
8431           2                                  8             { $new_elt->set_atts( shift @args); }
8432                                                          # paste the element
8433           7                                 37           $new_elt->paste( $elt);
8434           7                                 23           delete $elt->{empty};
8435           7                                 38           $elt= $new_elt;
8436                                                        }
8437                                                      # paste back the children
8438           7                                 21       foreach my $child (@children)
8439           4                                 18         { $child->paste( 'last_child', $elt); }
8440           7                                 24       return $elt;
8441                                                    }
8442                                                  
8443                                                  # insert a new element 
8444                                                  # $elt->insert_new_element( $opt_position, $gi, $opt_atts_hash, @opt_content); 
8445                                                  # the element is created with the same syntax as new
8446                                                  # position is the same as in paste, first_child by default
8447                                                  sub insert_new_elt
8448          95                   95           268     { my $elt= shift;
8449          95                                197       my $position= $_[0];
8450          95    100    100                 1276       if(     ($position eq 'before') || ($position eq 'after')
                           100                        
                           100                        
8451                                                           || ($position eq 'first_child') || ($position eq 'last_child'))
8452          92                                200         { shift; }
8453                                                      else
8454           3                                 11         { $position= 'first_child'; }
8455                                                  
8456          95                                351       my $new_elt= $elt->new( @_);
8457          95                                345       $new_elt->paste( $position, $elt);
8458                                                  
8459                                                      #if( defined $new_elt->{'att'}->{$ID}) { $new_elt->set_id( $new_elt->{'att'}->{$ID}); }
8460                                                      
8461          95                                283       return $new_elt;
8462                                                    }
8463                                                  
8464                                                  # wraps an element in elements which gi's are given as arguments
8465                                                  # $elt->wrap_in( 'td', 'tr', 'table') wraps the element as a single
8466                                                  # cell in a table for example
8467                                                  # returns the new element
8468                                                  sub wrap_in
8469          16                   16            67     { my $elt= shift;
8470          16                                 74       while( my $gi = shift @_)
8471          16                                 60         { my $new_elt = $elt->new( $gi);
8472          16    100                          72           if( $elt->{twig_current})
8473           2                                  9             { my $t= $elt->twig;
8474           2                                 13               $t->{twig_current}= $new_elt;
8475           2                                  5               delete $elt->{'twig_current'};
8476           2                                  7               $new_elt->{'twig_current'}=1;
8477                                                            }
8478                                                  
8479          16    100                          68           if( my $parent= $elt->{parent})
8480  ***     15     50                          49             { $new_elt->{parent}=$parent; if( $XML::Twig::weakrefs) { weaken( $new_elt->{parent});} ; 
              15                                 45   
              15                                 77   
8481          15    100                          90               if( $parent->{first_child} == $elt) { $parent->{first_child}=  $new_elt; }
              11                                114   
8482  ***     15     50                          73                if( $parent->{last_child} == $elt) {  delete $parent->{empty}; $parent->{last_child}=$new_elt; if( $XML::Twig::weakrefs) { weaken( $parent->{last_child});} ;  }
               8    100                          21   
               8                                 27   
               8                                 27   
               8                                 45   
8483                                                            }
8484                                                          else
8485                                                            { # wrapping the root
8486           1                                  6               my $twig= $elt->twig;
8487  ***      1     50     33                   10               if( $twig && $twig->root && ($twig->root eq $elt) )
      ***                   33                        
8488           1                                  5                 { $twig->{twig_root}= $new_elt; }
8489                                                            }
8490                                                  
8491          16    100                          73           if( my $prev_sibling= $elt->{prev_sibling})
8492  ***      4     50                          15             { $new_elt->{prev_sibling}=$prev_sibling; if( $XML::Twig::weakrefs) { weaken( $new_elt->{prev_sibling});} ;
               4                                 16   
               4                                 20   
8493           4                                 16               $prev_sibling->{next_sibling}=  $new_elt;
8494                                                            }
8495                                                  
8496          16    100                          74           if( my $next_sibling= $elt->{next_sibling})
8497           7                                 24             { $new_elt->{next_sibling}=  $next_sibling;
8498  ***      7     50                          25               $next_sibling->{prev_sibling}=$new_elt; if( $XML::Twig::weakrefs) { weaken( $next_sibling->{prev_sibling});} ;
               7                                 32   
               7                                 40   
8499                                                            }
8500          16                                 52           $new_elt->{first_child}=  $elt;
8501  ***     16     50                          50            delete $new_elt->{empty}; $new_elt->{last_child}=$elt; if( $XML::Twig::weakrefs) { weaken( $new_elt->{last_child});} ;
              16                                 54   
              16                                 49   
              16                                 67   
8502                                                  
8503  ***     16     50                          53           $elt->{parent}=$new_elt; if( $XML::Twig::weakrefs) { weaken( $elt->{parent});} ;
              16                                 43   
              16                                 66   
8504  ***     16     50                          55           $elt->{prev_sibling}=undef; if( $XML::Twig::weakrefs) { weaken( $elt->{prev_sibling});} ;
              16                                 44   
              16                                 64   
8505          16                                 50           $elt->{next_sibling}=  undef;
8506                                                  
8507                                                          # add the attributes if the next argument is a hash ref
8508  ***     16    100     66                  140           if( defined( $_[0]) && (isa( $_[0], 'HASH')) )
8509          10                                 43             { $new_elt->set_atts( shift @_); }
8510                                                  
8511          16                                 89           $elt= $new_elt;
8512                                                        }
8513                                                        
8514          16                                 63       return $elt;
8515                                                    }
8516                                                  
8517                                                  sub replace
8518           6                    6            37     { my( $elt, $ref)= @_;
8519                                                  
8520  ***      6     50                          29       if( $elt->{parent}) { $elt->cut; }
      ***      0                                  0   
8521                                                  
8522  ***      6     50                          26       if( my $parent= $ref->{parent})
8523  ***      6     50                          16         { $elt->{parent}=$parent; if( $XML::Twig::weakrefs) { weaken( $elt->{parent});} ;
               6                                 18   
               6                                 29   
8524           6    100                          28           if( $parent->{first_child} == $ref) { $parent->{first_child}=  $elt; }
               4                                 13   
8525  ***      6     50                          26           if( $parent->{last_child} == $ref)  {  delete $parent->{empty}; $parent->{last_child}=$elt; if( $XML::Twig::weakrefs) { weaken( $parent->{last_child});}  ; }
               3    100                           8   
               3                                 10   
               3                                 10   
               3                                 13   
8526                                                        }
8527           6    100                          27       if( my $prev_sibling= $ref->{prev_sibling})
8528  ***      2     50                           7         { $elt->{prev_sibling}=$prev_sibling; if( $XML::Twig::weakrefs) { weaken( $elt->{prev_sibling});} ;
               2                                  6   
               2                                  9   
8529           2                                  7           $prev_sibling->{next_sibling}=  $elt;
8530                                                        }
8531           6    100                          24       if( my $next_sibling= $ref->{next_sibling})
8532           3                                 10         { $elt->{next_sibling}=  $next_sibling;
8533  ***      3     50                          11           $next_sibling->{prev_sibling}=$elt; if( $XML::Twig::weakrefs) { weaken( $next_sibling->{prev_sibling});} ;
               3                                  8   
               3                                 13   
8534                                                        }
8535                                                     
8536  ***      6     50                          20       $ref->{parent}=undef; if( $XML::Twig::weakrefs) { weaken( $ref->{parent});} ;
               6                                 18   
               6                                 23   
8537  ***      6     50                          17       $ref->{prev_sibling}=undef; if( $XML::Twig::weakrefs) { weaken( $ref->{prev_sibling});} ;
               6                                 18   
               6                                 21   
8538           6                                 18       $ref->{next_sibling}=  undef;
8539           6                                 18       return $ref;
8540                                                    }
8541                                                  
8542                                                  sub replace_with
8543           2                    2             9     { my $ref= shift;
8544           2                                  6       my $elt= shift;
8545           2                                 15       $elt->replace( $ref);
8546           2                                  8       foreach my $new_elt (reverse @_)
8547           2                                  9         { $new_elt->paste( after => $elt); }
8548           2                                  6       return $elt;
8549                                                    }
8550                                                  
8551                                                  
8552                                                  # move an element, same syntax as paste, except the element is first cut
8553                                                  sub move
8554           6                    6            24     { my $elt= shift;
8555           6                                 24       $elt->cut;
8556           6                                 36       $elt->paste( @_);
8557           6                                 27       return $elt;
8558                                                    }
8559                                                  
8560                                                  
8561                                                  # adds a prefix to an element, creating a pcdata child if needed
8562                                                  sub prefix
8563          16                   16            89     { my ($elt, $prefix, $option)= @_;
8564  ***     16    100     66                  119       my $asis= ($option && ($option eq 'asis')) ? 1 : 0;
8565  ***     16    100     33                  247       if( (exists $elt->{'pcdata'}) 
      ***           100     33                        
      ***                   33                        
      ***                   66                        
                           100                        
                           100                        
                           100                        
                           100                        
                           100                        
8566                                                          && (($asis && $elt->{asis}) || (!$asis && ! $elt->{asis}))
8567                                                        )
8568           2                                 18         { $elt->set_pcdata( $prefix . $elt->{pcdata}); }
8569                                                      elsif( $elt->{first_child} && $elt->{first_child}->is_pcdata
8570                                                          && (   ($asis && $elt->{first_child}->{asis}) 
8571                                                              || (!$asis && ! $elt->{first_child}->{asis}))
8572                                                           )
8573                                                        { 
8574           5                                 39           $elt->{first_child}->set_pcdata( $prefix . $elt->{first_child}->pcdata); 
8575                                                        }
8576                                                      else
8577           9                                 39         { my $new_elt= $elt->new( PCDATA, $prefix);
8578           9                                 38           $new_elt->paste( $elt);
8579           9    100                          33           if( $asis) { $new_elt->set_asis; }
               3                                 13   
8580                                                        }
8581          16                                 54       return $elt;
8582                                                    }
8583                                                  
8584                                                  # adds a suffix to an element, creating a pcdata child if needed
8585                                                  sub suffix
8586          12                   12            64     { my ($elt, $suffix, $option)= @_;
8587  ***     12    100     66                   92       my $asis= ($option && ($option eq 'asis')) ? 1 : 0;
8588  ***     12    100     33                  159       if( (exists $elt->{'pcdata'})
      ***           100     33                        
      ***                   33                        
      ***                   66                        
      ***                   66                        
                           100                        
                           100                        
                           100                        
                           100                        
8589                                                          && (($asis && $elt->{asis}) || (!$asis && ! $elt->{asis}))
8590                                                        )
8591           1                                  7         { $elt->set_pcdata( $elt->{pcdata} . $suffix); }
8592                                                      elsif( $elt->{last_child} && $elt->{last_child}->is_pcdata
8593                                                          && (   ($asis && $elt->{last_child}->{asis}) 
8594                                                              || (!$asis && ! $elt->{last_child}->{asis}))
8595                                                           )
8596           5                                 33         { $elt->{last_child}->set_pcdata( $elt->{last_child}->pcdata . $suffix); }
8597                                                      else
8598           6                                 25         { my $new_elt= $elt->new( PCDATA, $suffix);
8599           6                                 27           $new_elt->paste( 'last_child', $elt);
8600           6    100                          26           if( $asis) { $new_elt->set_asis; }
               2                                  9   
8601                                                        }
8602          12                                 39       return $elt;
8603                                                    }
8604                                                  
8605                                                  # create a path to an element ('/root/.../gi)
8606                                                  sub path
8607          21                   21          1126     { my $elt= shift;
8608          21                                 65       my @context= ( $elt, $elt->ancestors);
8609          21                                 74       return "/" . join( "/", reverse map {$_->gi} @context);
              55                                151   
8610                                                    }
8611                                                  
8612                                                  sub xpath
8613           6                    6            18     { my $elt= shift;
8614           6                                  7       my $xpath;
8615           6                                 20       foreach my $ancestor (reverse $elt->ancestors_or_self)
8616          18                                 71         { my $gi= $XML::Twig::index2gi[$ancestor->{'gi'}];
8617          18                                 55           $xpath.= "/$gi";
8618          18                                 57           my $index= $ancestor->prev_siblings( $gi) + 1;
8619          18    100    100                   95           unless( ($index == 1) && !$ancestor->next_sibling( $gi))
8620          10                                128             { $xpath.= "[$index]"; }
8621                                                        }
8622           6                                 34       return $xpath;
8623                                                    }
8624                                                  
8625                                                  # methods used mainly by wrap_children
8626                                                  
8627                                                  # return a string with the 
8628                                                  # for an element <foo><elt att="val">...</elt><elt2/><elt>...</elt></foo>
8629                                                  # returns '<elt att="val"><elt2><elt>'
8630                                                  sub _stringify_struct
8631          13                   13            50     { my( $elt, %opt)= @_;
8632          13                                 37       my $string='';
8633          13                                 48       my $pretty_print= set_pretty_print( 'none');
8634          13                                 57       foreach my $child ($elt->_children)
8635  ***     37            50                  125         { $child->add_id; $string .= $child->start_tag( { escape_gt => 1 }) ||''; }
              37                                217   
8636          13                                 46       set_pretty_print( $pretty_print);
8637          13                                 59       return $string;
8638                                                    }
8639                                                  
8640                                                  # wrap a series of elements in a new one
8641                                                  sub _wrap_range
8642           9                    9            26     { my $elt= shift;
8643           9                                 21       my $gi= shift;
8644  ***      9     50                          65       my $atts= isa( $_[0], 'HASH') ? shift : undef;
8645           9                                 37       my $range= shift; # the string with the tags to wrap
8646                                                  
8647           9                                 30       my $t= $elt->twig;
8648                                                  
8649                                                      # get the tags to wrap
8650           9                                 19       my @to_wrap;
8651           9                                 89       while( $range=~ m{<\w+\s+[^>]*id=("[^"]*"|'[^']*')[^>]*>}g)
8652          14                                145         { push @to_wrap, $t->elt_id( substr( $1, 1, -1)); }
8653                                                  
8654  ***      9     50                          30       return '' unless @to_wrap;
8655                                                      
8656           9                                 22       my $to_wrap= shift @to_wrap;
8657           9                                 44       my %atts= %$atts;
8658           9                                 56       my $new_elt= $to_wrap->wrap_in( $gi, \%atts);
8659           9                                 16       $_->move( last_child => $new_elt) foreach (@to_wrap);
               9                                 53   
8660                                                  
8661           9                                118       return '';
8662                                                    }
8663                                                      
8664                                                  # wrap children matching a regexp in a new element
8665                                                  sub wrap_children
8666          13                   13            73     { my( $elt, $regexp, $gi, $atts)= @_;
8667                                                  
8668          13           100                   64       $atts ||={};
8669                                                  
8670          13                                 54       my $elt_as_string= $elt->_stringify_struct; # stringify the elt structure
8671          13                                108       $regexp=~ s{(<[^>]*>)}{_match_expr( $1)}eg; # in the regexp, replace gi's by the proper regexp 
              13                                 54   
8672          13                                 60       $elt_as_string=~ s{($regexp)}{$elt->_wrap_range( $gi, $atts, $1)}eg; # then do the actual replace
               9                                298   
8673                                                    
8674          13                                208       return $elt; 
8675                                                    }
8676                                                  
8677                                                  sub _match_expr
8678          22                   22           574     { my $tag= shift;
8679          22                                 75       my( $gi, %atts)= XML::Twig::_parse_start_tag( $tag);
8680          13                                 79       return _match_tag( $gi, %atts);
8681                                                    }
8682                                                  
8683                                                  
8684                                                  sub _match_tag
8685          13                   13            66     { my( $elt, %atts)= @_;
8686          13                                 68       my $string= "<$elt\\b";
8687          13                                 89       foreach my $key (sort keys %atts)
8688          14                                 53         { my $val= qq{\Q$atts{$key}\E};
8689          14                                 92           $string.= qq{[^>]*$key=(?:"$val"|'$val')};
8690                                                        }
8691          13                                 34       $string.=  qq{[^>]*>};
8692          13                                115       return "(?:$string)";
8693                                                    }
8694                                                  
8695                                                  sub field_to_att
8696           3                    3            21     { my( $elt, $cond, $att)= @_;
8697  ***      3            33                   25       $att ||= $cond;
8698           3    100                          14       my $child= $elt->first_child( $cond) or return undef;
8699           1                                  6       $elt->set_att( $att => $child->text);
8700           1                                  4       $child->cut;
8701           1                                  3       return $elt;
8702                                                    }
8703                                                  
8704                                                  sub att_to_field
8705           2                    2           260     { my( $elt, $att, $tag)= @_;
8706  ***      2            66                   10       $tag ||= $att;
8707           2                                 12       my $child= $elt->insert_new_elt( first_child => $tag, $elt->{'att'}->{$att});
8708           2                                  8       $elt->del_att( $att);
8709           2                                  8       return $elt;
8710                                                    }
8711                                                  
8712                                                  # sort children methods
8713                                                  
8714                                                  sub sort_children_on_field
8715           2                    2             6     { my $elt   = shift;
8716           2                                  6       my $field = shift;
8717           2                    9            18       my $get_key= sub { return $_[0]->field( $field) };
               9                                 39   
8718           2                                 11       return $elt->sort_children( $get_key, @_); 
8719                                                    }
8720                                                  
8721                                                  sub sort_children_on_att
8722           1                    1             3     { my $elt = shift;
8723           1                                  4       my $att = shift;
8724           1                    3             8       my $get_key= sub { return $_[0]->{'att'}->{$att} };
               3                                 15   
8725           1                                  5       return $elt->sort_children( $get_key, @_); 
8726                                                    }
8727                                                  
8728                                                  sub sort_children_on_value
8729           1                    1             3     { my $elt   = shift;
8730                                                      #my $get_key= eval qq{ sub { $NO_WARNINGS; return \$_[0]->text } };
8731           1                                  3       my $get_key= \&text;
8732           1                                  6       return $elt->sort_children( $get_key, @_); 
8733                                                    }
8734                                                  
8735                                                  
8736                                                  sub sort_children
8737           5                    5            55     { my( $elt, $get_key, %opt)=@_;
8738           5           100                   34       $opt{order} ||= 'normal';
8739           5           100                   24       $opt{type}  ||= 'alpha';
8740           5    100                         100       my( $par_a, $par_b)= ($opt{order} eq 'reverse') ? qw( b a) : qw ( a b) ;
8741           5    100                          25       my $op= ($opt{type} eq 'numeric') ? '<=>' : 'cmp' ;
8742           5                                 30       my @children= $elt->cut_children;
8743           5    100                          46       if( $opt{type} eq 'numeric')
                    100                               
8744           9                                 47         {  @children= map  { $_->[1] }
              14                                 47   
8745           9                                 25                       sort { $a->[0] <=> $b->[0] }
8746           2                                  8                       map  { [ $get_key->( $_), $_] } @children;
8747                                                        }
8748                                                      elsif( $opt{type} eq 'alpha')
8749           6                                 25         {  @children= map  { $_->[1] }
               5                                 18   
8750           6                                 16                       sort { $a->[0] cmp $b->[0] }
8751           2                                  7                       map  { [ $get_key->( $_), $_] } @children;
8752                                                        }
8753                                                      else
8754           1                                  8         { croak "wrong sort type '$opt{type}', should be either 'alpha' or 'numeric'"; }
8755                                                  
8756           4    100                          33       @children= reverse @children if( $opt{order} eq 'reverse');
8757           4                                 27       $elt->set_content( @children);
8758                                                    }
8759                                                  
8760                                                  
8761                                                  # comparison methods
8762                                                  
8763                                                  sub before
8764           6                    6          1284     { my( $a, $b)=@_;
8765           6    100                          22       if( $a->cmp( $b) == -1) { return 1; } else { return 0; }
               4                                 16   
               2                                  7   
8766                                                    }
8767                                                  
8768                                                  sub after
8769           3                    3           601     { my( $a, $b)=@_;
8770           3    100                          11       if( $a->cmp( $b) == 1) { return 1; } else { return 0; }
               1                                  4   
               2                                  8   
8771                                                    }
8772                                                  
8773                                                  sub lt
8774           2                    2            10     { my( $a, $b)=@_;
8775           2    100                           7       return 1 if( $a->cmp( $b) == -1);
8776           1                                  8       return 0;
8777                                                    }
8778                                                  
8779                                                  sub le
8780           2                    2            14     { my( $a, $b)=@_;
8781           2    100                           9       return 1 unless( $a->cmp( $b) == 1);
8782           1                                  5       return 0;
8783                                                    }
8784                                                  
8785                                                  sub gt
8786           2                    2             8     { my( $a, $b)=@_;
8787           2    100                           8       return 1 if( $a->cmp( $b) == 1);
8788           1                                  5       return 0;
8789                                                    }
8790                                                  
8791                                                  sub ge
8792           2                    2             9     { my( $a, $b)=@_;
8793           2    100                           8       return 1 unless( $a->cmp( $b) == -1);
8794           1                                  5       return 0;
8795                                                    }
8796                                                  
8797                                                  
8798                                                  sub cmp
8799         830                  830          2614     { my( $a, $b)=@_;
8800                                                  
8801                                                      # easy cases
8802         830    100                        3041       return  0 if( $a == $b);    
8803         787    100                        2370       return 1 if( $a->in($b)); # a starts after b 
8804         650    100                        1965       return -1 if( $b->in($a)); # a starts before b
8805                                                  
8806                                                      # ancestors does not include the element itself
8807         492                               1951       my @a_pile= ($a, $a->ancestors); 
8808         492                               1785       my @b_pile= ($b, $b->ancestors);
8809                                                  
8810                                                      # the 2 elements are not in the same twig
8811         492    100                        2528       return undef unless( $a_pile[-1] == $b_pile[-1]);
8812                                                  
8813                                                      # find the first non common ancestors (they are siblings)
8814         491                               1020       my $a_anc= pop @a_pile;
8815         491                               1178       my $b_anc= pop @b_pile;
8816                                                  
8817         491                               1624       while( $a_anc == $b_anc) 
8818         751                               1532         { $a_anc= pop @a_pile;
8819         751                               3163           $b_anc= pop @b_pile;
8820                                                        }
8821                                                  
8822                                                      # from there move left and right and figure out the order
8823         491                               1968       my( $a_prev, $a_next, $b_prev, $b_next)= ($a_anc, $a_anc, $b_anc, $b_anc);
8824         491                                954       while()
8825  ***    493            66                 2577         { $a_prev= $a_prev->{prev_sibling} || return( -1);
8826         296    100                        1185           return 1 if( $a_prev == $b_next);
8827  ***    131            66                  555           $a_next= $a_next->{next_sibling} || return( 1);
8828         101    100                         444           return -1 if( $a_next == $b_prev);
8829  ***     27            66                  133           $b_prev= $b_prev->{prev_sibling} || return( 1);
8830          20    100                          90           return -1 if( $b_prev == $a_next);
8831  ***      7            66                   34           $b_next= $b_next->{next_sibling} || return( -1);
8832           5    100                          23           return 1 if( $b_next == $a_prev);
8833                                                        }
8834                                                    }
8835                                                      
8836                                                  sub _dump
8837          49                   49           156     { my( $elt, $option)= @_; 
8838                                                    
8839          49    100                         221       my $atts       = defined $option->{atts}       ? $option->{atts}       :  1;
8840          49    100                         175       my $extra      = defined $option->{extra}      ? $option->{extra}      :  0;
8841  ***     49     50                         161       my $short_text = defined $option->{short_text} ? $option->{short_text} : 40;
8842                                                  
8843          49                                 92       my $sp= '| ';
8844          49                                147       my $indent= $sp x $elt->level;
8845          49                                144       my $indent_sp= '  ' x $elt->level;
8846                                                      
8847          49                                186       my $dump='';
8848          49    100                         133       if( $elt->is_elt)
8849                                                        { 
8850          24                                128           $dump .= $indent  . '|-' . $XML::Twig::index2gi[$elt->{'gi'}];
8851                                                          
8852          24    100    100                  134           if( $atts && (my @atts= $elt->att_names) )
8853           3                                 10             { $dump .= ' ' . join( ' ', map { qq{$_="} . $elt->{'att'}->{$_} . qq{"} } @atts); }
               3                                 36   
8854                                                  
8855          24                                 68           $dump .= "\n";
8856          24    100                          64           if( $extra) { $dump .= $elt->_dump_extra_data( $indent, $indent_sp, $short_text); }
               7                                 25   
8857          24                                 91           $dump .= join( "", map { $_->_dump( $option) } $elt->_children);
              44                                193   
8858                                                        }
8859                                                      else
8860                                                        { 
8861          25    100                         109           if( (exists $elt->{'pcdata'}))
      ***            50                               
                    100                               
                    100                               
      ***            50                               
8862          19                                 95             { $dump .= "$indent|-PCDATA:  '"  . _short_text( $elt->{pcdata}, $short_text) . "'\n" }
8863                                                          elsif( (exists $elt->{'ent'}))
8864  ***      0                                  0             { $dump .= "$indent|-ENTITY:  '" . _short_text( $elt->{ent}, $short_text) . "'\n" }
8865                                                          elsif( (exists $elt->{'cdata'}))
8866           3                                 17             { $dump .= "$indent|-CDATA:   '" . _short_text( $elt->{cdata}, $short_text) . "'\n" }
8867                                                          elsif( (exists $elt->{'comment'}))
8868           1                                  7             { $dump .= "$indent|-COMMENT: '" . _short_text( $elt->comment_string, $short_text) . "'\n" }
8869                                                          elsif( (exists $elt->{'target'}))
8870           2                                 22             { $dump .= "$indent|-PI:      '"      . $elt->{target} . "' - '" . _short_text( $elt->{data}, $short_text) . "'\n" }
8871          25    100                          82           if( $extra) { $dump .= $elt->_dump_extra_data( $indent, $indent_sp, $short_text); }
               7                                 25   
8872                                                        }
8873          49                                249       return $dump;
8874                                                    }
8875                                                  
8876                                                  sub _dump_extra_data
8877          14                   14            66     { my( $elt, $indent, $indent_sp, $short_text)= @_;
8878          14                                 36       my $dump='';
8879          14    100                          35       if( $elt->extra_data)
8880           2                                 10         { my $extra_data = $indent . "|-- (cpi before) '" . _short_text( $elt->extra_data, $short_text) . "'";
8881           2                                  9           $extra_data=~ s{\n}{$indent_sp}g;
8882           2                                  8           $dump .= $extra_data . "\n";
8883                                                        }
8884  ***     14     50                          45       if( $elt->_extra_data_in_pcdata)
8885  ***      0                                  0         { foreach my $data ( @{$elt->_extra_data_in_pcdata})
      ***      0                                  0   
8886  ***      0                                  0             { my $extra_data = $indent . "|-- (cpi offset $data->{offset}) '" . _short_text( $data->{text}, $short_text) . "'";
8887  ***      0                                  0               $extra_data=~ s{\n}{$indent_sp}g;
8888  ***      0                                  0               $dump .= $extra_data . "\n";
8889                                                            }
8890                                                        } 
8891  ***     14     50                          42       if( $elt->_extra_data_before_end_tag)
8892  ***      0                                  0         { my $extra_data = $indent . "|-- (cpi end) '" . _short_text( $elt->_extra_data_before_end_tag, $short_text) . "'";
8893  ***      0                                  0           $extra_data=~ s{\n}{$indent_sp}g;
8894  ***      0                                  0           $dump .= $extra_data . "\n";
8895                                                        } 
8896          14                                 56       return $dump;
8897                                                    }
8898                                                   
8899                                                  
8900                                                  sub _short_text
8901          27                   27           104     { my( $string, $length)= @_;
8902  ***     27    100     66                  254       if( !$length || (length( $string) < $length) ) { return $string; }
              24                                140   
8903           3                                 12       my $l1= (length( $string) -5) /2;
8904           3                                 20       my $l2= length( $string) - ($l1 + 5);
8905           3                                 26       return substr( $string, 0, $l1) . ' ... ' . substr( $string, -$l2);
8906                                                    }
8907                                                  
8908                                                  1;
8909                                                  
8910                                                  
8911                                                  __END__


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
119   ***     50      0     92   unless $parser_version >= $needVersion
121   ***     50     92      0   if ($] >= 5.008)
130   ***     50     92      0   if (eval 'require Scalar::Util' and defined \&Scalar::Util::weaken) { }
      ***      0      0      0   elsif (eval 'require WeakRef') { }
389          100   2775      1   unless ($args{'MoreOptions'})
391          100      3   5066   unless $valid_option{$arg}
403          100    162   2614   if (exists $args{'TwigHandlers'})
410          100     23   2747   if (exists $args{'StartTagHandlers'})
415          100      1   2769   if (exists $args{'DoNotChainHandlers'})
418          100      4   2766   if (exists $args{'IgnoreElts'})
420   ***     50      0      4   if (isa($args{'IgnoreElts'}, 'ARRAY'))
425          100      2   2768   if (exists $args{'Index'})
428          100      1      1   if (ref $index eq 'ARRAY')
437          100     66   2704   if (exists $args{'EltClass'})
439          100     15   2755   if (exists $args{'MapXmlns'})
445          100      4   2766   if (exists $args{'KeepOriginalPrefix'})
453          100      4   2766   if ($args{'ExpandExternalEnts'}) { }
457          100      1      3   if ($args{'ExpandExternalEnts'} == -1)
467   ***     50      0   2770   if (not $args{'NoLWP'} and not _use('URI') and not _use('URI::File') and not _use('LWP')) { }
472          100      1   2769   if ($args{'DoNotEscapeAmpInAtts'}) { }
484          100     63   2707   if ($args{'TwigRoots'})
489          100     11   2757   if ($args{'EndTagHandlers'})
490          100      1     10   unless ($$self{'twig_roots'} or $args{'ForceEndTagHandlersUsage'})
503          100     34   2733   if ($args{'TwigPrintOutsideRoots'})
504          100      1     33   unless $$self{'twig_roots'}
507          100     31      2   if (_is_fh($args{'TwigPrintOutsideRoots'}))
513          100     18   2748   if ($args{'KeepSpaces'})
514          100      1     17   if $args{'DiscardSpaces'}
515          100      1     16   if $args{'KeepSpacesIn'}
519          100      2   2762   if ($args{'DiscardSpaces'})
520          100      1      1   if $args{'KeepSpacesIn'}
524          100      8   2755   if ($args{'KeepSpacesIn'})
525          100      1      7   if $args{'DiscardSpacesIn'}
532          100      4   2758   if ($args{'DiscardSpacesIn'})
540          100   2742     20   unless $$self{'twig_keep_spaces'}
543          100      3   2759   if ($args{'Comments'} eq 'drop') { }
             100   1873    886   elsif ($args{'Comments'} eq 'keep') { }
             100    885      1   elsif ($args{'Comments'} eq 'process') { }
550          100      2   2759   if ($args{'Pi'} eq 'drop') { }
             100   1875    884   elsif ($args{'Pi'} eq 'keep') { }
             100    883      1   elsif ($args{'Pi'} eq 'process') { }
556          100    968   1792   if ($args{'KeepEncoding'}) { }
561          100      1    967   if defined $args{'ParseStartTag'}
566          100      2   1790   if ($args{'ParseStartTag'}) { }
573          100      5   2755   if ($args{'OutputFilter'}) { }
580          100      1   2759   if ($args{'RemoveCdata'}) { }
587          100      5   2755   if ($args{'OutputTextFilter'}) { }
595          100      7   2753   if (exists $args{'KeepAttsOrder'}) { }
597          100      6      1   if (_use('Tie::IxHash')) { }
606          100     42   2717   if ($args{'PrettyPrint'})
607   ***     50      0   2759   if ($args{'EscapeGt'})
608          100      1   2758   if ($args{'Quote'})
609          100     12   2747   if ($args{'EmptyTags'})
611          100      1   2758   if (exists $args{'Id'})
612          100      3   2756   if ($args{'NoProlog'})
613          100      2   2757   if ($args{'DoNotOutputDTD'})
614          100      9   2750   if ($args{'LoadDTD'})
615          100      1   2758   if ($args{'CharHandler'})
617          100      3   2756   if ($args{'InputFilter'})
618          100      1   2756   if ($args{'NoExpand'})
619          100      2   2755   if (my $output_encoding = $args{'OutputEncoding'})
621          100      4   2753   if (my $tdh = $args{'TopDownHandlers'})
624          100     61   2696   if ($$self{'twig_roots'}) { }
625          100     33     28   if ($$self{'twig_default_print'}) { }
626          100      7     26   if ($$self{'twig_keep_encoding'}) { }
651          100   2756      1   if ($weakrefs)
660          100     35   2780   if (not ref $t or not isa($t, 'XML::Twig'))
665   ***     50      0   2780   if ($] >= 5.008 and ${^UNICODE} and ${^UNICODE} & 24 and isa($_[0], 'GLOB') and -p $_[0])
682          100     22   2785   if (not $t)
683          100      6     16   if (isa($returned, 'XML::Twig') and $$returned{'twig_finish_now'}) { }
706   ***     50      0      6   unless _use('File::Temp')
714   ***     50      6      0   unless ($$t{'twig_keep_encoding'} or $] < 5.006)
715   ***     50      6      0   if (grep /useperlio=define/, `$^X -V`)
724   ***     50      0      6   unless chmod $mode, $tmpfile
726          100      4      2   if ($suffix)
728          100      2      2   if ($suffix =~ /\*/) { }
731   ***     50      0      4   unless rename $file, $backup
733   ***     50      0      6   unless rename $tmpfile, $file
752   ***     50      0      1   $@ ? :
757   ***     50      0      1   unless _use('LWP::Simple')
759   ***     50      0      1   $@ ? :
766   ***     50      0      1   $@ ? :
772          100      1      4   $$t{'ErrorContext'} ? :
781   ***     50      0     15   $$t{'ErrorContext'} ? :
783          100      1     14   isa($content, 'GLOB') ? :
790          100      1   1858   if (isa($to_parse, 'GLOB')) { }
             100   1847     11   elsif ($to_parse =~ /^\s*</) { }
             100      2      9   elsif ($to_parse =~ m[^\w+://.*\.html?$]) { }
             100      2      7   elsif ($to_parse =~ m[^\w+://]) { }
             100      2      5   elsif ($to_parse =~ /\.html?$/) { }
791          100      7   1840   $to_parse =~ /<html/i ? :
794          100      1      1   unless _use('LWP::Simple')
797          100      1      1   unless _use('LWP::Simple')
800   ***     50      1      0   if ($xml_parse_ok) { }
804   ***      0      0      0   if ($doc =~ /<html/i) { }
818          100      2      8   if (_is_well_formed_xml($_[0])) { }
822          100      4      4   if (_is_well_formed_xml($html)) { }
833          100     12      6   $@ ? :
850          100      1     27   unless _use('HTML::TreeBuilder', '3.13')
863          100      1     26   if ($$options{'indent'})
879   ***     50      0     21   if ($@ =~ /^\s*xml declaration not at start of external entity/) { }
      ***     50     21      0   elsif ($@ =~ /^\s*not well-formed \(invalid token\)/) { }
885          100      2     19   unless (keys %xml_parser_encoding)
887          100      5     16   if (not $add_decl) { }
888   ***     50      5      0   if ($xml_parser_encoding{$encoding}) { }
      ***      0      0      0   elsif ($encoding eq 'euc-jp' and $xml_parser_encoding{'x-euc-jp-jisx0221'}) { }
      ***      0      0      0   elsif ($encoding eq 'shift-jis' and $xml_parser_encoding{'x-sjis-jisx0221'}) { }
895   ***     50      5      0   if ($add_decl) { }
934   ***     50      0     10   if ($$meta{'http-equiv'} and $$meta{'http-equiv'} =~ /^\s*content-type\s*/i and $$meta{'content'} and $$meta{'content'} =~ m[^\s*text/html\s*;\s*charset\s*=\s*(\S*)\s*]i)
948   ***     50     16      0   if (_use('Encode')) { }
      ***      0      0      0   elsif (_use('Text::Iconv')) { }
      ***      0      0      0   elsif (_use('Unicode::Map8') and _use('Unicode::String')) { }
952   ***      0      0      0   if ($converter)
979   ***     50      5      0   if ($2 and $block_tag{$2}) { }
      ***      0      0      0   elsif ($3 and $block_tag{$3}) { }
980   ***     50      5      0   unless $2 =~ m[/>]
998          100      1      1   if ($text_type{$type}) { }
1023         100      5   2959   if ($disallowed{$module})
1024         100   2793    166   if ($used{$module})
1025         100    163      3   if (eval "require $module") { }
1027  ***     50    163      0   if (${"${module}::VERSION";} >= $version) { }
1039         100     99      7   if ($n > 0) { }
             100      6      1   elsif ($n < 0) { }
1040         100     29      6   if $i == $n
             100     35     86   if (&$coderef)
1042         100      5      6   if $i == $n
             100     11      2   if (&$coderef)
1050         100      1      9   if ($uri =~ m[^\w+://]) { }
1057         100      3     22   if (defined $base and not $filename =~ m[^(?:[\\/]|\w+:)])
1068         100      3     14   unless open TWIG_TO_SLURP, "<$filename"
1091  ***     50      0     20   unless _use('LWP')
1092  ***     50     20      0   if ($^O ne 'VMS') { }
1093  ***     50      0     20   unless pipe README, WRITEME
1094         100     15      5   if (my $pid = fork) { }
1097         100      6      9   $safe ? :
1099         100      3     12   $@ ? :
1111         100      1      4   unless $response->is_success
1121  ***      0      0      0   unless $response->is_success
1122  ***      0      0      0   $safe ? :
1123  ***      0      0      0   $@ ? :
1147         100      3    157   if ($$t{'twig_keep_encoding'})
1155  ***     50     76      0   if (@saved_default_handler and defined $saved_default_handler[1]) { }
1169         100      6     10   if ($$p{'twig'}{'twig_doctype'}{'has_internal'} and not $expat_1_95_2)
1184         100   2621    972   unless $_[0]
             100    958     14   if isa($_[0], 'GLOB') or isa($_[0], 'IO::Scalar')
1191         100      6    546   unless _set_special_handler($handlers, $path, $handler, $prev_handler) or _set_pi_handler($handlers, $path, $handler, $prev_handler) or _set_level_handler($handlers, $path, $handler, $prev_handler) or _set_regexp_handler($handlers, $path, $handler, $prev_handler) or _set_xpath_handler($handlers, $path, $handler, $prev_handler)
1209         100     25    527   if ($path =~ /^\s*($ALL|$DEFAULT|#COMMENT)\s*$/io) { }
1219         100    506      6   if (my $handler_data = _parse_xpath_handler($path, $handler)) { }
1231         100    114    398   $$handlers{'xpath_handler'}{$tag} ? :
1233         100     61    451   if ($prev_handler)
1235         100    492     20   if $$handler_data{'handler'}
1238         100    175     74   unless ($$a{'score'}{'type'} || 0) <=> ($$b{'score'}{'type'} || 0) or ($$b{'score'}{'anchored'} || 0) <=> ($$a{'score'}{'anchored'} || 0) or ($$b{'score'}{'steps'} || 0) <=> ($$a{'score'}{'steps'} || 0) or ($$b{'score'}{'predicates'} || 0) <=> ($$a{'score'}{'predicates'} || 0) or ($$b{'score'}{'tests'} || 0) <=> ($$a{'score'}{'tests'} || 0)
1253         100      9    518   if ($path =~ /^\s*(?:\?|#PI)\s*(?:([^\s]*)\s*)$/) { }
1267         100      3    515   if ($path =~ /^ \s* level \s* \( \s* ([0-9]+) \s* \) \s* $/ox) { }
1283         100      3    512   if ($path =~ /^\(\?([xism]*)(?:-[xism]*)?:(.*)\)$/) { }
1302  ***     50      0    512   if ($DEBUG_HANDLER >= 1)
1306  ***     50      0    512   if ($DEBUG_HANDLER and $path_to_check =~ /\S/)
1307         100      2    510   if $path_to_check =~ /\S/
1323         100     71    558   if ($2) { }
1324         100      1     70   if ($last_token_is_sep)
1328         100      2    556   if (defined $last_token_is_sep and not $last_token_is_sep)
1334         100      1    506   if ($last_token_is_sep)
1348         100     21    485   $xpath_original =~ m[^\s*/(?!/)] ? :
1357  ***     50      0    553   $DEBUG_HANDLER >= 2 ? :
1359         100    169    384   if ($predicate)
1360  ***     50      0    169   if ($DEBUG_HANDLER >= 2)
1363  ***     50      0    169   if ($DEBUG_HANDLER >= 2)
1366         100    510     43   $tag ne '*' ? :
1372         100    552      1   if ($sep eq '/') { }
      ***     50      1      0   elsif ($sep eq '//') { }
1400  ***     50      0    553   $DEBUG_HANDLER >= 2 ? :
1411         100     21    485   if ($anchored)
1413  ***     50      0     21   $DEBUG_HANDLER >= 2 ? :
1417  ***     50      0    506   if $DEBUG_HANDLER >= 2
1419  ***     50      0    506   if $DEBUG_HANDLER >= 1
1421  ***     50      0    506   if ($@)
1424  ***     50      0    506   if $DEBUG_HANDLER >= 1
1425  ***     50      0    506   if $DEBUG_HANDLER >= 1
1441         100     44    365   if ($func or $string_regexp or $string_test_num or $string_test_alpha)
1443         100     89    320   if (defined $string) { }
             100    111    209   elsif ($att) { }
             100     14    195   elsif ($bare_att) { }
             100      2    193   elsif ($num_test and $num_test eq '=') { }
             100     89    104   elsif ($alpha_test) { }
             100     40     64   elsif ($func and $func =~ /^string/) { }
             100      2     62   elsif ($string_regexp and $string_regexp =~ /string\(\s*($REG_NAME)\s*\)\s*($REG_MATCH)\s*($REG_REGEXP)/) { }
             100      2     60   elsif ($string_test_alpha and $string_test_alpha =~ /string\(\s*($REG_NAME)\s*\)\s*($REG_COMP)\s*($REG_STRING)/) { }
      ***     50      0     60   elsif ($string_test_num and $string_test_num =~ /string\(\s*($REG_NAME)\s*\)\s*($REG_COMP)\s*($REG_NUMBER)/) { }
      ***     50      0     60   elsif ($and_or) { }
1444         100      2    109   $att =~ /^#/ ? :
1447         100      3     11   $bare_att =~ /^#/ ? :
1459  ***      0      0      0   $2 eq '=' ? :
1462  ***      0      0      0   $and_or eq 'and' ? :
1497  ***     50      0    296   if $$handlers{'attcond_handlers'}
1577         100     44     16   if ref $$handlers{$path} and isa($$handlers{$path}, 'CODE')
1587         100      2     59   if (my $type = $$handler_data{'test_on_text'})
1602         100      1   2779   if ($$t{'twig_parsing'})
1606         100   2778      1   if ($weakrefs)
1623         100      3      6   $@ ? :
1629         100      2      1   $@ ? :
1643         100      2      3   if $t->root
1652         100   2776  17890   unless $$t{'twig_current'}
1653         100   1757  16133   if ($$t{'twig_stored_spaces'} or $option{'force'} or $$t{'twig_preserve_space'})
1654         100      2   1755   if ($$t{'twig_current'}->is_pcdata) { }
1658         100    455   1300   unless (defined $$t{'twig_space_policy'}{$current_gi})
1661         100     90   1665   if ($$t{'twig_space_policy'}{$current_gi} or not $$t{'twig_stored_spaces'} =~ /\n/ or $option{'force'} or $$t{'twig_preserve_space'})
1686         100    103  10264   if ($$t{'twig_in_pcdata'})
1693         100   1310   9057   if (my $func = $$t{'parse_start_tag'}) { }
      ***     50      0   9057   elsif ($$t{'twig_entities_in_attribute'}) { }
1702         100     48  10319   if ($$t{'twig_read_external_dtd'})
1705         100      5  10362   if (my $filter = $$t{'twig_input_filter'})
1710         100     46  10321   if ($$t{'twig_map_xmlns'})
1717         100  10363      4   if ($weakrefs)
1720         100   7591   2776   if $parent
1724         100   7591   2776   if ($parent) { }
1726         100   5644   1947   if ($prev_sibling)
1728         100   5642      2   if ($weakrefs)
1731         100   7588      3   if ($weakrefs)
1732         100   1947   5644   unless ($$parent{'first_child'})
1733         100   7588      3   if ($weakrefs)
1739  ***     50      0   2776   if defined $$t{'twig_dtd_handler'}
1744         100     33   2743   if ($$t{'twig_default_print'}) { }
             100     33   2710   elsif ($$t{'twig_roots'}) { }
1752         100   1471   8896   $p->recognized_string =~ m[/\s*>$]s ? :
1754         100    639   9728   if $$t{'extra_data'}
1759         100    500   9867   if (defined $id)
1761         100    497      3   if ($weakrefs)
1765         100    100  10267   if ($$t{'twig_starttag_handlers'})
1772         100      1     30   unless &$handler($t, $elt)
1774         100      3     97   if (my $all = $$t{'twig_starttag_handlers'}{'handlers'}{$ALL})
1779         100     48  10319   if ($$t{'twig_ignore_elts_handlers'})
1782         100     13     35   if (@handlers)
1785         100      1  10366   if ($$elt{'att'}{'xml:space'} and $$elt{'att'}{'xml:space'} eq 'preserve')
1795         100     16     12   if (not $$t{'twig_keep_original_prefix'} and my $mapped_prefix = $$t{'twig_map_xmlns'}{$uri})
1798         100      3     25   if ($new_prefix eq '#default') { }
1804         100     13     35   if ($$t{'twig_keep_original_prefix'}) { }
1809         100     11      2   if ($$ns_info{'mapped_prefix'})
1815         100     15     15   if ($att_name) { }
1818         100      4     11   if ($$ns_info{'mapped_prefix'})
1827         100     11      2   if $map_att
1833         100     44     44   if ($att_name) { }
1848         100     13     15   unless $$ns_info{'uri'}
1859         100     22     14   if ($p->expand_ns_prefix($prefix) eq $uri)
1871         100     13     53   if (not exists $value{$att} and exists $$attlist{$att}{'default'} and $$attlist{$att}{'default'} ne '#IMPLIED')
1893         100   1320     18   if ($string =~ s[^<\s*($REG_NAME)\s*[\s>/]][]s) { }
1906         100   2779      1   if ($weakrefs)
1916         100     46  10226   if ($$t{'twig_map_xmlns'})
1925         100   6141   4131   if ($$t{'twig_in_pcdata'})
1927  ***     50   6141      0   if $$elt{'parent'}
1935         100   7518   2754   if ($parent)
1938         100      5   7513   if ($$parent{'twig_to_be_normalized'})
1941         100    317   9955   if ($$t{'extra_data'})
1946         100   3099   7173   if ($$t{'twig_handlers'})
1950         100     48   3051   if ($$t{'twig_tdh'}) { }
1951         100     29     19   if (@handlers)
1952         100     12     36   if (my $all = $$t{'twig_handlers'}{'handlers'}{$ALL})
1960         100    125    398   unless &$handler($t, $elt)
1962         100     33   3006   if (my $all = $$t{'twig_handlers'}{'handlers'}{$ALL})
1968         100     76  10184   if ($$t{'twig_root_depth'} and $p->depth == $$t{'twig_root_depth'})
1969         100     24     52   if ($$t{'twig_default_print'}) { }
1972         100      5     19   if ($$t{'twig_keep_encoding'}) { }
1981         100      1  10259   if ($$elt{'att'}{'xml:space'} and $$elt{'att'}{'xml:space'} eq 'preserve')
1990  ***     50      4      0   if (@{$$t{'twig_handlers_to_trigger'};})
1995  ***     50      0     41   unless &$handler($t, $handled_elt)
2012         100    695    380   if (my $found_path = &$trigger($$t{'_twig_context_stack'}))
2019         100     41   3664   if (not @found_handlers and defined $$handlers{'handlers'}{$DEFAULT})
2022         100      1   3704   if (@found_handlers and $$t{'twig_do_not_chain_handlers'})
2036         100     34     91   if (not $uri and not $name =~ /^xml/)
2037         100     75     50   if ($uri) { }
2038         100     68      7   if (my $mapped_prefix = $$t{'twig_map_xmlns'}{$uri}) { }
2042         100      1      6   if ($prefix eq '#default')
2043         100      6      1   $prefix ? :
2057         100   6556   9420   if ($$t{'twig_keep_encoding'})
2058         100    461   6095   if (not $$t{'twig_in_cdata'}) { }
2063         100   6055     40   if (length $string < 1024) { }
2074         100      2  15974   if ($$t{'twig_input_filter'})
2075         100      2  15974   if ($$t{'twig_char_handler'})
2079         100   6142   9834   if ($$t{'twig_in_cdata'}) { }
             100    257   9577   elsif ($$t{'twig_in_pcdata'}) { }
2085         100     72    185   if ($$t{'extra_data'})
2093         100   3296   6281   if ($string =~ /\A\s*\Z/s) { }
2095         100     34   3262   if ($$t{'extra_data'}) { }
2110         100     23   6258   if ($$t{'extra_data'})
2129         100     17     78   if ($$t{'twig_in_pcdata'}) { }
2131  ***     50     17      0   if ($weakrefs)
2134  ***     50     17      0   if ($weakrefs)
2135  ***     50     17      0   if ($weakrefs)
2140         100      5     73   if ($t->_space_policy($XML::Twig::index2gi[$$twig_current{'gi'}]) and $$t{'twig_stored_spaces'})
2145  ***     50     78      0   if ($weakrefs)
2146         100      8     70   if (my $prev_sibling = $$twig_current{'last_child'}) { }
2147  ***     50      8      0   if ($weakrefs)
2152  ***     50     78      0   if ($weakrefs)
2159         100      4     91   if ($$t{'extra_data'})
2178         100     16     79   if ($$t{'twig_handlers'})
2182         100      2      2   unless &$handler($t, $elt)
2199  ***     50      0      7   unless &$handler($t, $pi)
             100      7      7   if ($handler)
2204         100      1   1502   if (my $handler = $$t{'twig_handlers'}{'pi_handlers'}{$target})
2206         100      1   1501   if (my $handler = $$t{'twig_handlers'}{'pi_handlers'}{''})
2208         100   1473     28   defined $data && $data ne '' ? :
2213         100      6   1747   if (my $handler = $$t{'twig_handlers'}{'handlers'}{'#COMMENT'})
2219         100      4   1875   if (my $handler = $$t{'twig_handlers'}{'handlers'}{'#COMMENT'})
2221         100      2      2   if (not defined $comment or $comment eq '')
2234         100   1751   1886   if ($$t{'twig_keep_encoding'})
2248         100   1459   1513   if ($$t{'twig_keep_encoding'})
2262         100      2   6607   if ($$t{'twig_input_filter'})
2266         100   3382   3227   if ($keep) { }
             100   3216     11   elsif ($process) { }
2268         100     22   3360   if ($$t{'twig_stored_spaces'})
2283         100    676   2540   if ($$t{'extra_data'})
2288         100   1451   1765   if (not $t->root) { }
             100      7   1758   elsif ($$t{'twig_in_pcdata'}) { }
             100    312   1446   elsif ($twig_current) { }
2298         100      1    311   if ($t->_space_policy($XML::Twig::index2gi[$$twig_current{'gi'}]) and $$t{'twig_stored_spaces'})
2307         100    319   2897   if ($twig_current)
2333         100      6   2761   $p->isa('XML::Twig') ? :
2336         100    579   2188   if ($$t{'extra_data'})
2339         100    236   2531   if ($$t{'twig_stored_spaces'})
2344         100      4   2763   if $$t{'twig_tdh'}
2346         100      4   2763   if $$t{'twig_original_selected_fh'}
2348         100     11   2756   if (exists $$t{'twig_autoflush_data'})
2350         100      5      6   if $$t{'twig_autoflush_data'}{'fh'}
2351         100      1     10   if $$t{'twig_autoflush_data'}{'args'}
2373         100    156   6221   if ($prev_sibling) { }
2375  ***     50    156      0   if ($weakrefs)
2380         100   6376      1   if ($weakrefs)
2381         100   6376      1   if ($weakrefs)
2389         100    808     37   if $$t{'twig_discard_spaces'}
2390         100     37    808   if $$t{'twig_keep_spaces'}
2391         100      8    837   if $$t{'twig_keep_spaces_in'} and $$t{'twig_keep_spaces_in'}{$gi}
2393         100      6    839   if $$t{'twig_discard_spaces_in'} and $$t{'twig_discard_spaces_in'}{$gi}
2409         100     31     37   if ($sysid)
2410         100     15     16   if ($ndata) { }
2411         100     14      1   if (not -f _based_filename($sysid, $p->base))
2414         100      4     12   if ($$t{'twig_expand_external_ents'})
2416         100      2      2   if (not defined $val)
2417         100      1      1   if ($$t{'twig_extern_ent_nofail'}) { }
2427         100     15     52   if ($missing_entity)
2430  ***     50     67      0   if ($entity_list)
2432  ***     50     67      0   if ($parser_version > 2.27)
2436         100      3     64   if ($$t{'twig_keep_encoding'})
2437  ***     50      0      3   if (defined $$ent{'val'} and not $ent_decl =~ /["']/)
2439  ***      0      0      0   $val =~ /"/ ? :
2444  ***     50     67      0   unless $$t{'twig_doctype'}{'internal'} =~ /<!ENTITY\s+$name\s+/
2456  ***     50      0      7   if ($$t{'twig_no_expand'})
2457  ***      0      0      0   $$t{'twig_keep_encoding'} ? :
2462         100      1      6   if (not defined $ent_content)
2467  ***     50      0      1   if ($$t{'twig_extern_ent_nofail'}) { }
2502  ***     50     77      0   if ($parser_version > 2.27) { }
2518         100      5     72   if ($$t{'twig_read_external_dtd'} and $sysid)
2527  ***     50      5      0   if $t_dtd->entity_list
2543  ***     50     44      0   if ($parser_version > 2.27 and $$t{'twig_doctype'}{'internal'} =~ /(^|>)\s*$/)
2544  ***     50      0     44   $XML::Twig::Elt::keep_encoding ? :
2545  ***     50     44      0   unless ($text)
2564  ***     50     37      0   if ($parser_version > 2.27 and $$t{'twig_doctype'}{'internal'} =~ /(^|>)\s*$/)
2565  ***     50      0     37   $XML::Twig::Elt::keep_encoding ? :
2566  ***     50     37      0   unless ($text)
2570         100      6     31   if $fixed
2571  ***     50     37      0   if defined $default
2573         100     15     22   if ($$t{'twig_dtd'}{'att'}{$gi}) { }
2586  ***     50     37      0   if defined $default
2601         100    236     97   if (not $$t{'twig_current'} and $$t{'twig_root'} and $string =~ /^\s+$/m)
2604         100     36    297   if ($string =~ /^&([^;]*);$/)
2606  ***     50      0     36   if ($p->original_string =~ /^</ and $p->original_string =~ />$/) { }
2608  ***      0      0      0   if $$t{'twig_do_not_escape_amp_in_atts'}
2612         100      9     27   if ($$t{'twig_keep_encoding'}) { }
2637         100     13     14   if ($$t{'twig_in_pcdata'}) { }
2640  ***     50     13      0   if ($weakrefs)
2643  ***     50     13      0   if ($weakrefs)
2644  ***     50     13      0   if ($weakrefs)
2653  ***     50     14      0   if ($weakrefs)
2654         100      8      6   if (my $prev_sibling = $$twig_current{'last_child'}) { }
2655  ***     50      8      0   if ($weakrefs)
2659  ***     50      6      0   if ($twig_current)
2660  ***     50     14      0   if ($weakrefs)
      ***     50     14      0   if ($twig_current)
2676         100   2216     55   unless $$t{'twig_xmldecl'} or $$t{'output_encoding'}
2679         100     51      4   if ($decl) { }
2686         100     13     38   if ($$t{'output_encoding'}) { }
             100     15     23   elsif ($$decl{'encoding'}) { }
2695         100     10     41   if (defined $$decl{'standalone'})
2697         100      4      6   $$decl{'standalone'} ? :
2709         100     17     38   $output_filter ? :
2714         100      1      3   unless defined $$t{'twig_doctype'}
2716  ***     50      4      0   if defined $name
2717         100      3      1   if defined $system
2718         100      2      2   if defined $public
2719         100      1      3   if defined $internal
2724         100      1      3   unless my $doctype = $$t{'twig_doctype'}
2730         100      1      3   unless my $doctype = $$t{'twig_doctype'}
2736         100      1      3   unless my $doctype = $$t{'twig_doctype'}
2742         100      1      3   unless my $doctype = $$t{'twig_doctype'}
2756         100      2      1   if $elt
2783  ***     50      0    886   _is_fh($_[0]) ? :
2790         100      3   2269   if ($$t{'no_prolog'})
2792         100      2   2267   defined $$t{'no_dtd_output'} ? :
      ***     50      0   2269   $$t{'no_prolog'} ? :
2805         100     43   2228   if ($doctype)
2806  ***     50     43      0   if $$doctype{'name'}
2807         100      5     38   if $$doctype{'pub'}
2808         100     19     24   if $$doctype{'sysid'} and not $$doctype{'pub'}
2809         100     24     19   if $$doctype{'sysid'}
2812         100      9   2262   if ($update_dtd) { }
             100     36   2226   elsif ($doctype) { }
2813         100      7      2   if ($doctype) { }
      ***     50      2      0   elsif (not $$t{'twig_dtd'} and keys %{$t->entity_list;}) { }
2816         100      5      2   if ($internal)
2821  ***     50      7      0   if $t->entity_list
2822         100      4      3   if ($internal)
2832         100     23     13   if (my $internal = $$doctype{'internal'})
2844         100     45   2226   if ($doctype_text) { }
2851  ***     50      0     45   $output_filter ? :
2876         100      1      1   unless open TWIG_PRINT_TO_FILE, ">$filename"
2877  ***     50      1      0   if ($] > 5.006 and not $$t{'twig_keep_encoding'})
2878  ***     50      1      0   if (grep /useperlio=define/, `$^X -V`)
2888         100     17      3   _is_fh($_[0]) ? :
2891         100     17      3   defined $fh ? :
2892         100      1     19   defined $args{'PrettyPrint'} ? :
2893         100      1     19   defined $args{'EmptyTags'} ? :
2903         100      1     19   if defined $old_pretty
2904         100      1     19   if defined $old_empty_tag
2905         100     17      3   if ($fh)
2914  ***     50      0    909   if $$t{'twig_tdh'}
2916         100      8    901   if $$t{'twig_completely_flushed'}
2918         100    885     16   _is_fh($_[0]) ? :
2919         100    885     16   defined $fh ? :
2920         100     18    883   ref $_[0] ? :
2924         100      6    895   if (defined $args{'PrettyPrint'})
2930         100      8    893   if ($args{'EmptyTags'})
2939         100     18    883   if ($up_to) { }
             100      6    877   elsif ($$t{'twig_current'}) { }
2951         100    886     15   unless ($elt->_flushed)
2953         100    877      9   if ($$t{'twig_autoflush'})
2955         100    871      6   if $fh
2956         100      1    876   if @_
2964         100     31    920   if ($last_elt and $last_elt->in($elt)) { }
2966         100     25      6   unless ($elt->_flushed)
2978         100    901     19   if $last_elt and $elt == $last_elt
2983         100    877     24   if ($flush_trailing_data)
2988         100    885     16   if defined $old_select
2989         100      6    895   if defined $old_pretty
2990         100      8    893   if defined $old_empty_tag_style
2992  ***     50      0    901   if (my $ids = $$t{'twig_id_list'})
2993  ***      0      0      0   if (not defined $elt)
3004         100     10      8   if (_is_fh($_[0])) { }
3021         100      8   1357   if (defined $args{'PrettyPrint'})
3027         100     12   1353   if (defined $args{'EmptyTags'})
3038         100      4   1361   if ($$t{'twig_keep_spaces'} and $$t{'trailing_spaces'})
3040         100      8   1357   if defined $old_pretty
3041         100     12   1353   if defined $old_empty_tag_style
3055  ***     50      0     10   if $$t{'twig_tdh'}
3059         100      7      3   if ($up_to) { }
             100      2      1   elsif ($$t{'twig_current'}) { }
3070         100     13     16   if ($last_elt and $last_elt->in($elt)) { }
3078         100     10      6   if $last_elt and $elt == $last_elt
3083         100      2      8   if (my $ids = $$t{'twig_id_list'})
3084         100      4      4   if (not defined $elt)
3105  ***     50      0      3   if $] < 5.006
3108         100      2      1   ref $twig_or_class ? :
3113         100      1      3   if $elt_class->can($att) and not $accessor{$att}
3116         100      2      1   if (not $accessor{$att})
3120         100      2      9   if (@_)
3134         100      5     82   if $root->passes($cond)
3146         100      2      2   if $t->root->matches($cond)
3152         100      1    149   if (isa($_[0], 'ARRAY')) { }
3165         100    275      4   unless @unique and $unique[-1] == $current
3171         100      1     11   if (isa($_[0], 'ARRAY')) { }
3188         100      8      2   defined $index ? :
3196         100     79      3   if (not $cond && !$root->passes($cond)) { }
3215         100     44     35   if ($root->passes($cond)) { }
3250         100      2      2   unless $index = $XML::Twig::gi2index{$old_gi}
3262  ***     50      0      4   unless my $doctype = $$t{'twig_doctype'}
3269         100      2      3   if ($$dtd{'att'}{$gi})
3274         100      1      3   if ($$attlist{$att}{'fixed'}) { }
3283  ***     50      4      0   if $t->entity_list
3291         100      2      1   _is_fh($_[0]) ? :
3292         100      2      1   if ($fh) { }
3309         100     16     18   unless $$t{'twig_parsing'}
3317  ***     50      0     17   if ($$t{'twig_map_xmlns'}) { }
3332         100      2      4   if (not defined $fh) { }
      ***     50      4      0   elsif (defined $fh) { }
3336  ***     50      4      0   if $old_fh
3340         100      1      5   if ($$t{'twig_keep_encoding'}) { }
3358         100      2      2   if (not $input_filter or isa($input_filter, 'CODE')) { }
      ***     50      0      2   elsif ($input_filter eq 'latin1') { }
      ***     50      0      2   elsif ($filter{$input_filter}) { }
3418  ***     50      0   2756   if ($$t{'twig_root'} and isa($$t{'twig_root'}, 'XML::Twig'))
3423         100   2708     48   if $$t{'twig_root'}
3443  ***     50      0     15   if ($string eq '<!DOCTYPE') { }
3459  ***     50      0    474   if ($expat_1_95_2 and $p->recognized_string eq '[' and not $$p{'twig'}{'expat_1_95_2_seen_bracket'}) { }
3483  ***     50      0      3   if ($string eq '<!DOCTYPE') { }
3506  ***     50      5      0   if ($name)
3510  ***     50      5      0   if $name
3511  ***     50      0      5   if $pubid
3512         100      1      4   if $sysid and not $pubid
3513         100      1      4   if $sysid
3514         100      3      2   if $internal and not $expat_1_95_2
3515         100      2      3   unless $internal or $expat_1_95_2
3526  ***     50     11      0   if ($name)
3530  ***     50     11      0   if $name
3531  ***     50      0     11   if $pubid
3532         100      7      4   if $sysid and not $pubid
3533         100      7      4   if $sysid
3534         100      3      8   if $internal
3535         100      8      3   unless $internal or $expat_1_95_2
3568         100    307     66   unless ($p->depth == 0)
3569         100      2    305   if ($$t{'twig_map_xmlns'})
3575         100     78    295   if (_handler($t, $$t{'twig_roots'}, $gi))
3584         100     16    126   $$t{'twig_keep_encoding'} ? :
             100    142    153   $$t{'twig_default_print'} ? :
3588         100     64    231   if ($p->depth == 0) { }
             100     23    208   elsif ($$t{'twig_starttag_handlers'}) { }
3590         100     33     31   if $tag
3602  ***     50      0     13   unless $last_handler_res
3605         100     12     11   if $tag and !@handlers || $last_handler_res
3609         100     97    111   if $tag
3620         100     16    126   $$t{'twig_keep_encoding'} ? :
             100    142    153   $$t{'twig_default_print'} ? :
3625         100     34    261   if ($$t{'twig_endtag_handlers'})
3631  ***     50      0     34   if (not $last_handler_res)
3638         100    142    153   if defined $tag
3640         100     64    231   if ($p->depth == 0)
3654  ***     50      0     18   $$t{'twig_keep_encoding'} ? :
             100     18      1   $$t{'twig_default_print'} ? :
3659         100      1     18   if (my $handler = $$t{'twig_handlers'}{'pi_handlers'}{$target} || $$t{'twig_handlers'}{'pi_handlers'}{''}) { }
3671  ***     50     18      0   if defined $pi
3684  ***     50      0     48   if ($action eq 'print')
3698  ***     50      0    110   if ($action eq 'print')
3705         100     46     64   if (not $$t{'twig_ignore_level'})
3719         100     12     34   if ($$t{'twig_endtag_handlers'})
3737         100     19     30   if (not $elt && ref $elt && isa($elt, 'XML::Twig::Elt'))
3743         100      2     47   unless ($elt == $current or $$current{'last_child'} and $elt == $$current{'last_child'} or $current->in($elt))
3746         100     32     15   $current == $elt ? :
3755  ***     50      0     47   if ($action eq 'print')
3770         100     30     53   if ($$elt_in_stack{'_elt'} and $elt == $$elt_in_stack{'_elt'})
3781         100     31   2774   if ($output_fh and not $$t{'twig_output_fh_selected'})
3793         100   2736     31   unless $$t{'twig_output_fh'}
3802  ***     50      5      0   if $_[0]{'twig_xmldecl'}
3807  ***     50      0      4   unless $t->xml_version
3819         100     16      2   if ($encoding and not $encoding =~ /^utf-?8$/i or $$t{'twig_keep_encoding'} or $output_filter)
3827  ***     50      7      0   if $_[0]{'twig_xmldecl'}
3837  ***     50      2      0   if $_[0]{'twig_xmldecl'}
3842  ***     50      0      1   unless $t->xml_version
3851         100      1      1   if defined $_[0]{'twig_parser'}
3858         100      1      4   if defined $_[0]{'twig_parser'}
3868         100      4      1   if (my $start_document = $handler->can('start_document'))
3873  ***     50      5      0   if ($t->root)
3874  ***     50      5      0   if (my $end_document = $handler->can('end_document'))
3896         100      4      2   if ($$t{'twig_current'}) { }
3902         100      2      4   unless ($elt->_flushed)
3904  ***     50      2      0   if (my $start_document = $handler->can('start_document'))
3912         100      6     12   if ($last_elt and $last_elt->in($elt)) { }
3914         100      4      2   unless ($elt->_flushed)
3916  ***     50      4      0   if (my $start_element = $handler->can('start_element'))
3917  ***     50      4      0   if (my $tag_data = &$start_tag_data($elt))
3929         100      6      6   if $last_elt and $elt == $last_elt
3933         100      2      4   if (not $$t{'twig_parsing'})
3934  ***     50      2      0   if (my $end_document = $handler->can('end_document'))
3953         100      4      3   if (my $xml_decl = $handler->can('xml_decl'))
3960         100      5      2   unless $doctype
3966  ***     50      2      0   if (my $start_dtd = $handler->can('start_dtd'))
3971  ***     50      2      0   if (my $end_dtd = $handler->can('end_dtd'))
3979  ***     50      2      0   if (_use('Encode')) { }
      ***      0      0      0   elsif (_use('Text::Iconv')) { }
      ***      0      0      0   elsif (_use('Unicode::Map8') and _use('Unicode::String')) { }
3993  ***     50     16      0   if (_use('Encode')) { }
      ***      0      0      0   elsif (_use('Text::Iconv')) { }
      ***      0      0      0   elsif (_use('Unicode::Map8') and _use('Unicode::String')) { }
4017  ***     50      0      5   unless _use('HTML::Entities')
4023  ***     50      0     19   if ($] < 5.008) { }
4035  ***     50      0     19   if ($] < 5.008) { }
4052  ***     50      4      0   if ($len == 2) { }
      ***      0      0      0   elsif ($len == 3) { }
      ***      0      0      0   elsif ($len == 4) { }
      ***      0      0      0   elsif ($len == 1) { }
4070         100      2      2   $hex ? :
4076  ***     50      1      0   $_[1] ? :
4077  ***     50      0      1   unless _use('Unicode::Map8')
4078  ***     50      0      1   unless _use('Unicode::String')
4080  ***     50      0      1   unless $cnv = 'Unicode::Map8'->new($enc)
4088  ***     50      0      1   unless ($sub)
4093  ***     50      4      0   $_[1] ? :
4094  ***     50      0      4   unless _use('Text::Iconv')
4095  ***     50      0      2   unless $cnv = 'Text::Iconv'->new('utf8', $enc)
      ***     50      0      1   unless $cnv = 'Text::Iconv'->new('utf8', $enc)
4103         100      1      3   unless ($sub)
4104  ***     50      0      1   if ($@ =~ /^Unsupported conversion: Invalid argument/) { }
4114  ***     50      0     18   $_[1] ? :
4116  ***     50      0     18   unless $sub
4124         100     93     74   wantarray ? :
4134  ***     50      5      0   if ($t->root)
4167         100      2      3   unless $ents_to_add and %$ents_to_add
4188         100      1      3   if (isa(ref $_[0], 'XML::Twig::Entity')) { }
4204  ***     50      0      2   defined $fh ? :
4209  ***     50      4      0   if (isa($ent, 'XML::Twig::Entity'))
4211  ***     50      0      2   if defined $old_select
4246         100     45     35   if defined $val
4247         100     36     44   if defined $sysid
4248         100      5     75   if defined $pubid
4249         100     18     62   if defined $ndata
4250         100      4     76   if defined $param
4259         100      2      1   defined $_[0]{'sysid'} ? :
4260  ***     50      0      2   defined $_[0]{'pubid'} ? :
4261         100      1      1   defined $_[0]{'ndata'} ? :
4262         100      1      1   defined $_[0]{'param'} ? :
4268  ***     50      0     14   if (not defined $text)
4269  ***     50      0     14   if ($fh) { }
4276  ***     50      0      3   if (not defined $text)
4282         100      2    109   if not $$ent{'name'}
4286         100      4    105   if $$ent{'param'}
4289         100     57     52   if (defined $$ent{'val'} and not defined $$ent{'sysid'} and not defined $$ent{'pubid'}) { }
      ***     50     52      0   elsif (defined $$ent{'sysid'}) { }
4293         100      4     48   if $$ent{'pubid'}
4294         100     48      4   unless $$ent{'pubid'}
4296         100     33     19   if $$ent{'ndata'}
4302  ***     50      0    113   $_[0] =~ /"/ ? :
4402  ***     50     92      0   if (eval 'require Scalar::Util' and defined &Scalar::Util::weaken) { }
      ***      0      0      0   elsif (eval 'require WeakRef') { }
4421         100      4  22158   unless @_
4428         100     75  22083   ref $_[0] eq 'HASH' ? :
4430         100      4  22154   if ($atts and defined $$atts{'#CDATA'})
4437         100   6673  15481   if ($gi eq '#PCDATA') { }
             100     45  15436   elsif ($gi eq '#ENT') { }
             100    104  15332   elsif ($gi eq '#CDATA') { }
             100   1758  13574   elsif ($gi eq '#COMMENT') { }
             100   1469  12105   elsif ($gi eq '#PI') { }
4438         100      1   6672   if (grep {ref $_;} @_)
4444         100      1    103   if (grep {ref $_;} @_)
4448         100      1   1757   if (grep {ref $_;} @_)
4452         100      1   1468   if (grep {ref $_;} @_)
4457         100     96  12009   if (@_) { }
4463         100     71  22079   if ($atts)
4465         100      2     69   if (defined $$atts{'#ASIS'})
4466         100      2     69   if (defined $$atts{'#EMPTY'})
4467         100     29     42   if (keys %$atts)
4468         100      1     70   if $$atts{$ID}
4481         100      2     20   if (ref $class)
4490         100      5     17   if ($$t{'twig_id_list'})
4507         100      1      3   if ($elt->tag eq 'head') { }
             100      2      1   elsif ($elt->tag ne 'html') { }
4524         100    666  21518   unless (defined $XML::Twig::gi2index{$gi})
4548         100     52     73   if ($qname =~ /^([^:]*):/) { }
4569         100     35     35   defined $_[0] ? :
4570         100     23     47   $prefix ? :
4581  ***      0      0      0   $prefix eq '#default' ? :
4582  ***      0      0      0   if (not $$root{'att'}{$prefix_att})
4595  ***      0      0      0   $att =~ /^xmlns:(.*)$/ ? :
      ***      0      0      0   $att eq 'xmlns' ? :
4599  ***      0      0      0   if (not exists $$map{$prefix})
4608  ***      0      0      0   $prefix ? :
4617  ***      0      0      0   if ($elt->_ns_prefix and $elt->namespace eq $uri)
4620  ***      0      0      0   if $_ =~ /xmlns(:|$)/
4639         100      1      5   if $gi_nb >= $XML::Twig::SPECIAL_GI
4645         100   1456    271   if ($_[0]{'gi'} >= $XML::Twig::SPECIAL_GI) { }
4687  ***     50      0      1   defined $_[1] ? :
4690  ***     50      1      0   if $_[0]{'empty'} or 0
4698         100      2     21   if (exists $$descendant{'cdata'})
4710  ***     50      2      0   if $$descendant{'asis'}
4721         100      1     14   unless $curr_elt
4728         100     12    318   if ($elt->_extra_data_in_pcdata)
4747         100      2      7   if ($$elt{'extra_data_before_end_tag'}) { }
4763         100      2     10   if ((my $offset = index($modified, $initial)) != -1) { }
             100      4      6   elsif (($offset = index($initial, $modified)) != -1) { }
4771         100      2      2   if $$_{'offset'} >= 0
4774         100      3      3   unless _match_extra_data_words($elt, $initial, $modified) or _match_extra_data_chars($elt, $initial, $modified)
4801         100      5      5   if (@$initial <= @$modified) { }
4804         100      2      3   if ($ok)
4819         100      1      4   if ($ok)
4833  ***     50      1      0   if ($$cpi{'offset'} < $prev_pos)
4850         100     10     12   if ($s_word ne $l_word)
4855         100      7      3   if (not @$long and $s_word ne $l_word)
4901  ***     50      1      0   unless ($$elt{'gi'} == $XML::Twig::gi2index{'#PI'})
4916  ***     50   1464      0   if (defined $data and $data ne '')
4923         100      1      6   unless ($$elt{'gi'} == $XML::Twig::gi2index{'#COMMENT'})
4940         100      1      1   unless ($$elt{'gi'} == $XML::Twig::gi2index{'#CDATA'})
4963         100     18     24   unless $elt->is_elt
4965         100      9     16   if $child->is_elt
4973         100      2      5   unless $child->is($exp)
4979         100    106     50   unless my $child = $$elt{'first_child'}
4980         100      3     47   unless $child->passes($exp)
4981         100      2     45   if $$child{'next_sibling'}
5034         100      2    312   $cond =~ s/^\s*!// ? :
5036         100      1    313   if (ref $cond eq 'CODE')
5038         100      3    310   if (ref $cond eq 'Regexp') { }
5042         100      6    304   if ($cond eq '#ELT') { }
             100     11    293   elsif ($cond eq '#TEXT') { }
             100    128    165   elsif ($cond =~ /^\s*($REG_NAME_W)\s*$/o) { }
             100      2    163   elsif ($cond =~ /^\s*($REG_REGEXP)\s*$/o) { }
             100     47    116   elsif ($cond =~ /^\s*($REG_NAME_W)?\s*  # $1
                           \[\s*(-?)\s*(\d+)\s*\] #   [$2]
                           \s*$/ox) { }
             100      4    112   elsif ($cond =~ /^\s*\.([\w-]+)\s*$/o) { }
             100     93     19   elsif ($cond =~ /^\s*($REG_NAME_W?)\s*($REG_PREDICATE)\s*$/) { }
             100     14      5   elsif ($cond =~ /^\s*($REG_NAKED_PREDICATE)\s*$/) { }
5048         100    127      1   if ($1 ne '*') { }
5052         100    102     25   if ($gi) { }
5074         100     20     27   $neg ? :
5075         100     30     17   if ($gi and $gi ne '*') { }
5087         100     48     45   $tag && $tag ne '*' ? :
5101         100      4    304   if ($@)
5115         100     60    219   if (defined $string) { }
             100     76    143   elsif ($att) { }
             100     11    132   elsif ($bare_att) { }
      ***     50      0    132   elsif ($num_test and $num_test eq '=') { }
             100     60     72   elsif ($alpha_test) { }
             100      7     65   elsif ($func and $func =~ /^(?:string|text)/) { }
             100      9     56   elsif ($string_regexp and $string_regexp =~ /(?:string|text)\(\s*($REG_NAME)\s*\)\s*($REG_MATCH)\s*($REG_REGEXP)/) { }
             100     17     39   elsif ($string_eq and $string_eq =~ /(?:string|text)\(\s*($REG_NAME)\s*\)\s*(!?=)\s*($REG_VALUE)/) { }
      ***     50      0     39   elsif ($string_test and $string_test =~ /(?:string|text)\(\s*($REG_NAME)\s*\)\s*([<>]=?)\s*($REG_VALUE)/) { }
             100     16     23   elsif ($and_or) { }
5124         100      5     11   $and_or eq 'and' ? :
5151         100     78      4   if ($op eq '=') { }
             100      3      1   elsif ($op eq '!=') { }
5158         100   3181    605   unless $cond
5166  ***      0      0      0   if ($XML::Twig::weakrefs)
5205         100      1      2   if ($child) { }
5208         100      1      1   if ($cond =~ /^\s*($REG_NAME)/) { }
5221  ***     50     29      0   if ($XML::Twig::weakrefs)
5237  ***      0      0      0   if ($XML::Twig::weakrefs)
5269         100      1      5   unless $new_class
5271  ***     50      5      0   $class ? :
5287         100      1      1   unless $elt->tag eq 'span' and $elt->class
5293         100      1      1   unless $elt->tag eq 'div' and $elt->class
5300  ***     50      0     14   unless defined $elt_class
5301         100      9      5   $elt->class =~ /(?:^|\s)\Q$class\E(?:\s|$)/ ? :
5310         100     49  10390   if keep_atts_order()
5311         100     72  10367   isa($_[0] || '', 'HASH') ? :
5313         100    507   9932   if (exists $atts{$ID})
5325  ***     50      0     93   if ($_[0] and ref $_[0] and not $_[1])
5328         100      4     89   unless ($$elt{'att'})
5330         100      2      2   if keep_atts_order()
5336         100     55     38   if ($att eq $ID)
5360         100      1      1   unless defined $value
5369  ***      0      0      0   if ($att ne lc $att)
5380         100      5     46   if exists $$elt{'att'}{$ID}
5391         100    611      3   if ($XML::Twig::weakrefs)
5407         100      1     39   if (defined $$elt{'att'}{$ID}) { }
5410  ***     50      0     39   $_[0] && ref $_[0] && isa($_[0], 'CODE') ? :
5419  ***     50      0     15   unless (exists $$elt{'att'})
5420         100      5     10   unless (exists $$elt{'att'}{$ID})
5426         100      2      8   unless ($t)
5427  ***     50      8      0   if (exists $$t{'twig_id_list'}{$id})
5473         100   1121      7   if $child->passes($cond)
5482         100      2      1   wantarray ? :
5489         100      1      1   wantarray ? :
5496         100      2      2   unless $child->passes($cond)
5506         100   1983      9   if $elt->passes($cond)
5515         100     30      8   if $elt->passes($cond)
5524         100      1      1   $include_self ? :
5536         100      8   6079   if (defined $$elt{'att'}{$att} and !%tags || $tags{$XML::Twig::index2gi[$$elt{'gi'}]})
5550         100     40     81   if (defined $$elt{'att'}{$att} and !%tags || $tags{$XML::Twig::index2gi[$$elt{'gi'}]})
5562         100      2      1   if $elt->namespace('')
5584         100    287    125   if defined $_[0] and (ref $_[0] and isa($_[0], 'XML::Twig::Elt'))
5590         100    395     17   if ($cond)
5591         100    290    105   unless (defined($ind = $XML::Twig::gi2index{$cond}))
5596         100    352    247   if ($next_elt = $$elt{'first_child'}) { }
             100     81    166   elsif ($next_elt = $$elt{'next_sibling'}) { }
5603         100      3     78   if $subtree_root and $elt == $subtree_root
5611         100      2    164   if $subtree_root and $elt == $subtree_root
5616         100     88     69   if $subtree_root and $subtree_root == $next_elt
5619         100      4     61   if $subtree_root and $subtree_root == $next_elt
5640         100     23     15   if (not $cond or $last_descendant->matches($cond)) { }
5661         100     17     20   if (defined $_[0] and (ref $_[0] and isa($_[0], 'XML::Twig::Elt')))
5663         100      2     15   if $elt == $subtree_root
5669         100      3    102   if $elt == $subtree_root
5670         100     37     65   if ($prev_elt = $$elt{'prev_sibling'}) { }
5686         100      6      1   $elt ? :
5692         100      4      2   if not $cond or $elt->matches($cond)
5698         100      4      2   if (not $cond)
5700         100      5      1   if ($following) { }
5714         100      3      4   $elt ? :
5720         100      1      2   if not $cond or $elt->matches($cond)
5726         100      4      3   if (not $cond)
5728         100      3      4   if ($preceding) { }
5741         100      4      2   $cond ? :
5755         100   2473      2   if (ref $ancestor and isa($ancestor, 'XML::Twig::Elt')) { }
5757         100    364   2324   if $elt == $ancestor
5761         100      1      1   if $elt->matches($ancestor)
5768         100      2     11   unless my $dest = $elt->first_child(@_)
5779         100      3      1   unless my $dest = $elt->first_child(@_)
5785         100      1      2   unless my $dest = $$elt{'first_child'}
5791         100      1      2   unless my $dest = $elt->last_child(@_)
5797         100      1      1   unless my $dest = $elt->last_child(@_)
5803         100      1      5   unless my $dest = $$elt{'last_child'}
5809         100      1      1   unless my $dest = $elt->child(@_)
5815         100      1      1   unless my $dest = $elt->child(@_)
5822         100      1      1   unless my $dest = $elt->child($nb)
5828         100      1      1   unless my $dest = $elt->_prev_sibling(@_)
5834         100      1      1   unless my $dest = $elt->_prev_sibling(@_)
5840         100      1      2   unless my $dest = $$elt{'prev_sibling'}
5846         100      1      2   unless my $dest = $elt->next_sibling(@_)
5852         100      1      1   unless my $dest = $elt->next_sibling(@_)
5858         100      1      1   unless my $dest = $$elt{'next_sibling'}
5864         100      1      1   unless my $dest = $elt->prev_elt(@_)
5870         100      1      1   unless my $dest = $elt->prev_elt(@_)
5876         100      1      2   unless my $dest = $elt->prev_elt
5882         100      1      1   unless my $dest = $elt->next_elt(@_)
5888         100      1      1   unless my $dest = $elt->next_elt(@_)
5894         100      1      2   unless my $dest = $elt->next_elt
5900         100      1      3   unless my $dest = $elt->parent(@_)
5906         100      1      1   unless my $dest = $elt->parent(@_)
5912         100      2      6   unless my $dest = $$elt{'parent'}
5918         100      1      8   unless my $parent = $$elt{'parent'}
5919         100      1      7   unless my $first_child = $parent->first_child(@_)
5920         100      4      3   $first_child == $elt ? :
5925         100      1      8   unless my $parent = $$elt{'parent'}
5926         100      1      7   unless my $last_child = $parent->last_child(@_)
5927         100      3      4   $last_child == $elt ? :
5937         100    408      4   if not $cond or $elt->matches($cond)
5944         100     12      6   unless $level
5947         100      8     24   unless $elt = $$elt{'parent'}
5948         100      8     16   if ($elt->matches($cond))
5956         100     13     30   $include_self ? :
5962         100     59     62   if ($next_elt = $$elt{'first_child'}) { }
             100      7     55   elsif ($next_elt = $$elt{'next_sibling'}) { }
5969         100      4      3   if $elt == $subtree_root
5976         100     15     40   if $elt == $subtree_root
5981         100     18     19   if $subtree_root == $next_elt
5984         100      6     16   if $subtree_root == $next_elt
6003         100    114     89   if (not $cond or defined($ind = $XML::Twig::gi2index{$cond})) { }
6008         100    804    646   if ($next_elt = $$elt{'first_child'}) { }
             100    118    528   elsif ($next_elt = $$elt{'next_sibling'}) { }
6015  ***     50      0    118   if $subtree_root and $elt == $subtree_root
6022         100      3    525   if $subtree_root and $elt == $subtree_root
6027         100    111    279   if $subtree_root and $subtree_root == $next_elt
6030         100    111    414   if $subtree_root and $subtree_root == $next_elt
6034         100    900    436   if not $cond or $$elt{'gi'} eq $ind
6049         100      6     37   $elt->passes($cond) ? :
6057         100      4      5   if ($nb > 0) { }
             100      3      2   elsif ($nb < 0) { }
6059         100      2      2   unless $elt = $elt->next_sibling(@_)
6063         100      1      2   unless $elt = $elt->prev_sibling(@_)
6072         100      2      1   $elt ? :
6079         100     27     16   if ($nb >= 0) { }
6080         100      7     20   unless $elt = $elt->first_child(@_)
6082         100      1     19   unless $elt = $elt->next_sibling(@_)
6085         100      3     13   unless $elt = $elt->last_child(@_)
6087         100      1     15   unless $elt = $elt->prev_sibling(@_)
6102         100      8      9   if $_[0] and not $elt->matches(@_)
6141         100    153     14   if ($xpath_exp =~ s[^/][]) { }
             100      6      8   elsif ($xpath_exp =~ s[^\./][]) { }
6160         100      4    286   if ($sub_exp eq '..') { }
             100      1    285   elsif ($sub_exp =~ /^\.(.*)$/s) { }
6161  ***     50      0      4   if $wildcard
6170         100    252     33   if (not $axis)
6171         100     85    167   $wildcard ? :
6172         100     81    204   if (not $gi or $gi eq '*')
6176         100     30    255   if ($predicates and $predicates =~ /^\s*\[\s*((-\s*)?\d+)\s*\]\s*$/) { }
             100      3    252   elsif ($predicates and $predicates =~ /^\s*\[\s*last\s*\(\s*\)\s*\]\s*$/) { }
6179         100     19     11   if $offset > 0
6180  ***     50     30      0   $axis eq 'child' ? :
      ***     50      0     30   $axis eq 'descendant' ? :
6188  ***     50      0      3   if $wildcard
6205         100     18    113   if ($pred =~ /^(-?\s*\d+)$/) { }
6207         100     16      2   if ($step =~ /^\s*grep(.*) (\$_->\w+\(\s*'[^']*'\s*\))/) { }
6210  ***     50      2      0   if ($pos > 0)
6218         100      6    147   if ($pred =~ s/^string\(\s*\)\s*=\s*($REG_STRING)\s*//o) { }
             100      8    139   elsif ($pred =~ s/^string\(\s*\)\s*($REG_MATCH)\s*($REG_REGEXP)\s*//o) { }
             100     82     57   elsif ($pred =~ s/^@($REG_NAME)\s*($REG_OP)\s*($REG_STRING|$REG_NUMBER)//o) { }
             100     12     45   elsif ($pred =~ s/^@($REG_NAME)\s*($REG_MATCH)\s*($REG_REGEXP)\s*//o) { }
             100     17     28   elsif ($pred =~ s/^@($REG_NAME)\s*//o) { }
             100      6     22   elsif ($pred =~ s/^\s*(?:not|!)\s*@($REG_NAME)\s*//o) { }
             100      2     20   elsif ($pred =~ s/^\s*([()])//) { }
             100     19      1   elsif ($pred =~ s/^\s*(and|or)\s*//) { }
6244         100      1    112   if $pred
6254         100      1    165   if ($xpath_exp)
6260  ***     50      0    165   if ($@)
6269  ***     50      0      2   if ($XML::Twig::XPath::VERSION or 0)
6271  ***      0      0      0   if (eval {
	do {
	$$check_twig{'twig_xp'}->_parse($xpath_expression)
}
})
6287         100    158     13   unless defined $offset
6302         100   1118    464   wantarray ? :
6313         100    961    357   unless ($parent = $$elt{'parent'})
6318         100   1065      6   if ($XML::Twig::weakrefs)
6322         100     46    311   if ($$elt{'twig_current'})
6330         100    178    179   if ($$parent{'first_child'} == $elt)
6332         100     96     82   unless ($$elt{'next_sibling'})
6334         100    152      1   if ($XML::Twig::weakrefs)
             100    153    204   if ($$parent{'last_child'} == $elt)
6336         100    179    178   if ($prev_sibling = $$elt{'prev_sibling'})
6338         100    204    153   if ($next_sibling = $$elt{'next_sibling'})
6339         100    203      1   if ($XML::Twig::weakrefs)
6342         100    355      2   if ($XML::Twig::weakrefs)
6343         100    355      2   if ($XML::Twig::weakrefs)
6346         100      5    352   if ($prev_sibling and $next_sibling and $prev_sibling->is_text and $XML::Twig::index2gi[$$prev_sibling{'gi'}] eq $XML::Twig::index2gi[$$next_sibling{'gi'}])
6368         100      1     81   if ($$elt{'twig_current'})
6370         100      5     76   if (not $$elt{'parent'}) { }
6373         100      1      4   unless (@children == 1)
6377  ***     50      4      0   if ($XML::Twig::weakrefs)
6385         100     61     15   if (@children)
6390         100     19     42   if ($prev_sibling) { }
6392  ***     50     19      0   if ($XML::Twig::weakrefs)
6402         100     32     29   if ($next_sibling) { }
6405  ***     50     32      0   if ($XML::Twig::weakrefs)
6413  ***     50     88      0   if ($XML::Twig::weakrefs)
6416         100     12     49   if ($prev_sibling and $prev_sibling->is_text and $XML::Twig::index2gi[$$first_child{'gi'}] eq $XML::Twig::index2gi[$$prev_sibling{'gi'}])
6418         100     10     51   if ($next_sibling and $next_sibling->is_text and $XML::Twig::index2gi[$$last_child{'gi'}] eq $XML::Twig::index2gi[$$next_sibling{'gi'}])
6422         100      9     52   if ($$elt{'parent'}{'twig_current'} and $$elt{'last_child'}->is_text)
6445         100     20     60   if (my $extra_data = $$elt{'extra_data'})
6447         100     14      6   if ($target) { }
6449         100      7      7   if ($target->is('#ELT')) { }
      ***     50      7      0   elsif ($target->is('#TEXT')) { }
6461         100     13     67   if (my $extra_data = $elt->_extra_data_before_end_tag)
6462         100     10      3   if (my $target = $$elt{'next_sibling'}) { }
      ***     50      3      0   elsif (my $parent = $$elt{'parent'}) { }
6463         100      3      7   if ($target->is('#ELT')) { }
      ***     50      7      0   elsif ($target->is('#TEXT')) { }
6489         100      1    502   if ($$elt{'parent'})
6493         100     32    470   if (ref $_[0]) { }
6495         100      1     31   if $_[1]
6500         100    500      1   if (my $method = $method{$pos}) { }
6502         100      4    496   unless (ref $_[0] and isa($_[0], 'XML::Twig::Elt'))
6503         100      1      3   if (not defined $_[0]) { }
             100      1      2   elsif (not ref $_[0]) { }
6514         100      6    490   if (not $$ref{'parent'} and $pos =~ /^(before|after)$/ and not exists $$elt{'target'} and not exists $$elt{'comment'})
6523         100     22    468   if (my $ids = $$elt{'twig_id_list'} and my $t = $ref->twig)
6527  ***     50     24      0   if ($XML::Twig::weakrefs)
6539         100      4     87   unless ($$ref{'parent'})
6540  ***     50      4      0   if (my $t = $ref->twig) { }
6541         100      2      2   if (exists $$elt{'comment'} or exists $$elt{'target'}) { }
6553  ***     50     87      0   if ($XML::Twig::weakrefs)
6554         100      3     84   if ($$parent{'first_child'} == $ref)
6556         100     84      3   if ($prev_sibling)
6557  ***     50     87      0   if ($XML::Twig::weakrefs)
6559  ***     50     87      0   if ($XML::Twig::weakrefs)
6569         100      4    172   unless ($$ref{'parent'})
6570  ***     50      4      0   if (my $t = $ref->twig) { }
6571         100      2      2   if (exists $$elt{'comment'} or exists $$elt{'target'}) { }
6583  ***     50    172      0   if ($XML::Twig::weakrefs)
6584  ***     50    142      0   if ($XML::Twig::weakrefs)
             100    142     30   if ($$parent{'last_child'} == $ref)
6587  ***     50    172      0   if ($XML::Twig::weakrefs)
6589  ***     50     30      0   if ($XML::Twig::weakrefs)
             100     30    142   if ($next_sibling)
6602  ***     50     52      0   if ($XML::Twig::weakrefs)
6604  ***     50     31      0   if ($XML::Twig::weakrefs)
             100     31     21   unless ($$parent{'last_child'})
6606  ***     50     52      0   if ($XML::Twig::weakrefs)
6608  ***     50     21      0   if ($XML::Twig::weakrefs)
             100     21     31   if ($next_sibling)
6620  ***     50   3404      0   if ($XML::Twig::weakrefs)
6621  ***     50   3404      0   if ($XML::Twig::weakrefs)
6622         100   1986   1418   unless ($$parent{'first_child'})
6624  ***     50   3404      0   if ($XML::Twig::weakrefs)
6625         100   1418   1986   if ($prev_sibling)
6633         100      1      1   $ref->is_text ? :
6659  ***     50      0    117   unless $allowed_options{$option}
6664         100      5    116   if ($options{'content_key'} =~ /^-/) { }
6673         100      5    116   if (isa($options{'forcearray'}, 'ARRAY'))
6680         100    106     15   if (ref $options{'keyattr'} eq 'ARRAY') { }
      ***     50     15      0   elsif (ref $options{'keyattr'} eq 'HASH') { }
6685  ***     50    293      0   unless $prefix eq '+'
6686  ***     50      0    293   if $prefix eq '-'
6694         100      5     10   unless $prefix
6695         100      5     10   if $prefix eq '-'
6701         100     11    110   if ($options{'var'}) { }
6704         100      7    114   if ($options{'variables'})
6709  ***     50      0    121   if ($options{'var_regexp'} and not $options{'var'})
6724         100     32    730   $$options{'noattr'} || !$elt->atts ? :
6737         100    475    641   if ($child->is_text) { }
6740         100     20    455   if ($$options{'normalise_space'} >= 2)
6741         100    201    274   if ($$options{'force_content'} or $nb_atts or scalar @children > 1) { }
6757         100      9    632   if (my $grouped_tag = $$options{'group_tags'}{$child_gi})
6759         100      3      6   if (not ref $child_data eq 'HASH' && keys %$child_data == 1 && defined(my $grouped_child_data = $$child_data{$grouped_tag})) { }
6768         100     27    611   if ($$options{'extra_folding'})
6769         100      8     19   if (ref $child_data eq 'HASH' and keys %$child_data == 1 and defined(my $content = $$child_data{$$options{'content_key'}}))
6776         100    207    431   if (my $keyatt = $child->_key_attr($options)) { }
             100    239    192   elsif ($$options{'forcearray'} or $$options{'forcearray_tags'}{$child_gi} or $nb_children{$child_gi} > 1) { }
6779         100     22    185   if ($$options{'normalise_space'} >= 1)
6801         100    201    375   if ($$options{'remove_key_for_all'}{$att} or $$options{'remove_key_for_elt'}{"$gi#$att"})
6806         100     49    326   $$options{'var'} ? :
6807         100     15    360   if ($$options{'normalise_space'} >= 2)
6809         100      3    372   if ($$options{'prefix_key_for_all'}{$att} or $$options{'prefix_key_for_elt'}{"$gi#$att"}) { }
6826         100     27    611   if $$options{'noattr'}
6827         100    530     81   if ($$options{'key_for_all'}) { }
      ***     50     81      0   elsif ($$options{'key_for_elt'}) { }
6829         100    198     40   if ($$options{'key_for_all'}{$att})
6834         100     12     69   if (my $key_for_elt = $$options{'key_for_elt'}{$XML::Twig::index2gi[$$elt{'gi'}]})
6835         100      9      3   if defined $$elt{'att'}{$key_for_elt}
6843         100     68    407   if ($$options{'var'}) { }
6863  ***     50      0     14   unless my $atts = $_[0]->atts
6868  ***     50      0      3   unless my $atts = $_[0]->atts
6869         100      2      1   scalar keys %$atts ? :
6875         100      8      6   if (defined(my $value = $$options{'var_values'}{$2})) { }
6888         100      3     65   if (defined(my $var_name = $$elt{'att'}{$$options{'var'}}))
6897         100     83      1   $elt->is_text ? :
6914         100      1      5   if ($elt->is_text) { }
6927         100      1     25   if ($elt->is_text) { }
6948         100      5     25   if (ref $_[0]) { }
6954         100      2     30   unless (@tags)
6967         100     15     28   if ($previous_match) { }
6971         100      4     11   if $return_all
6978         100      4     24   if $return_all
6982         100     31     12   if (@matches) { }
7003         100     13     19   if ($previous_match and $text)
7008         100      6     26   if $return_all
7017  ***     50     77      0   if ($] >= 5.008 and not _keep_encoding())
7018         100      3     74   unless ($encode_is_loaded)
7034         100     15     39   if ($is_string) { }
7052  ***     50     38      0   if ($next_sibling = $$text_elt{'next_sibling'} and $XML::Twig::index2gi[$$text_elt{'gi'}] eq $XML::Twig::index2gi[$$next_sibling{'gi'}])
7058         100     18     20   if (not $text_elt->text)
7067  ***     50      0     38   if ($prev_sibling = $$post_match{'prev_sibling'} and $XML::Twig::index2gi[$$post_match{'gi'}] eq $XML::Twig::index2gi[$$prev_sibling{'gi'}])
7075         100     18     20   if (not $text_elt->text)
7086         100     16      7   $_[0] =~ /&e[ln]t/ ? :
7101         100     10     18   if ($item =~ /^&elt\s*\(([^)]*)\)/) { }
             100      3     15   elsif ($item =~ /^&ent\s*\(\s*([^\s)]*)\s*\)/) { }
7115  ***     50      0     13   if ($@)
7124         100      1     68   unless isa($e2, 'XML::Twig::Elt')
7126         100      2     66   unless $e1->is_text and $e2->is_text and $e1->gi eq $e2->gi
7133  ***     50      0     66   if ($extra_data)
7138         100     10     56   if ($extra_data = $e2->_extra_data_in_pcdata)
7141  ***     50      0     66   if (my $extra_data_before_end_tag = $e2->_extra_data_before_end_tag)
7152  ***     50      2      0   if ($e1->_last_child and $e1->_last_child->is_pcdata and @e2_children and $e2_children[0]->is_pcdata)
7167         100      4     57   if ($elt->extra_data)
7168         100      7     54   if ($elt->_extra_data_before_end_tag)
7170         100      2     59   if ($elt->is_asis)
7173         100     25     36   if (exists $$elt{'pcdata'}) { }
             100      2     34   elsif (exists $$elt{'cdata'}) { }
             100      1     33   elsif (exists $$elt{'target'}) { }
             100      1     32   elsif (exists $$elt{'comment'}) { }
             100      1     31   elsif (exists $$elt{'ent'}) { }
7175         100      7     18   if ($elt->_extra_data_in_pcdata)
7179  ***     50      0      2   if ($elt->_extra_data_in_pcdata)
7189         100     26      5   if (my $atts = $elt->atts)
7191  ***     50      0     26   if keep_atts_order()
7203  ***     50    183      0   if ($XML::Twig::weakrefs)
7213  ***     50      0   1191   unless $XML::Twig::weakrefs
7220         100  22000      4   if $XML::Twig::weakrefs
7227  ***     50      0      4   if $ID and $t and defined $$elt{'att'} and exists $$elt{'att'}{$ID}
7360         100     89   1572   defined $_[1] ? :
7362         100   1571     90   if ($style =~ /^\d+$/) { }
7363         100      1   1570   unless $style < keys %pretty_print_style
7367         100      1     89   unless exists $pretty_print_style{$style}
7370         100      6   1653   if ($pretty == $WRAPPED or $pretty == $INDENTEDA)
7371  ***     50      0      6   unless XML::Twig::_use('Text::Wrap')
7383         100     88      7   defined $_[1] ? :
7385         100     25     70   if ($style =~ /^\d+$/) { }
7386         100      1     24   unless $style < keys %empty_tag_style
7391         100      1     69   unless exists $empty_tag_style{$style}
7399  ***      0      0      0   unless $pretty_print_style{$a} <=> $pretty_print_style{$b}
7404         100      1      3   unless exists $quote_style{$style}
7410  ***     50   2760      0   defined $_[1] ? :
7418         100      4      1   defined $_[1] ? :
7425         100      5      4   defined $_[1] ? :
7433  ***     50      0   2764   defined $_[1] ? :
7440  ***      0      0      0   defined $_[1] ? :
7461  ***     50   2770      0   defined $_[1] ? :
7471  ***     50   2783      0   defined $_[1] ? :
7473         100      1   2782   if (isa($new_value, 'XML::Twig::Elt') or isa($new_value, 'XML::Twig'))
7475         100   2776      7   if (not $new_value or isa($new_value, 'CODE')) { }
             100      1      6   elsif ($new_value eq 'latin1') { }
             100      5      1   elsif ($XML::Twig::filter{$new_value}) { }
7489         100   2768      1   defined $_[1] ? :
7491         100      1   2768   if (isa($new_value, 'XML::Twig::Elt') or isa($new_value, 'XML::Twig'))
7493         100   2761      8   if (not $new_value or isa($new_value, 'CODE')) { }
      ***     50      0      8   elsif ($new_value eq 'latin1') { }
             100      7      1   elsif ($XML::Twig::filter{$new_value}) { }
7507         100   2770      1   defined $_[1] ? :
7514  ***     50      0   2761   defined $_[1] ? :
7529         100      1   4414   if $$elt{'gi'} < $XML::Twig::SPECIAL_GI
7536  ***     50   4414      0   $att ? :
7537         100     11   4403   if ($ns_map)
7540         100     17   4397   if ($output_text_filter)
7543         100      4   4405   $pretty == $INDENTEDA ? :
             100      5   4409   $pretty == $NSGMLS ? :
7549         100     37   4377   if ($$option{'escape_gt'} and not $replaced_ents =~ />/)
7552         100     51   4363   $keep_atts_order ? :
7553         100    664   3750   if (@att_names) { }
7554         100     11   1160   $ns_map ? :
7555         100      4   1167   if ($output_text_filter)
7565         100      1    663   if ($pretty == $INDENTEDA and @att_names == 1)
7571         100      5   4409   if $pretty == $NSGMLS
7574         100     21   4393   if ($empty_tag_style eq $HTML and not $$elt{'first_child'} and not $elt->_extra_data_before_end_tag and $html_empty_elt{$gi})
7577         100     37   1003   $empty_tag_style ? :
             100      1   1040   $pretty == $INDENTEDA && @att_names == 1 ? :
             100      1   1041   $pretty == $INDENTEDA && @att_names > 1 ? :
             100     21   1042   $empty_tag_style eq $HTML && $html_empty_elt{$gi} ? :
             100   3351   1063   !$$elt{'empty'} || $elt->_extra_data_before_end_tag ? :
7586         100      3   4411   if (substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 1) eq '#' and substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 9) ne '#default:')
7588  ***     50   4194      0   defined $extra_data ? :
             100   4194    220   unless ($pretty)
7594         100     29    191   if ($pretty == $RECORD1) { }
             100      4    187   elsif ($pretty == $RECORD2) { }
             100      3    184   elsif ($pretty == $NICE) { }
             100    179      5   elsif ($KEEP_TEXT_TAG_ON_ONE_LINE{$pretty}) { }
7596         100     11     18   if $level < 2
7597         100      9     20   if $level == 1
7607         100      2      1   unless (not $parent or $$parent{'contains_text'})
7609         100      2      1   if $parent and $$parent{'contains_text'} or $elt->contains_text
7615         100    132     47   unless (not $parent or $$parent{'contains_text'})
7619         100     33    146   if $parent and $$parent{'contains_text'} or $elt->contains_text
7623         100    149     71   if ($return or $indent)
7626  ***     50      0    149   if $xml_space_preserve
7627         100      3    146   if ($t and $$t{'twig_keep_spaces_in'})
7629  ***     50      0      3   if $$t{'twig_keep_spaces_in'}{$XML::Twig::index2gi[$$ancestor{'gi'}]}
7633         100      5    144   if ($extra_data)
7646         100   1030   3334   if $$elt{'gi'} < $XML::Twig::SPECIAL_GI or $$elt{'empty'} || 0 and not $elt->_extra_data_before_end_tag
7652         100     11   3323   if (my $map = $$elt{'att'}{'#original_gi'})
7655         100     16   3318   if ($output_text_filter)
7660         100      3   3331   if (substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 1) eq '#' and substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 9) ne '#default:')
7662         100   3211    123   unless $pretty
7668         100     29     94   if ($pretty == $RECORD1) { }
             100      4     90   elsif ($pretty == $RECORD2) { }
             100      3     87   elsif ($pretty == $NICE) { }
             100     83      4   elsif ($KEEP_TEXT_TAG_ON_ONE_LINE{$pretty}) { }
7669         100      2     27   if $elt->level == 0
7673         100      2      2   unless ($elt->contains_text)
7681         100      1      2   if ($parent && !$$parent{'contains_text'} || !$parent and (not $$elt{'contains_text'} and $$elt{'has_flushed_child'} || $elt->_first_child))
7691         100     40     43   if ($parent && !$$parent{'contains_text'} || !$parent and (not $$elt{'contains_text'} and $$elt{'has_flushed_child'} || $elt->_first_child))
7701         100     45     78   if ($return or $indent)
7704  ***     50      0     45   if $xml_space_preserve
7705         100      1     44   if ($t and $$t{'twig_keep_spaces_in'})
7707  ***     50      0      1   if $$t{'twig_keep_spaces_in'}{$XML::Twig::index2gi[$$ancestor{'gi'}]}
7710  ***     50      0     45   $pretty == $INDENTEDCT ? :
      ***     50     45      0   if ($return)
7715         100     45     78   unless $$elt{'parent'}
7723         100     26      7   if (my $original_prefix = $$map{$prefix})
7724         100      8     18   if ($original_prefix eq '#default') { }
7743         100     13     30   _is_fh($_[0]) ? :
7744         100     13     30   defined $fh ? :
7745         100      1     42   defined($pretty = shift @_) ? :
7756  ***     50      0     43   if ($output_filter or $pretty == $WRAPPED || $pretty == $INDENTEDC and not $xml_space_preserve) { }
7758  ***      0      0      0   if ($output_filter)
7760  ***      0      0      0   if ($pretty == $WRAPPED || $pretty == $INDENTEDC and not $xml_space_preserve)
7770         100     13     30   if defined $old_select
7771         100      1     42   if defined $old_pretty
7779  ***     50      0     14   $_[0] && isa($_[0], 'XML::Twig::Elt') ? :
7784         100      2      2   $_[0] && isa($_[0], 'XML::Twig::Elt') ? :
7792  ***     50      0   1689   _is_fh($_[0]) ? :
7793  ***     50      0   1689   defined $fh ? :
7794         100    769    920   defined($pretty = shift @_) ? :
7796  ***     50      0   1689   if ($elt->inherit_att('xml:space') || '') eq 'preserve'
7802  ***     50      0   1689   if defined $old_select
7803         100    769    920   if defined $old_pretty
7809         100   1214    475   if ($$elt{'gi'} >= $XML::Twig::SPECIAL_GI) { }
7811  ***     50      0   1214   if $preserve
7812         100   1202     12   unless ($elt->_flushed)
7820  ***     50   1214      0   unless ($$elt{'end_tag_flushed'})
7821  ***     50      0   1214   if $preserve
7823         100    337    877   if (my $parent = $$elt{'parent'})
7827         100    325    150   if (exists $$elt{'pcdata'}) { }
             100      2    148   elsif (exists $$elt{'cdata'}) { }
             100      2    146   elsif (exists $$elt{'target'}) { }
      ***     50    146      0   elsif (exists $$elt{'comment'}) { }
      ***      0      0      0   elsif (exists $$elt{'ent'}) { }
7828  ***     50    325      0   if (my $parent = $$elt{'parent'})
7832  ***     50      2      0   if (my $parent = $$elt{'parent'})
7839  ***     50      0    475   $output_filter ? :
7847         100      1     25   if (@options and grep {lc $_ eq 'no_recurse';} @options)
7851         100      9     16   if ($$elt{'gi'} >= $XML::Twig::SPECIAL_GI) { }
             100     13      3   elsif (exists $$elt{'pcdata'}) { }
             100      1      2   elsif (exists $$elt{'cdata'}) { }
      ***     50      2      0   elsif (exists $$elt{'ent'}) { }
7858         100      2     11   $output_filter ? :
7861  ***     50      0      1   $output_filter ? :
7870         100      4      1   if $_->is_text or exists $$_{'ent'}
7881         100      6   3098   if ($_[0] and isa($_[0], 'HASH'))
7883         100      3      3   if (defined $args{'PrettyPrint'})
7884         100      3      3   if (defined $args{'EmptyTags'})
7887         100      1   3103   if ($elt->inherit_att('xml:space') || '') eq 'preserve'
7892         100     23   3081   if ($output_filter)
7894         100      5   3099   if ($pretty == $WRAPPED || $pretty == $INDENTEDC and not $xml_space_preserve)
7899         100      3   3101   if (defined $old_pretty)
7900         100      3   3101   if (defined $old_empty_tag_style)
7928         100   4711   4584   if ($$elt{'gi'} >= $XML::Twig::SPECIAL_GI) { }
7931         100      1   4710   if $preserve
7933         100   3150   1561   unless $no_tag
7941         100   3150   1561   unless $no_tag
7942         100      1   4710   if $preserve
7945         100    680   3904   if $$elt{'extra_data'}
7946         100   1421   3163   if (exists $$elt{'pcdata'}) { }
             100     45   3118   elsif (exists $$elt{'cdata'}) { }
             100   1460   1658   elsif (exists $$elt{'target'}) { }
             100   1616     42   elsif (exists $$elt{'comment'}) { }
      ***     50     42      0   elsif (exists $$elt{'ent'}) { }
7949  ***     50      0   1460   if ($pretty >= $INDENTED and not $$elt{'parent'}{'contains_text'})
7952  ***     50      0   1616   if ($pretty >= $INDENTED and not $$elt{'parent'}{'contains_text'})
7963         100      1   1557   isa($_[0], 'HASH') ? :
7968         100   1759      1   if (defined(my $string = $$elt{'pcdata'})) { }
7970         100     83   1676   if ($elt->_extra_data_in_pcdata) { }
7974         100     30     88   if ($keep_encoding or $$elt{'asis'}) { }
7979         100     63     20   unless ($keep_encoding or $$elt{'asis'})
7988         100   1327    349   unless $keep_encoding or $$elt{'asis'}
7991         100     11   1748   $output_text_filter ? :
8025         100      1     49   unless (defined $cdata)
8026         100      1     48   if ($remove_cdata) { }
8038  ***     50      0      1   if ($_[0] and $_[0]{'escape_gt'} and not $replace =~ />/)
8040  ***     50      0      1   if (defined(my $string = $$elt{'att'}{$att})) { }
8049         100      1   1170   if (not defined $string)
8050         100    994    176   unless ($keep_encoding)
8052         100      3    991   if ($do_not_escape_amp_in_atts) { }
8063         100      4   1166   $output_text_filter ? :
8070         100      9     35   if ($expand_external_entities and $t = $ent->twig and $el = $t->entity_list and $ent_string = $$el{'entities'}{$ent->ent_name}{'val'}) { }
8084         100      2   2799   if (@options and grep {lc $_ eq 'no_recurse';} @options)
8088         100   1619   1180   if (exists $$elt{'pcdata'}) { }
             100     12   1168   elsif (exists $$elt{'cdata'}) { }
             100      2   1166   elsif (exists $$elt{'target'}) { }
             100      2   1164   elsif (exists $$elt{'comment'}) { }
             100      2   1162   elsif (exists $$elt{'ent'}) { }
8098  ***     50   1263      0   defined $child_text ? :
8101         100     16   1146   unless (defined $string)
8103  ***     50      0   1162   $output_text_filter ? :
8107         100     10      2   if $_->is_text or exists $$_{'ent'}
8138         100      1      1   if ($keep_encoding) { }
8178         100     43     29   if ($$elt{'gi'} >= $XML::Twig::SPECIAL_GI) { }
8181         100     39      4   if ($data and my $start_element = $handler->can('start_element'))
8182         100     35      4   unless ($elt->_flushed)
8187         100     39      4   if (my $data = &$end_tag_data($elt) and my $end_element = $handler->can('end_element'))
8192         100     20      9   if (exists $$elt{'pcdata'} and my $characters = $handler->can('characters')) { }
             100      2      7   elsif (exists $$elt{'cdata'}) { }
             100      2      5   elsif (exists $$elt{'target'} and my $pi = $handler->can('processing_instruction')) { }
             100      2      3   elsif (exists $$elt{'comment'} and my $comment = $handler->can('comment')) { }
             100      1      2   elsif (exists $$elt{'ent'}) { }
8195  ***     50      2      0   if (my $start_cdata = $handler->can('start_cdata'))
8197  ***     50      2      0   if (my $characters = $handler->can('characters'))
8199  ***     50      2      0   if (my $end_cdata = $handler->can('end_cdata'))
8208  ***     50      1      0   if (my $se = $handler->can('skipped_entity')) { }
      ***      0      0      0   elsif (my $characters = $handler->can('characters')) { }
8211  ***      0      0      0   if (defined $elt->ent_string) { }
8224         100      2     13   if substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 1) eq '#' and substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 9) ne '#default:'
8228         100      2      2   unless substr($att, 0, 1) eq '#' and substr($att, 0, 9) ne '#default:'
8235         100      2     11   if substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 1) eq '#' and substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 9) ne '#default:'
8244         100      2     30   if substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 1) eq '#' and substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 9) ne '#default:'
8265         100      2     13   if substr($att, 0, 1) eq '#' and substr($att, 0, 9) ne '#default:'
8281         100     10      3   unless /^\{[^}]*\}xmlns/
             100      7     36   if (my $start_prefix_mapping = $handler->can('start_prefix_mapping') and my(@new_prefix_mappings) = grep({/^\{$XMLNS_URI\}/ unless /^\{[^}]*\}xmlns/;} keys %{$$data{'Attributes'};}))
8286         100      3      4   if ($prefix_string eq 'xmlns')
8300         100     30     13   if (my $end_prefix_mapping = $handler->can('end_prefix_mapping'))
8308         100      2     28   if substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 1) eq '#' and substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 9) ne '#default:'
8316         100     37    131   if $child->is_text or exists $$child{'ent'}
8329         100    169     51   if ($XML::Twig::index2gi[$$elt{'gi'}] eq '#PCDATA') { }
             100     12     39   elsif ($XML::Twig::index2gi[$$elt{'gi'}] eq '#CDATA') { }
             100     32      7   elsif ($elt->contains_a_single('#PCDATA')) { }
8332         100      2     10   if ($option{'force_pcdata'}) { }
8361         100      1    118   unless defined $_[0]
8364         100      1    117   if (ref $_[0] eq 'HASH')
8368  ***     50      0      1   unless defined $_[0]
8372         100      5    113   if (not ref $_[0] and $_[0] eq '#EMPTY')
8377         100     12    101   if ($XML::Twig::index2gi[$$elt{'gi'}] eq '#PCDATA' || $elt->contains_a_single('#PCDATA') and @_ == 1 and not ref $_[0]) { }
             100      1    100   elsif ($XML::Twig::index2gi[$$elt{'gi'}] eq '#CDATA' and @_ == 1 and not ref $_[0]) { }
8394         100     25     95   if (ref $child and isa($child, 'XML::Twig::Elt')) { }
8400         100      2     93   if (my $pcdata = $$elt{'last_child'} and $$elt{'last_child'}->is_pcdata) { }
8430         100      2      5   if (defined $args[0] and isa($args[0], 'HASH'))
8450         100     92      3   if ($position eq 'before' or $position eq 'after' or $position eq 'first_child' or $position eq 'last_child') { }
8472         100      2     14   if ($$elt{'twig_current'})
8479         100     15      1   if (my $parent = $$elt{'parent'}) { }
8480  ***     50     15      0   if ($XML::Twig::weakrefs)
8481         100     11      4   if ($$parent{'first_child'} == $elt)
8482  ***     50      8      0   if ($XML::Twig::weakrefs)
             100      8      7   if ($$parent{'last_child'} == $elt)
8487  ***     50      1      0   if ($twig and $twig->root and $twig->root eq $elt)
8491         100      4     12   if (my $prev_sibling = $$elt{'prev_sibling'})
8492  ***     50      4      0   if ($XML::Twig::weakrefs)
8496         100      7      9   if (my $next_sibling = $$elt{'next_sibling'})
8498  ***     50      7      0   if ($XML::Twig::weakrefs)
8501  ***     50     16      0   if ($XML::Twig::weakrefs)
8503  ***     50     16      0   if ($XML::Twig::weakrefs)
8504  ***     50     16      0   if ($XML::Twig::weakrefs)
8508         100     10      6   if (defined $_[0] and isa($_[0], 'HASH'))
8520  ***     50      0      6   if ($$elt{'parent'})
8522  ***     50      6      0   if (my $parent = $$ref{'parent'})
8523  ***     50      6      0   if ($XML::Twig::weakrefs)
8524         100      4      2   if ($$parent{'first_child'} == $ref)
8525  ***     50      3      0   if ($XML::Twig::weakrefs)
             100      3      3   if ($$parent{'last_child'} == $ref)
8527         100      2      4   if (my $prev_sibling = $$ref{'prev_sibling'})
8528  ***     50      2      0   if ($XML::Twig::weakrefs)
8531         100      3      3   if (my $next_sibling = $$ref{'next_sibling'})
8533  ***     50      3      0   if ($XML::Twig::weakrefs)
8536  ***     50      6      0   if ($XML::Twig::weakrefs)
8537  ***     50      6      0   if ($XML::Twig::weakrefs)
8564         100      5     11   $option && $option eq 'asis' ? :
8565         100      2     14   if (exists $$elt{'pcdata'} and $asis && $$elt{'asis'} || !$asis && !$$elt{'asis'}) { }
             100      5      9   elsif ($$elt{'first_child'} and $$elt{'first_child'}->is_pcdata and $asis && $$elt{'first_child'}{'asis'} || !$asis && !$$elt{'first_child'}{'asis'}) { }
8579         100      3      6   if ($asis)
8587         100      5      7   $option && $option eq 'asis' ? :
8588         100      1     11   if (exists $$elt{'pcdata'} and $asis && $$elt{'asis'} || !$asis && !$$elt{'asis'}) { }
             100      5      6   elsif ($$elt{'last_child'} and $$elt{'last_child'}->is_pcdata and $asis && $$elt{'last_child'}{'asis'} || !$asis && !$$elt{'last_child'}{'asis'}) { }
8600         100      2      4   if ($asis)
8619         100     10      8   unless ($index == 1 and not $ancestor->next_sibling($gi))
8644  ***     50      9      0   isa($_[0], 'HASH') ? :
8654  ***     50      0      9   unless @to_wrap
8698         100      2      1   unless my $child = $elt->first_child($cond)
8740         100      1      4   $opt{'order'} eq 'reverse' ? :
8741         100      2      3   $opt{'type'} eq 'numeric' ? :
8743         100      2      3   if ($opt{'type'} eq 'numeric') { }
             100      2      1   elsif ($opt{'type'} eq 'alpha') { }
8756         100      1      3   if $opt{'order'} eq 'reverse'
8765         100      4      2   if ($a->cmp($b) == -1) { }
8770         100      1      2   if ($a->cmp($b) == 1) { }
8775         100      1      1   if $a->cmp($b) == -1
8781         100      1      1   unless $a->cmp($b) == 1
8787         100      1      1   if $a->cmp($b) == 1
8793         100      1      1   unless $a->cmp($b) == -1
8802         100     43    787   if $a == $b
8803         100    137    650   if $a->in($b)
8804         100    158    492   if $b->in($a)
8811         100      1    491   unless $a_pile[-1] == $b_pile[-1]
8826         100    165    131   if $a_prev == $b_next
8828         100     74     27   if $a_next == $b_prev
8830         100     13      7   if $b_prev == $a_next
8832         100      3      2   if $b_next == $a_prev
8839         100     14     35   defined $$option{'atts'} ? :
8840         100     14     35   defined $$option{'extra'} ? :
8841  ***     50      0     49   defined $$option{'short_text'} ? :
8848         100     24     25   if ($elt->is_elt) { }
8852         100      3     21   if ($atts and my(@atts) = $elt->att_names)
8856         100      7     17   if ($extra)
8861         100     19      6   if (exists $$elt{'pcdata'}) { }
      ***     50      0      6   elsif (exists $$elt{'ent'}) { }
             100      3      3   elsif (exists $$elt{'cdata'}) { }
             100      1      2   elsif (exists $$elt{'comment'}) { }
      ***     50      2      0   elsif (exists $$elt{'target'}) { }
8871         100      7     18   if ($extra)
8879         100      2     12   if ($elt->extra_data)
8884  ***     50      0     14   if ($elt->_extra_data_in_pcdata)
8891  ***     50      0     14   if ($elt->_extra_data_before_end_tag)
8902         100     24      3   if (not $length or length $string < $length)


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
752   ***      0      0      0   $t->_reset_twig && 0
759   ***      0      0      0   $t->_reset_twig && 0
766   ***      0      0      0   $t->_reset_twig && 0
1623  ***     50      3      0   $t->_reset_twig && 0

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
130   ***     33      0      0     92   eval 'require Scalar::Util' and defined \&Scalar::Util::weaken
467   ***     33      0   2770      0   not $args{'NoLWP'} and not _use('URI')
      ***     33   2770      0      0   not $args{'NoLWP'} and not _use('URI') and not _use('URI::File')
      ***     33   2770      0      0   not $args{'NoLWP'} and not _use('URI') and not _use('URI::File') and not _use('LWP')
665   ***     33      0   2780      0   $] >= 5.008 and ${^UNICODE}
      ***     33   2780      0      0   $] >= 5.008 and ${^UNICODE} and ${^UNICODE} & 24
      ***     33   2780      0      0   $] >= 5.008 and ${^UNICODE} and ${^UNICODE} & 24 and isa($_[0], 'GLOB')
      ***     33   2780      0      0   $] >= 5.008 and ${^UNICODE} and ${^UNICODE} & 24 and isa($_[0], 'GLOB') and -p $_[0]
683   ***     66     16      0      6   isa($returned, 'XML::Twig') and $$returned{'twig_finish_now'}
876          100     23      4     21   not _check_xml($xml) and $max_tries--
888   ***      0      0      0      0   $encoding eq 'euc-jp' and $xml_parser_encoding{'x-euc-jp-jisx0221'}
      ***      0      0      0      0   $encoding eq 'shift-jis' and $xml_parser_encoding{'x-sjis-jisx0221'}
934   ***     33     10      0      0   $$meta{'http-equiv'} and $$meta{'http-equiv'} =~ /^\s*content-type\s*/i
      ***     33     10      0      0   $$meta{'http-equiv'} and $$meta{'http-equiv'} =~ /^\s*content-type\s*/i and $$meta{'content'}
      ***     33     10      0      0   $$meta{'http-equiv'} and $$meta{'http-equiv'} =~ /^\s*content-type\s*/i and $$meta{'content'} and $$meta{'content'} =~ m[^\s*text/html\s*;\s*charset\s*=\s*(\S*)\s*]i
948   ***      0      0      0      0   _use('Unicode::Map8') and _use('Unicode::String')
979   ***     33      0      0      5   $2 and $block_tag{$2}
      ***      0      0      0      0   $3 and $block_tag{$3}
1057  ***     66     22      0      3   defined $base and not $filename =~ m[^(?:[\\/]|\w+:)]
1155  ***     33      0      0     76   @saved_default_handler and defined $saved_default_handler[1]
1169  ***     66     10      0      6   $$p{'twig'}{'twig_doctype'}{'has_internal'} and not $expat_1_95_2
1269  ***     66      0      7      6   !($$stack[-1]{'_tag'} =~ /^#/) && scalar @$stack == $level + 1
1306  ***     33    512      0      0   $DEBUG_HANDLER and $path_to_check =~ /\S/
1328         100    488     68      2   defined $last_token_is_sep and not $last_token_is_sep
1338  ***     33    506      0      0   $DEBUG_HANDLER >= 1 && "warn q{checking path '${xpath_to_display}'\n};"
1443         100    188      5      2   $num_test and $num_test eq '='
      ***     66     64      0     40   $func and $func =~ /^string/
      ***     66     62      0      2   $string_regexp and $string_regexp =~ /string\(\s*($REG_NAME)\s*\)\s*($REG_MATCH)\s*($REG_REGEXP)/
      ***     66     60      0      2   $string_test_alpha and $string_test_alpha =~ /string\(\s*($REG_NAME)\s*\)\s*($REG_COMP)\s*($REG_STRING)/
      ***     33     60      0      0   $string_test_num and $string_test_num =~ /string\(\s*($REG_NAME)\s*\)\s*($REG_COMP)\s*($REG_NUMBER)/
1577  ***     66     16      0     44   ref $$handlers{$path} and isa($$handlers{$path}, 'CODE')
1785  ***     66  10366      0      1   $$elt{'att'}{'xml:space'} and $$elt{'att'}{'xml:space'} eq 'preserve'
1795         100      9      3     16   not $$t{'twig_keep_original_prefix'} and my $mapped_prefix = $$t{'twig_map_xmlns'}{$uri}
1871  ***     66     43      0     23   not exists $value{$att} and exists $$attlist{$att}{'default'}
             100     43     10     13   not exists $value{$att} and exists $$attlist{$att}{'default'} and $$attlist{$att}{'default'} ne '#IMPLIED'
1968         100  10110     74     76   $$t{'twig_root_depth'} and $p->depth == $$t{'twig_root_depth'}
1981  ***     66  10259      0      1   $$elt{'att'}{'xml:space'} and $$elt{'att'}{'xml:space'} eq 'preserve'
2019         100    630   3034     41   not @found_handlers and defined $$handlers{'handlers'}{$DEFAULT}
2022         100   3034    670      1   @found_handlers and $$t{'twig_do_not_chain_handlers'}
2036         100     72     19     34   not $uri and not $name =~ /^xml/
2140  ***     66     73      0      5   $t->_space_policy($XML::Twig::index2gi[$$twig_current{'gi'}]) and $$t{'twig_stored_spaces'}
2208         100     14     14   1473   defined $data && $data ne ''
2298  ***     66    311      0      1   $t->_space_policy($XML::Twig::index2gi[$$twig_current{'gi'}]) and $$t{'twig_stored_spaces'}
2391         100    833      4      8   $$t{'twig_keep_spaces_in'} and $$t{'twig_keep_spaces_in'}{$gi}
2393         100    837      2      6   $$t{'twig_discard_spaces_in'} and $$t{'twig_discard_spaces_in'}{$gi}
2437  ***     33      0      3      0   defined $$ent{'val'} and not $ent_decl =~ /["']/
2518         100     64      8      5   $$t{'twig_read_external_dtd'} and $sysid
2543  ***     33      0      0     44   $parser_version > 2.27 and $$t{'twig_doctype'}{'internal'} =~ /(^|>)\s*$/
2564  ***     33      0      0     37   $parser_version > 2.27 and $$t{'twig_doctype'}{'internal'} =~ /(^|>)\s*$/
2601         100     40     57    236   not $$t{'twig_current'} and $$t{'twig_root'}
      ***     66     97      0    236   not $$t{'twig_current'} and $$t{'twig_root'} and $string =~ /^\s+$/m
2606  ***     33     36      0      0   $p->original_string =~ /^</ and $p->original_string =~ />$/
2808         100     19      5     19   $$doctype{'sysid'} and not $$doctype{'pub'}
2813  ***     33      0      0      2   not $$t{'twig_dtd'} and keys %{$t->entity_list;}
2877  ***     33      0      0      1   $] > 5.006 and not $$t{'twig_keep_encoding'}
2897  ***     66     19      1      0   ($$t{'twig_keep_spaces'} || '') && ($$t{'trailing_spaces'} || '')
2964  ***     66      0    920     31   $last_elt and $last_elt->in($elt)
2978  ***     66      0     19    901   $last_elt and $elt == $last_elt
3038         100   1351     10      4   $$t{'twig_keep_spaces'} and $$t{'trailing_spaces'}
3070  ***     66      0     16     13   $last_elt and $last_elt->in($elt)
3078  ***     66      0      6     10   $last_elt and $elt == $last_elt
3113         100      2      1      1   $elt_class->can($att) and not $accessor{$att}
3165         100    149    126      4   @unique and $unique[-1] == $current
3196         100      4     75      3   $cond && !$root->passes($cond)
3418  ***     66     48   2708      0   $$t{'twig_root'} and isa($$t{'twig_root'}, 'XML::Twig')
3459  ***     33    474      0      0   $expat_1_95_2 and $p->recognized_string eq '['
      ***     33    474      0      0   $expat_1_95_2 and $p->recognized_string eq '[' and not $$p{'twig'}{'expat_1_95_2_seen_bracket'}
3512  ***     66      4      0      1   $sysid and not $pubid
3514  ***     66      2      0      3   $internal and not $expat_1_95_2
3532  ***     66      4      0      7   $sysid and not $pubid
3605  ***     66     11      0     12   $tag and !@handlers || $last_handler_res
3737         100      6     13     30   $elt && ref $elt
      ***     66     19      0     30   $elt && ref $elt && isa($elt, 'XML::Twig::Elt')
3743         100      5     11      1   $$current{'last_child'} and $elt == $$current{'last_child'}
3770  ***     66      0     53     30   $$elt_in_stack{'_elt'} and $elt == $$elt_in_stack{'_elt'}
3781         100   2754     20     31   $output_fh and not $$t{'twig_output_fh_selected'}
3819         100      4      9      5   $encoding and not $encoding =~ /^utf-?8$/i
3912  ***     66      0     12      6   $last_elt and $last_elt->in($elt)
3929  ***     66      0      6      6   $last_elt and $elt == $last_elt
3979  ***      0      0      0      0   _use('Unicode::Map8') and _use('Unicode::String')
3993  ***      0      0      0      0   _use('Unicode::Map8') and _use('Unicode::String')
4167  ***     66      0      2      3   $ents_to_add and %$ents_to_add
4289         100     48      4     57   defined $$ent{'val'} and not defined $$ent{'sysid'}
      ***     66     52      0     57   defined $$ent{'val'} and not defined $$ent{'sysid'} and not defined $$ent{'pubid'}
4402  ***     33      0      0     92   eval 'require Scalar::Util' and defined &Scalar::Util::weaken
4430         100  22083     71      4   $atts and defined $$atts{'#CDATA'}
4617  ***      0      0      0      0   $elt->_ns_prefix and $elt->namespace eq $uri
4851         100      9      1     31   @$long and $s_word ne $l_word
4855         100      1      2      7   not @$long and $s_word ne $l_word
4916  ***     33      0      0   1464   defined $data and $data ne ''
5075         100     16      1     30   $gi and $gi ne '*'
5087         100     16     29     48   $tag && $tag ne '*'
5115  ***     66    127      5      0   $num_test and $num_test eq '='
      ***     66     65      0      7   $func and $func =~ /^(?:string|text)/
      ***     66     56      0      9   $string_regexp and $string_regexp =~ /(?:string|text)\(\s*($REG_NAME)\s*\)\s*($REG_MATCH)\s*($REG_REGEXP)/
      ***     66     39      0     17   $string_eq and $string_eq =~ /(?:string|text)\(\s*($REG_NAME)\s*\)\s*(!?=)\s*($REG_VALUE)/
      ***     33     39      0      0   $string_test and $string_test =~ /(?:string|text)\(\s*($REG_NAME)\s*\)\s*([<>]=?)\s*($REG_VALUE)/
5186         100     53    276    501   $child and not &$test_cond($child)
5229         100      3     23     24   $child and not &$test_cond($child)
5245         100     28     29     16   $sibling and not &$test_cond($sibling)
5257         100     77     85     68   $sibling and not &$test_cond($sibling)
5287  ***     66      1      0      1   $elt->tag eq 'span' and $elt->class
5293  ***     66      1      0      1   $elt->tag eq 'div' and $elt->class
5325  ***     33      0     93      0   $_[0] and ref $_[0]
      ***     33     93      0      0   $_[0] and ref $_[0] and not $_[1]
5410  ***     33     39      0      0   $_[0] && ref $_[0]
      ***     33     39      0      0   $_[0] && ref $_[0] && isa($_[0], 'CODE')
5536         100   6075      4      8   defined $$elt{'att'}{$att} and !%tags || $tags{$XML::Twig::index2gi[$$elt{'gi'}]}
5550  ***     66     81      0     40   defined $$elt{'att'}{$att} and !%tags || $tags{$XML::Twig::index2gi[$$elt{'gi'}]}
5584  ***     66    110      0    287   ref $_[0] and isa($_[0], 'XML::Twig::Elt')
             100     15    110    287   defined $_[0] and (ref $_[0] and isa($_[0], 'XML::Twig::Elt'))
5596         100    270    113     97   defined $ind and $$elt{'gi'} eq $ind
             100    113     74    196   defined $test_cond and &$test_cond($elt)
5603         100     31     47      3   $subtree_root and $elt == $subtree_root
5611         100     39    125      2   $subtree_root and $elt == $subtree_root
5616         100     36     33     88   $subtree_root and $subtree_root == $next_elt
5619         100     28     33      4   $subtree_root and $subtree_root == $next_elt
5661  ***     66     12      0     17   ref $_[0] and isa($_[0], 'XML::Twig::Elt')
             100      8     12     17   defined $_[0] and (ref $_[0] and isa($_[0], 'XML::Twig::Elt'))
5684         100      1      6     12   $elt and not $$elt{'next_sibling'}
5712         100      4      3     11   $elt and not $$elt{'prev_sibling'}
5755  ***     66      2      0   2473   ref $ancestor and isa($ancestor, 'XML::Twig::Elt')
6015  ***     33      0    118      0   $subtree_root and $elt == $subtree_root
6022  ***     66      0    525      3   $subtree_root and $elt == $subtree_root
6027  ***     66      0    279    111   $subtree_root and $subtree_root == $next_elt
6030  ***     66      0    414    111   $subtree_root and $subtree_root == $next_elt
6102         100      5      4      8   $_[0] and not $elt->matches(@_)
6150         100    165      1    290   $xpath_exp and $xpath_exp =~ s[^\s*(/?)                            
                            # the xxx=~/regexp/ is a pain as it includes /  
                            (\s*(?:(?:($REG_AXIS)::)?(\*|$REG_NAME|\.\.|\.)\s*)?($REG_PREDICATE_ALT*)
                            )
                            (/|$)][]ox
6176         100    141    114     30   $predicates and $predicates =~ /^\s*\[\s*((-\s*)?\d+)\s*\]\s*$/
             100    141    111      3   $predicates and $predicates =~ /^\s*\[\s*last\s*\(\s*\)\s*\]\s*$/
6218         100      1    112     40   not $syntax_error and $pred
6346         100    178     57    122   $prev_sibling and $next_sibling
             100    235     68     54   $prev_sibling and $next_sibling and $prev_sibling->is_text
             100    303     49      5   $prev_sibling and $next_sibling and $prev_sibling->is_text and $XML::Twig::index2gi[$$prev_sibling{'gi'}] eq $XML::Twig::index2gi[$$next_sibling{'gi'}]
6416         100     42      5     14   $prev_sibling and $prev_sibling->is_text
             100     47      2     12   $prev_sibling and $prev_sibling->is_text and $XML::Twig::index2gi[$$first_child{'gi'}] eq $XML::Twig::index2gi[$$prev_sibling{'gi'}]
6418         100     29     10     22   $next_sibling and $next_sibling->is_text
             100     39     12     10   $next_sibling and $next_sibling->is_text and $XML::Twig::index2gi[$$last_child{'gi'}] eq $XML::Twig::index2gi[$$next_sibling{'gi'}]
6422  ***     66     52      0      9   $$elt{'parent'}{'twig_current'} and $$elt{'last_child'}->is_text
6502         100      2      2    496   ref $_[0] and isa($_[0], 'XML::Twig::Elt')
6514         100    287    199     10   not $$ref{'parent'} and $pos =~ /^(before|after)$/
             100    486      2      8   not $$ref{'parent'} and $pos =~ /^(before|after)$/ and not exists $$elt{'target'}
             100    488      2      6   not $$ref{'parent'} and $pos =~ /^(before|after)$/ and not exists $$elt{'target'} and not exists $$elt{'comment'}
6523  ***     66    468      0     22   my $ids = $$elt{'twig_id_list'} and my $t = $ref->twig
6709  ***     66    120      1      0   $options{'var_regexp'} and not $options{'var'}
6759  ***     66      0      3      6   ref $child_data eq 'HASH' && keys %$child_data == 1
      ***     66      3      0      6   ref $child_data eq 'HASH' && keys %$child_data == 1 && defined(my $grouped_child_data = $$child_data{$grouped_tag})
6769         100     11      4     12   ref $child_data eq 'HASH' and keys %$child_data == 1
             100     15      4      8   ref $child_data eq 'HASH' and keys %$child_data == 1 and defined(my $content = $$child_data{$$options{'content_key'}})
7003         100      4     15     13   $previous_match and $text
7017  ***     33      0      0     77   $] >= 5.008 and not _keep_encoding()
7052  ***     33      0      0     38   $next_sibling = $$text_elt{'next_sibling'} and $XML::Twig::index2gi[$$text_elt{'gi'}] eq $XML::Twig::index2gi[$$next_sibling{'gi'}]
7067  ***     66      2     36      0   $prev_sibling = $$post_match{'prev_sibling'} and $XML::Twig::index2gi[$$post_match{'gi'}] eq $XML::Twig::index2gi[$$prev_sibling{'gi'}]
7126  ***     66      1      0     67   $e1->is_text and $e2->is_text
             100      1      1     66   $e1->is_text and $e2->is_text and $e1->gi eq $e2->gi
7152  ***     33      0      0      2   $e1->_last_child and $e1->_last_child->is_pcdata
      ***     33      0      0      2   $e1->_last_child and $e1->_last_child->is_pcdata and @e2_children
      ***     33      0      0      2   $e1->_last_child and $e1->_last_child->is_pcdata and @e2_children and $e2_children[0]->is_pcdata
7227  ***     33      0      4      0   $ID and $t
      ***     33      4      0      0   $ID and $t and defined $$elt{'att'}
      ***     33      4      0      0   $ID and $t and defined $$elt{'att'} and exists $$elt{'att'}{$ID}
7549  ***     66   4377      0     37   $$option{'escape_gt'} and not $replaced_ents =~ />/
7552  ***     66   1171      0     17   substr($_, 0, 1) eq '#' && substr($_, 0, 9) ne '#default:'
7565         100    661      2      1   $pretty == $INDENTEDA and @att_names == 1
7574         100   4277     99     38   $empty_tag_style eq $HTML and not $$elt{'first_child'}
      ***     66   4376      0     38   $empty_tag_style eq $HTML and not $$elt{'first_child'} and not $elt->_extra_data_before_end_tag
             100   4376     17     21   $empty_tag_style eq $HTML and not $$elt{'first_child'} and not $elt->_extra_data_before_end_tag and $html_empty_elt{$gi}
7577         100   1034      8     21   $empty_tag_style eq $HTML && $html_empty_elt{$gi}
             100   1040      1      1   $pretty == $INDENTEDA && @att_names > 1
      ***     66   1040      0      1   $pretty == $INDENTEDA && @att_names == 1
7586  ***     66   4411      0      3   substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 1) eq '#' and substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 9) ne '#default:'
7609  ***     66      1      2      0   $parent and $$parent{'contains_text'}
7619  ***     66     47    132      0   $parent and $$parent{'contains_text'}
7627  ***     66      0    146      3   $t and $$t{'twig_keep_spaces_in'}
7646  ***     66   3334      0   1030   $$elt{'empty'} || 0 and not $elt->_extra_data_before_end_tag
7660  ***     66   3331      0      3   substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 1) eq '#' and substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 9) ne '#default:'
7681  ***     66      1      0      2   $parent && !$$parent{'contains_text'}
      ***     66      2      0      1   not $$elt{'contains_text'} and $$elt{'has_flushed_child'} || $elt->_first_child
      ***     66      0      2      1   $parent && !$$parent{'contains_text'} || !$parent and (not $$elt{'contains_text'} and $$elt{'has_flushed_child'} || $elt->_first_child)
7691  ***     66     39      0     44   $parent && !$$parent{'contains_text'}
             100     33     10     40   not $$elt{'contains_text'} and $$elt{'has_flushed_child'} || $elt->_first_child
      ***     66      0     43     40   $parent && !$$parent{'contains_text'} || !$parent and (not $$elt{'contains_text'} and $$elt{'has_flushed_child'} || $elt->_first_child)
7705  ***     66      0     44      1   $t and $$t{'twig_keep_spaces_in'}
7756  ***     33     43      0      0   $pretty == $WRAPPED || $pretty == $INDENTEDC and not $xml_space_preserve
7760  ***      0      0      0      0   $pretty == $WRAPPED || $pretty == $INDENTEDC and not $xml_space_preserve
7779  ***     66      6      8      0   $_[0] && isa($_[0], 'XML::Twig::Elt')
7784  ***     66      2      0      2   $_[0] && isa($_[0], 'XML::Twig::Elt')
7847  ***     66     25      0      1   @options and grep {lc $_ eq 'no_recurse';} @options
7881         100   1537   1561      6   $_[0] and isa($_[0], 'HASH')
7894  ***     66   3099      0      5   $pretty == $WRAPPED || $pretty == $INDENTEDC and not $xml_space_preserve
7949  ***     66   1459      1      0   $pretty >= $INDENTED and not $$elt{'parent'}{'contains_text'}
7952  ***     66   1615      1      0   $pretty >= $INDENTED and not $$elt{'parent'}{'contains_text'}
8038  ***     33      1      0      0   $_[0] and $_[0]{'escape_gt'}
      ***     33      1      0      0   $_[0] and $_[0]{'escape_gt'} and not $replace =~ />/
8070  ***     66     35      0      9   $expand_external_entities and $t = $ent->twig
      ***     66     35      0      9   $expand_external_entities and $t = $ent->twig and $el = $t->entity_list
      ***     66     35      0      9   $expand_external_entities and $t = $ent->twig and $el = $t->entity_list and $ent_string = $$el{'entities'}{$ent->ent_name}{'val'}
8084  ***     66   2799      0      2   @options and grep {lc $_ eq 'no_recurse';} @options
8160         100      6      2     10   @descendants and $$desc{'next_sibling'}
             100      8      7      3   @descendants and $$desc{'next_sibling'} and $$desc{'next_sibling'} == $descendants[0]
8181  ***     66      4      0     39   $data and my $start_element = $handler->can('start_element')
8187  ***     66      4      0     39   my $data = &$end_tag_data($elt) and my $end_element = $handler->can('end_element')
8192         100      7      2     20   exists $$elt{'pcdata'} and my $characters = $handler->can('characters')
      ***     66      5      0      2   exists $$elt{'target'} and my $pi = $handler->can('processing_instruction')
      ***     66      3      0      2   exists $$elt{'comment'} and my $comment = $handler->can('comment')
8224  ***     66     13      0      2   substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 1) eq '#' and substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 9) ne '#default:'
8228  ***     66      2      0      2   substr($att, 0, 1) eq '#' and substr($att, 0, 9) ne '#default:'
8235  ***     66     11      0      2   substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 1) eq '#' and substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 9) ne '#default:'
8244  ***     66     30      0      2   substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 1) eq '#' and substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 9) ne '#default:'
8265  ***     66     13      0      2   substr($att, 0, 1) eq '#' and substr($att, 0, 9) ne '#default:'
8281         100     13     23      7   my $start_prefix_mapping = $handler->can('start_prefix_mapping') and my(@new_prefix_mappings) = grep({/^\{$XMLNS_URI\}/ unless /^\{[^}]*\}xmlns/;} keys %{$$data{'Attributes'};})
8308  ***     66     28      0      2   substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 1) eq '#' and substr($XML::Twig::index2gi[$$elt{'gi'}], 0, 9) ne '#default:'
8372         100      8    105      5   not ref $_[0] and $_[0] eq '#EMPTY'
8377         100    100      1     12   $XML::Twig::index2gi[$$elt{'gi'}] eq '#PCDATA' || $elt->contains_a_single('#PCDATA') and @_ == 1
      ***     66    101      0     12   $XML::Twig::index2gi[$$elt{'gi'}] eq '#PCDATA' || $elt->contains_a_single('#PCDATA') and @_ == 1 and not ref $_[0]
      ***     66    100      0      1   $XML::Twig::index2gi[$$elt{'gi'}] eq '#CDATA' and @_ == 1
      ***     66    100      0      1   $XML::Twig::index2gi[$$elt{'gi'}] eq '#CDATA' and @_ == 1 and not ref $_[0]
8394  ***     66     95      0     25   ref $child and isa($child, 'XML::Twig::Elt')
8400         100     92      1      2   my $pcdata = $$elt{'last_child'} and $$elt{'last_child'}->is_pcdata
8430  ***     66      5      0      2   defined $args[0] and isa($args[0], 'HASH')
8487  ***     33      0      0      1   $twig and $twig->root
      ***     33      0      0      1   $twig and $twig->root and $twig->root eq $elt
8508  ***     66      6      0     10   defined $_[0] and isa($_[0], 'HASH')
8564  ***     66     11      0      5   $option && $option eq 'asis'
8565  ***     33      2      0      0   $asis && $$elt{'asis'}
      ***     33      0      0      2   !$asis && !$$elt{'asis'}
      ***     66     14      0      2   exists $$elt{'pcdata'} and $asis && $$elt{'asis'} || !$asis && !$$elt{'asis'}
             100      1      6      7   $$elt{'first_child'} and $$elt{'first_child'}->is_pcdata
             100      4      1      2   $asis && $$elt{'first_child'}{'asis'}
             100      1      1      3   !$asis && !$$elt{'first_child'}{'asis'}
             100      7      2      5   $$elt{'first_child'} and $$elt{'first_child'}->is_pcdata and $asis && $$elt{'first_child'}{'asis'} || !$asis && !$$elt{'first_child'}{'asis'}
8587  ***     66      7      0      5   $option && $option eq 'asis'
8588  ***     33      1      0      0   $asis && $$elt{'asis'}
      ***     33      0      0      1   !$asis && !$$elt{'asis'}
      ***     66     11      0      1   exists $$elt{'pcdata'} and $asis && $$elt{'asis'} || !$asis && !$$elt{'asis'}
      ***     66      0      4      7   $$elt{'last_child'} and $$elt{'last_child'}->is_pcdata
             100      3      1      3   $asis && $$elt{'last_child'}{'asis'}
             100      1      1      2   !$asis && !$$elt{'last_child'}{'asis'}
             100      4      2      5   $$elt{'last_child'} and $$elt{'last_child'}->is_pcdata and $asis && $$elt{'last_child'}{'asis'} || !$asis && !$$elt{'last_child'}{'asis'}
8619         100      6      4      8   $index == 1 and not $ancestor->next_sibling($gi)
8852         100      7     14      3   $atts and my(@atts) = $elt->att_names

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
436          100     66   2704   $args{'EltClass'} || 'XML::Twig::Elt'
542   ***     66   1756   1006   0
549   ***     66   1753   1008   0
560          100      1    967   $args{'ParseStartTag'} || \&_parse_start_tag
1022         100     35   2929   $version ||= 0
1189         100     63    489   $$handlers{'handlers'}{'string'}{$path} || undef
1238  ***     50    249      0   $$a{'score'}{'type'} || 0
      ***     50    249      0   $$b{'score'}{'type'} || 0
             100      8    241   $$b{'score'}{'anchored'} || 0
             100     14    235   $$a{'score'}{'anchored'} || 0
      ***     50    231      0   $$b{'score'}{'steps'} || 0
      ***     50    231      0   $$a{'score'}{'steps'} || 0
      ***     50    217      0   $$b{'score'}{'predicates'} || 0
      ***     50    217      0   $$a{'score'}{'predicates'} || 0
      ***     50      0    175   $$b{'score'}{'tests'} || 0
      ***     50      0    175   $$a{'score'}{'tests'} || 0
1254         100      7      2   $1 || ''
1355         100    550      3   $tag ||= '*'
1512         100     61      2   $$t{'twig_handlers'} ||= {}
1518         100     21    172   $$t{'twig_handlers'} || undef
1526  ***     50      3      0   $$t{'twig_starttag_handlers'} ||= {}
1532         100      2     24   $$t{'twig_starttag_handlers'} || undef
1540  ***     50      0      1   $$t{'twig_ignore_elts_handlers'} ||= {}
1554         100      1      1   $$t{'twig_endtag_handlers'} ||= {}
1576         100     10     50   $$t{'twig_handlers'} ||= {}
2337         100    236   2531   $$t{'twig_stored_spaces'} || ''
2476         100      1     41   $level || 0
2485  ***     50      0    102   $$t{'twig_xmldecl'} ||= {}
2496  ***     50      0     77   $$t{'twig_doctype'} ||= {}
2511  ***      0      0      0   $internal ||= ''
2523         100      1      4   $$t{'ErrorContext'} || 0
2538         100     18     26   $$t{'twig_dtd'} ||= {}
2539         100     18     26   $$t{'twig_dtd'}{'model'} ||= {}
2540         100     18     26   $$t{'twig_dtd'}{'elt_list'} ||= []
2561  ***     50     37      0   $$t{'twig_dtd'} ||= {}
2562         100     15     22   $$t{'twig_dtd'}{$gi} ||= {}
2725  ***     50      3      0   $$doctype{'name'} || ''
2731         100      2      1   $$doctype{'sysid'} || ''
2737         100      1      2   $$doctype{'pub'} || ''
2743         100      2      1   $$doctype{'internal'} || ''
2783  ***     50    886      0   $$t{'twig_output_fh'} || select || \*STDOUT
2800         100      9   2262   $args{'UpdateDTD'} || ''
2821         100      4      3   $t->entity_list->text || ''
2871         100    579   1683   $$t{'trailing_cpi_text'} || ''
2897         100      1     19   $$t{'twig_keep_spaces'} || ''
      ***     50      0      1   $$t{'trailing_spaces'} || ''
3566  ***     50    373      0   $$t{'twig_output_fh'} || select || \*STDOUT
3623  ***     50    295      0   $$t{'twig_output_fh'} || select || \*STDOUT
3657  ***     50     19      0   $$t{'twig_output_fh'} || select || \*STDOUT
3750  ***     50     47      0   shift @_ || 1
3806  ***     50      4      0   $$t{'twig_xmldecl'} ||= {}
3817         100     13      5   $t->output_filter || ''
3820         100     12      4   $encoding || ''
3831  ***     50      1      0   $$t{'twig_xmldecl'} ||= {}
3841  ***     50      1      0   $$t{'twig_xmldecl'} ||= {}
4571         100     46     24   $DEFAULT_NS{$prefix} || $elt->_inherit_att_through_cut($ns_att) || ''
4684         100      2      3   $_[0]{'empty'} || 0
4690  ***     50      1      0   $_[0]{'empty'} or 0
4742         100    346   5413   $_[0]{'extra_data_before_end_tag'} || ''
4884         100     16    141   $_[0]{'extra_data'} || ''
4974         100      2      1   @children || 1
5311         100   1393   9046   $_[0] || ''
5936  ***     50    349      0   shift @_ || ''
6269  ***     50      0      2   $XML::Twig::XPath::VERSION or 0
6450         100      2      5   $target->extra_data || ''
6464         100      2      1   $target->extra_data || ''
6524  ***     50     22      0   $$t{'twig_id_list'} ||= {}
6661         100      5    111   $options{'normalize_space'} || 0
6663         100     15    106   $options{'content_key'} ||= 'content'
6672         100     10    111   $options{'forcearray'} ||= 0
6679         100     30     91   $options{'keyattr'} ||= ['name', 'key', 'id']
6683  ***     50      0    293   $prefix ||= ''
6692         100     10      5   $prefix ||= ''
6705         100      1      6   $options{'var'} ||= 1
6711         100      1    120   $options{'var_regexp'} ||= '\\$\\{?(\\w+)\\}?'
6787         100    121    118   $$data{$child_gi} ||= []
6989  ***     50     33      0   \%{$tags[$i]{'atts'};} || {}
6998  ***     50     12      0   \%{$tags[0]{'atts'};} || {}
7171         100      4     57   $$elt{'empty'} || 0
7531         100    621   3793   $$elt{'extra_data'} || ''
7646         100   1030   3334   $$elt{'empty'} || 0
7658         100    319   3015   $elt->_extra_data_before_end_tag || ''
7746         100      1     42   $pretty ||= 0
7749  ***     50      0     43   $elt->inherit_att('xml:space') || ''
7796  ***     50      0   1689   $elt->inherit_att('xml:space') || ''
7810  ***     50      0   1214   $$elt{'att'}{'xml:space'} || ''
7853         100      8      1   $$elt{'first_child'} || ''
7887         100      1   3103   $elt->inherit_att('xml:space') || ''
7925         100   1562   7733   shift @_ || 0
7930         100      1   4710   $$elt{'att'}{'xml:space'} || ''
8094         100   1146     16   $$elt{'first_child'} || ''
8292         100      2      5   $$elt{'twig_end_prefix_mapping'} ||= []
8635  ***     50     37      0   $child->start_tag({'escape_gt', 1}) || ''
8668         100      3     10   $atts ||= {}
8738         100      1      4   $opt{'order'} ||= 'normal'
8739         100      3      2   $opt{'type'} ||= 'alpha'

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
490          100      8      2      1   $$self{'twig_roots'} or $args{'ForceEndTagHandlersUsage'}
660   ***     66     35      0   2780   not ref $t or not isa($t, 'XML::Twig')
714   ***     33      0      0      6   $$t{'twig_keep_encoding'} or $] < 5.006
831   ***     66     14      4      0   $parser ||= 'XML::Parser'->new
1105  ***     66      1      4      0   $agent ||= 'LWP::UserAgent'->new
1118  ***      0      0      0      0   $agent ||= 'LWP::UserAgent'->new
1184  ***     66    958      0     14   isa($_[0], 'GLOB') or isa($_[0], 'IO::Scalar')
1191         100     25      9    518   _set_special_handler($handlers, $path, $handler, $prev_handler) or _set_pi_handler($handlers, $path, $handler, $prev_handler)
             100     34      3    515   _set_special_handler($handlers, $path, $handler, $prev_handler) or _set_pi_handler($handlers, $path, $handler, $prev_handler) or _set_level_handler($handlers, $path, $handler, $prev_handler)
             100     37      3    512   _set_special_handler($handlers, $path, $handler, $prev_handler) or _set_pi_handler($handlers, $path, $handler, $prev_handler) or _set_level_handler($handlers, $path, $handler, $prev_handler) or _set_regexp_handler($handlers, $path, $handler, $prev_handler)
             100     40    506      6   _set_special_handler($handlers, $path, $handler, $prev_handler) or _set_pi_handler($handlers, $path, $handler, $prev_handler) or _set_level_handler($handlers, $path, $handler, $prev_handler) or _set_regexp_handler($handlers, $path, $handler, $prev_handler) or _set_xpath_handler($handlers, $path, $handler, $prev_handler)
1238  ***     66      0     18    231   ($$a{'score'}{'type'} || 0) <=> ($$b{'score'}{'type'} || 0) or ($$b{'score'}{'anchored'} || 0) <=> ($$a{'score'}{'anchored'} || 0)
             100     18     14    217   ($$a{'score'}{'type'} || 0) <=> ($$b{'score'}{'type'} || 0) or ($$b{'score'}{'anchored'} || 0) <=> ($$a{'score'}{'anchored'} || 0) or ($$b{'score'}{'steps'} || 0) <=> ($$a{'score'}{'steps'} || 0)
             100     32     42    175   ($$a{'score'}{'type'} || 0) <=> ($$b{'score'}{'type'} || 0) or ($$b{'score'}{'anchored'} || 0) <=> ($$a{'score'}{'anchored'} || 0) or ($$b{'score'}{'steps'} || 0) <=> ($$a{'score'}{'steps'} || 0) or ($$b{'score'}{'predicates'} || 0) <=> ($$a{'score'}{'predicates'} || 0)
      ***     66     74      0    175   ($$a{'score'}{'type'} || 0) <=> ($$b{'score'}{'type'} || 0) or ($$b{'score'}{'anchored'} || 0) <=> ($$a{'score'}{'anchored'} || 0) or ($$b{'score'}{'steps'} || 0) <=> ($$a{'score'}{'steps'} || 0) or ($$b{'score'}{'predicates'} || 0) <=> ($$a{'score'}{'predicates'} || 0) or ($$b{'score'}{'tests'} || 0) <=> ($$a{'score'}{'tests'} || 0)
1369  ***     66     47    506      0   $last_tag ||= $tag
1441         100     40      2    367   $func or $string_regexp
      ***     66     42      0    367   $func or $string_regexp or $string_test_num
             100     42      2    365   $func or $string_regexp or $string_test_num or $string_test_alpha
1502  ***     66    295      1      0   shift @_ || return
1653  ***     66   1755      0  16135   $$t{'twig_stored_spaces'} or $option{'force'}
             100   1755      2  16133   $$t{'twig_stored_spaces'} or $option{'force'} or $$t{'twig_preserve_space'}
1661         100     77      8   1670   $$t{'twig_space_policy'}{$current_gi} or not $$t{'twig_stored_spaces'} =~ /\n/
      ***     66     85      0   1670   $$t{'twig_space_policy'}{$current_gi} or not $$t{'twig_stored_spaces'} =~ /\n/ or $option{'force'}
             100     85      5   1665   $$t{'twig_space_policy'}{$current_gi} or not $$t{'twig_stored_spaces'} =~ /\n/ or $option{'force'} or $$t{'twig_preserve_space'}
1851  ***     66     13      2      0   $$t{'twig_map_xmlns'}{$$ns_info{'uri'}} || $$ns_info{'prefix'}
2197  ***     66      7   1456      0   $$t{'twig_handlers'}{'pi_handlers'} || return
2221         100      1      1      2   not defined $comment or $comment eq ''
2323  ***     66   1352   1550      0   $$t{$type} ||= $$t{'twig_elt_class'}->new('#CPI')
2676         100     51      4   2216   $$t{'twig_xmldecl'} or $$t{'output_encoding'}
2783  ***     33      0    886      0   $$t{'twig_output_fh'} || select
2859  ***     66    777   1494      0   $$t{'leading_cpi'} || return('')
2865  ***     66    772   1490      0   $$t{'trailing_cpi'} || return('')
3133  ***     33     87      0      0   $t->root || return(undef)
3140  ***     33      7      0      0   $t->root || return(undef)
3358  ***     66      0      2      2   not $input_filter or isa($input_filter, 'CODE')
3515  ***     66      3      0      2   $internal or $expat_1_95_2
3535  ***     66      3      0      8   $internal or $expat_1_95_2
3566  ***     66    154    219      0   $$t{'twig_output_fh'} || select
3605  ***     66      8      4      0   !@handlers || $last_handler_res
3623  ***     66    134    161      0   $$t{'twig_output_fh'} || select
3630  ***     66      8      2      0   &$handler($t, $gi) || last
3657  ***     66     18      1      0   $$t{'twig_output_fh'} || select
3659  ***     66      1      0     18   $$t{'twig_handlers'}{'pi_handlers'}{$target} || $$t{'twig_handlers'}{'pi_handlers'}{''}
3724  ***     33     12      0      0   &$handler($t, $gi) || last
3743         100     32      1     16   $elt == $current or $$current{'last_child'} and $elt == $$current{'last_child'}
             100     33     14      2   $elt == $current or $$current{'last_child'} and $elt == $$current{'last_child'} or $current->in($elt)
3819  ***     66      5      0     13   $encoding and not $encoding =~ /^utf-?8$/i or $$t{'twig_keep_encoding'}
             100      5     11      2   $encoding and not $encoding =~ /^utf-?8$/i or $$t{'twig_keep_encoding'} or $output_filter
3992  ***     66      0     12      4   $_[1] || $_[0]
4241  ***     33      0     80      0   ref $class || $class
4417  ***     66    464  21698      0   ref $class || $class
4571         100      6     40     24   $DEFAULT_NS{$prefix} || $elt->_inherit_att_through_cut($ns_att)
4601  ***      0      0      0      0   $$elt{'parent'} || $elt->former_parent
4674  ***     33      0      0      1   exists $$elt{'ent'} || $$elt{'ent_name'}
4680         100   1019     12    974   exists $$elt{'pcdata'} || exists $$elt{'cdata'}
4719  ***     33     15      0      0   $elt->twig || return
4774         100      2      1      3   _match_extra_data_words($elt, $initial, $modified) or _match_extra_data_chars($elt, $initial, $modified)
4810  ***     33      0      2      0   shift @$positions || $length + 1
4830  ***     33      0      1      0   shift @$positions || $length + 1
4994  ***      0      0      0      0   $$elt{'parent'} or $elt->former_parent
      ***      0      0      0      0   $$elt{'parent'} || $elt->former_parent
5159  ***     66    511     94      0   $cond_cache{$cond} ||= _install_cond($cond)
5171  ***     66     26     15      0   shift @_ || return($$elt{'parent'})
5172  ***     66      0     22     13   not $elt or $elt->passes($cond)
      ***     66     35      4      0   $$elt{'parent'} || return
5183  ***     66    338    194      0   shift @_ || return($$elt{'first_child'})
5185  ***     66    135    203      0   $cond_cache{$cond} ||= _install_cond($cond)
5226  ***     66     26     27      0   shift @_ || return($$elt{'last_child'})
5227  ***     66     22      4      0   $cond_cache{$cond} ||= _install_cond($cond)
5242  ***     66     57     42      0   shift @_ || return($$elt{'prev_sibling'})
5243  ***     66     50      7      0   $cond_cache{$cond} ||= _install_cond($cond)
5254  ***     66    162    328      0   shift @_ || return($$elt{'next_sibling'})
5255  ***     33    162      0      0   $cond_cache{$cond} ||= _install_cond($cond)
5389  ***     66     97    517      0   $elt->twig || $elt
5425  ***     66      0      8      2   shift @_ || $elt->twig
5536         100      5      3      4   !%tags || $tags{$XML::Twig::index2gi[$$elt{'gi'}]}
5550  ***     66     57      0     24   $$elt{'parent'} || $elt->former_parent
      ***     33     40      0      0   !%tags || $tags{$XML::Twig::index2gi[$$elt{'gi'}]}
5592  ***     66    284      6      0   $cond_cache{$cond} ||= _install_cond($cond)
5596  ***     66      0     11    480   not defined $elt or not defined $cond
             100     11     97    383   not defined $elt or not defined $cond or defined $ind and $$elt{'gi'} eq $ind
             100    108    196    187   not defined $elt or not defined $cond or defined $ind and $$elt{'gi'} eq $ind or defined $test_cond and &$test_cond($elt)
5617  ***     66     58     11      0   $$next_elt{'parent'} || return(undef)
5640         100      4     19     15   not $cond or $last_descendant->matches($cond)
5675  ***     66     58      7      0   $$elt{'parent'} || return(undef)
5691  ***     66      6      1      0   $elt->_following_elt || return(undef)
5692  ***     66      4      0      2   not $cond or $elt->matches($cond)
5719  ***     66      3      4      0   $elt->_preceding_elt || return(undef)
5720  ***     66      1      0      2   not $cond or $elt->matches($cond)
5746  ***     66      5      2      0   shift @_ || return(undef)
5748  ***     66      5      2      0   $elt->next_elt(@_) || return(undef)
5937         100    406      2      4   not $cond or $elt->matches($cond)
5979  ***     33     40      0      0   $$elt{'parent'} || last
5982  ***     33     19      0      0   $$next_elt{'parent'} || last MAIN
5987  ***     33     78      0      0   $next_elt || last MAIN
6003         100     64     50     89   not $cond or defined($ind = $XML::Twig::gi2index{$cond})
6025  ***     33    525      0      0   $$elt{'parent'} || last 
6028  ***     33    279      0      0   $$next_elt{'parent'} || last
6033  ***     33   1336      0      0   $next_elt || last
6034         100    746    154    436   not $cond or $$elt{'gi'} eq $ind
6172         100     22     59    204   not $gi or $gi eq '*'
6286         100      6    166      1   $xpath{$xpath_exp} ||= _install_xpath($xpath_exp)
6446         100     12      2      6   $$elt{'first_child'} || $$elt{'next_sibling'}
6541         100      1      1      2   exists $$elt{'comment'} or exists $$elt{'target'}
6571         100      1      1      2   exists $$elt{'comment'} or exists $$elt{'target'}
6661  ***     66      5    116      0   $options{'normalise_space'} ||= $options{'normalize_space'} || 0
6700  ***     33      0    121      0   $options{'var'} ||= $options{'var_attr'}
6724  ***     66     32      0    730   $$options{'noattr'} || !$elt->atts
6741  ***     66      0    200    275   $$options{'force_content'} or $nb_atts
             100    200      1    274   $$options{'force_content'} or $nb_atts or scalar @children > 1
6776         100     16      1    414   $$options{'forcearray'} or $$options{'forcearray_tags'}{$child_gi}
             100     17    222    192   $$options{'forcearray'} or $$options{'forcearray_tags'}{$child_gi} or $nb_children{$child_gi} > 1
6801         100    198      3    375   $$options{'remove_key_for_all'}{$att} or $$options{'remove_key_for_elt'}{"$gi#$att"}
6809  ***     66      0      3    372   $$options{'prefix_key_for_all'}{$att} or $$options{'prefix_key_for_elt'}{"$gi#$att"}
6897  ***     33      1      0      0   $elt->first_child('#TEXT') || return('')
7041  ***     66     26     13      0   $replace_sub{$replace} ||= _install_replace_sub($replace)
7221  ***     33      0      0      4   shift @_ || $elt->twig
7370         100      5      1   1653   $pretty == $WRAPPED or $pretty == $INDENTEDA
7402  ***     33      4      0      0   $_[1] || $_[0]
7473  ***     66      0      1   2782   isa($new_value, 'XML::Twig::Elt') or isa($new_value, 'XML::Twig')
7475         100   2756     20      7   not $new_value or isa($new_value, 'CODE')
7491  ***     66      0      1   2768   isa($new_value, 'XML::Twig::Elt') or isa($new_value, 'XML::Twig')
7493         100   2757      4      8   not $new_value or isa($new_value, 'CODE')
7577  ***     66   3351      0   1063   !$$elt{'empty'} || $elt->_extra_data_before_end_tag
7607  ***     66      1      0      2   not $parent or $$parent{'contains_text'}
7609  ***     66      0      2      1   $parent and $$parent{'contains_text'} or $elt->contains_text
7615  ***     66     47      0    132   not $parent or $$parent{'contains_text'}
7619  ***     66      0     33    146   $parent and $$parent{'contains_text'} or $elt->contains_text
7623  ***     66    149      0     71   $return or $indent
7646  ***     66      0   1030   3334   $$elt{'gi'} < $XML::Twig::SPECIAL_GI or $$elt{'empty'} || 0 and not $elt->_extra_data_before_end_tag
7681  ***     66      2      1      0   $parent && !$$parent{'contains_text'} || !$parent
      ***     33      0      1      0   $$elt{'has_flushed_child'} || $elt->_first_child
7691  ***     66     44     39      0   $parent && !$$parent{'contains_text'} || !$parent
             100      3     37     10   $$elt{'has_flushed_child'} || $elt->_first_child
7701  ***     66     45      0     78   $return or $indent
7747  ***     66      1      0     42   $pretty_print_style{$pretty} || $pretty
7756  ***     33      0      0     43   $pretty == $WRAPPED || $pretty == $INDENTEDC
      ***     33      0      0     43   $output_filter or $pretty == $WRAPPED || $pretty == $INDENTEDC and not $xml_space_preserve
7760  ***      0      0      0      0   $pretty == $WRAPPED || $pretty == $INDENTEDC
7870         100      3      1      1   $_->is_text or exists $$_{'ent'}
7894  ***     66      5      0   3099   $pretty == $WRAPPED || $pretty == $INDENTEDC
7974  ***     66     30      0     88   $keep_encoding or $$elt{'asis'}
7979  ***     66     20      0     63   $keep_encoding or $$elt{'asis'}
7988         100    332     17   1327   $keep_encoding or $$elt{'asis'}
8107         100      9      1      2   $_->is_text or exists $$_{'ent'}
8316  ***     66     37      0    131   $child->is_text or exists $$child{'ent'}
8377         100      1     12    100   $XML::Twig::index2gi[$$elt{'gi'}] eq '#PCDATA' || $elt->contains_a_single('#PCDATA')
8450         100      1     74     20   $position eq 'before' or $position eq 'after'
             100     75     10     10   $position eq 'before' or $position eq 'after' or $position eq 'first_child'
             100     85      7      3   $position eq 'before' or $position eq 'after' or $position eq 'first_child' or $position eq 'last_child'
8565  ***     33      0      2      0   $asis && $$elt{'asis'} || !$asis && !$$elt{'asis'}
             100      2      3      2   $asis && $$elt{'first_child'}{'asis'} || !$asis && !$$elt{'first_child'}{'asis'}
8588  ***     33      0      1      0   $asis && $$elt{'asis'} || !$asis && !$$elt{'asis'}
             100      3      2      2   $asis && $$elt{'last_child'}{'asis'} || !$asis && !$$elt{'last_child'}{'asis'}
8697  ***     33      0      3      0   $att ||= $cond
8706  ***     66      1      1      0   $tag ||= $att
8825  ***     66    296    197      0   $$a_prev{'prev_sibling'} || return(-1)
8827  ***     66    101     30      0   $$a_next{'next_sibling'} || return(1)
8829  ***     66     20      7      0   $$b_prev{'prev_sibling'} || return(1)
8831  ***     66      5      2      0   $$b_next{'next_sibling'} || return(-1)
8902  ***     66      0     24      3   not $length or length $string < $length


Covered Subroutines
-------------------

Subroutine                         Count Location                 
---------------------------------- ----- -------------------------
BEGIN                                 92 blib/lib/XML/Twig.pm:1026
BEGIN                                 95 blib/lib/XML/Twig.pm:114 
BEGIN                                 95 blib/lib/XML/Twig.pm:116 
BEGIN                                131 blib/lib/XML/Twig.pm:12  
BEGIN                                 92 blib/lib/XML/Twig.pm:122 
BEGIN                                 11 blib/lib/XML/Twig.pm:1420
BEGIN                                 10 blib/lib/XML/Twig.pm:1420
BEGIN                                 11 blib/lib/XML/Twig.pm:1420
BEGIN                                 10 blib/lib/XML/Twig.pm:1420
BEGIN                                 12 blib/lib/XML/Twig.pm:1420
BEGIN                                 10 blib/lib/XML/Twig.pm:1420
BEGIN                                 12 blib/lib/XML/Twig.pm:1420
BEGIN                                 14 blib/lib/XML/Twig.pm:1420
BEGIN                                 15 blib/lib/XML/Twig.pm:1420
BEGIN                                 12 blib/lib/XML/Twig.pm:1420
BEGIN                                 12 blib/lib/XML/Twig.pm:1420
BEGIN                                  6 blib/lib/XML/Twig.pm:1420
BEGIN                                  7 blib/lib/XML/Twig.pm:1420
BEGIN                                  8 blib/lib/XML/Twig.pm:1420
BEGIN                                  7 blib/lib/XML/Twig.pm:1420
BEGIN                                  5 blib/lib/XML/Twig.pm:1420
BEGIN                                  4 blib/lib/XML/Twig.pm:1420
BEGIN                                  4 blib/lib/XML/Twig.pm:1420
BEGIN                                  3 blib/lib/XML/Twig.pm:1420
BEGIN                                  3 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  2 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                  1 blib/lib/XML/Twig.pm:1420
BEGIN                                129 blib/lib/XML/Twig.pm:16  
BEGIN                                118 blib/lib/XML/Twig.pm:18  
BEGIN                                117 blib/lib/XML/Twig.pm:19  
BEGIN                                 92 blib/lib/XML/Twig.pm:2062
BEGIN                                115 blib/lib/XML/Twig.pm:27  
BEGIN                                 92 blib/lib/XML/Twig.pm:2784
BEGIN                                114 blib/lib/XML/Twig.pm:29  
BEGIN                                113 blib/lib/XML/Twig.pm:30  
BEGIN                                 92 blib/lib/XML/Twig.pm:3111
BEGIN                                112 blib/lib/XML/Twig.pm:32  
BEGIN                                 92 blib/lib/XML/Twig.pm:3299
BEGIN                                112 blib/lib/XML/Twig.pm:33  
BEGIN                                 92 blib/lib/XML/Twig.pm:3307
BEGIN                                111 blib/lib/XML/Twig.pm:35  
BEGIN                                 92 blib/lib/XML/Twig.pm:3589
BEGIN                                 92 blib/lib/XML/Twig.pm:3604
BEGIN                                 92 blib/lib/XML/Twig.pm:3608
BEGIN                                 92 blib/lib/XML/Twig.pm:3637
BEGIN                                 92 blib/lib/XML/Twig.pm:3670
BEGIN                                 92 blib/lib/XML/Twig.pm:371 
BEGIN                                110 blib/lib/XML/Twig.pm:38  
BEGIN                                111 blib/lib/XML/Twig.pm:39  
BEGIN                                110 blib/lib/XML/Twig.pm:40  
BEGIN                                  1 blib/lib/XML/Twig.pm:4080
BEGIN                                  1 blib/lib/XML/Twig.pm:4080
BEGIN                                  1 blib/lib/XML/Twig.pm:4095
BEGIN                                  1 blib/lib/XML/Twig.pm:4095
BEGIN                                  1 blib/lib/XML/Twig.pm:4095
BEGIN                                  1 blib/lib/XML/Twig.pm:4095
BEGIN                                107 blib/lib/XML/Twig.pm:41  
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                  1 blib/lib/XML/Twig.pm:4115
BEGIN                                 92 blib/lib/XML/Twig.pm:4146
BEGIN                                102 blib/lib/XML/Twig.pm:42  
BEGIN                                 92 blib/lib/XML/Twig.pm:4237
BEGIN                                 92 blib/lib/XML/Twig.pm:4314
BEGIN                                 92 blib/lib/XML/Twig.pm:4316
BEGIN                                 92 blib/lib/XML/Twig.pm:4318
BEGIN                                 92 blib/lib/XML/Twig.pm:4319
BEGIN                                 92 blib/lib/XML/Twig.pm:4320
BEGIN                                 92 blib/lib/XML/Twig.pm:4321
BEGIN                                 92 blib/lib/XML/Twig.pm:4322
BEGIN                                 92 blib/lib/XML/Twig.pm:4324
BEGIN                                 92 blib/lib/XML/Twig.pm:4326
BEGIN                                 92 blib/lib/XML/Twig.pm:4327
BEGIN                                 92 blib/lib/XML/Twig.pm:4328
BEGIN                                 92 blib/lib/XML/Twig.pm:4330
BEGIN                                 92 blib/lib/XML/Twig.pm:4331
BEGIN                                 92 blib/lib/XML/Twig.pm:4332
BEGIN                                 92 blib/lib/XML/Twig.pm:4333
BEGIN                                 92 blib/lib/XML/Twig.pm:4334
BEGIN                                 92 blib/lib/XML/Twig.pm:4335
BEGIN                                 92 blib/lib/XML/Twig.pm:4337
BEGIN                                 92 blib/lib/XML/Twig.pm:4343
BEGIN                                104 blib/lib/XML/Twig.pm:45  
BEGIN                                 92 blib/lib/XML/Twig.pm:4562
BEGIN                                101 blib/lib/XML/Twig.pm:46  
BEGIN                                 98 blib/lib/XML/Twig.pm:49  
BEGIN                                 99 blib/lib/XML/Twig.pm:50  
BEGIN                                 54 blib/lib/XML/Twig.pm:5099
BEGIN                                 23 blib/lib/XML/Twig.pm:5099
BEGIN                                 27 blib/lib/XML/Twig.pm:5099
BEGIN                                 32 blib/lib/XML/Twig.pm:5099
BEGIN                                 21 blib/lib/XML/Twig.pm:5099
BEGIN                                 25 blib/lib/XML/Twig.pm:5099
BEGIN                                 19 blib/lib/XML/Twig.pm:5099
BEGIN                                 17 blib/lib/XML/Twig.pm:5099
BEGIN                                  4 blib/lib/XML/Twig.pm:5099
BEGIN                                  4 blib/lib/XML/Twig.pm:5099
BEGIN                                  4 blib/lib/XML/Twig.pm:5099
BEGIN                                  4 blib/lib/XML/Twig.pm:5099
BEGIN                                  4 blib/lib/XML/Twig.pm:5099
BEGIN                                  4 blib/lib/XML/Twig.pm:5099
BEGIN                                  4 blib/lib/XML/Twig.pm:5099
BEGIN                                  4 blib/lib/XML/Twig.pm:5099
BEGIN                                  4 blib/lib/XML/Twig.pm:5099
BEGIN                                  4 blib/lib/XML/Twig.pm:5099
BEGIN                                  4 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  2 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  2 blib/lib/XML/Twig.pm:5099
BEGIN                                  2 blib/lib/XML/Twig.pm:5099
BEGIN                                  2 blib/lib/XML/Twig.pm:5099
BEGIN                                  2 blib/lib/XML/Twig.pm:5099
BEGIN                                  2 blib/lib/XML/Twig.pm:5099
BEGIN                                  2 blib/lib/XML/Twig.pm:5099
BEGIN                                  2 blib/lib/XML/Twig.pm:5099
BEGIN                                  2 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                  1 blib/lib/XML/Twig.pm:5099
BEGIN                                 99 blib/lib/XML/Twig.pm:53  
BEGIN                                 92 blib/lib/XML/Twig.pm:5399
BEGIN                                 92 blib/lib/XML/Twig.pm:6121
BEGIN                                  4 blib/lib/XML/Twig.pm:6259
BEGIN                                  3 blib/lib/XML/Twig.pm:6259
BEGIN                                  3 blib/lib/XML/Twig.pm:6259
BEGIN                                  3 blib/lib/XML/Twig.pm:6259
BEGIN                                  3 blib/lib/XML/Twig.pm:6259
BEGIN                                  3 blib/lib/XML/Twig.pm:6259
BEGIN                                  3 blib/lib/XML/Twig.pm:6259
BEGIN                                  3 blib/lib/XML/Twig.pm:6259
BEGIN                                  3 blib/lib/XML/Twig.pm:6259
BEGIN                                  5 blib/lib/XML/Twig.pm:6259
BEGIN                                  3 blib/lib/XML/Twig.pm:6259
BEGIN                                  2 blib/lib/XML/Twig.pm:6259
BEGIN                                 95 blib/lib/XML/Twig.pm:63  
BEGIN                                 92 blib/lib/XML/Twig.pm:6478
BEGIN                                  1 blib/lib/XML/Twig.pm:7114
BEGIN                                  1 blib/lib/XML/Twig.pm:7114
BEGIN                                  1 blib/lib/XML/Twig.pm:7114
BEGIN                                  1 blib/lib/XML/Twig.pm:7114
BEGIN                                 92 blib/lib/XML/Twig.pm:7241
BEGIN                                 92 blib/lib/XML/Twig.pm:7524
BEGIN                                 92 blib/lib/XML/Twig.pm:8000
CDATA                                  5 blib/lib/XML/Twig.pm:13  
DESTROY                             2756 blib/lib/XML/Twig.pm:3417
DESTROY                            22004 blib/lib/XML/Twig.pm:7219
PCDATA                                 6 blib/lib/XML/Twig.pm:12  
_DTD_toSAX                             7 blib/lib/XML/Twig.pm:3958
_XmlUtf8Decode                         4 blib/lib/XML/Twig.pm:4048
__ANON__                               4 blib/lib/XML/Twig.pm:1110
__ANON__                              13 blib/lib/XML/Twig.pm:1269
__ANON__                              21 blib/lib/XML/Twig.pm:1285
__ANON__                             127 blib/lib/XML/Twig.pm:1747
__ANON__                              11 blib/lib/XML/Twig.pm:3119
__ANON__                              34 blib/lib/XML/Twig.pm:3308
__ANON__                               4 blib/lib/XML/Twig.pm:433 
__ANON__                               9 blib/lib/XML/Twig.pm:8717
__ANON__                               3 blib/lib/XML/Twig.pm:8724
__flush                             1689 blib/lib/XML/Twig.pm:7807
_a_proper_ns_prefix                   22 blib/lib/XML/Twig.pm:1857
_add_cpi_outside_of_root            2902 blib/lib/XML/Twig.pm:2322
_add_handler                         512 blib/lib/XML/Twig.pm:1228
_add_list                              5 blib/lib/XML/Twig.pm:4165
_add_or_discard_stored_spaces      20666 blib/lib/XML/Twig.pm:1649
_allow_use                             4 blib/lib/XML/Twig.pm:1016
_ancestors                             2 blib/lib/XML/Twig.pm:5523
_att_xml_string                     1171 blib/lib/XML/Twig.pm:8048
_atts_to_SAX2                         30 blib/lib/XML/Twig.pm:8261
_based_filename                       25 blib/lib/XML/Twig.pm:1055
_check_illegal_twig_roots_handlers    63 blib/lib/XML/Twig.pm:1584
_check_xml                            48 blib/lib/XML/Twig.pm:923 
_checked_parse_result               2807 blib/lib/XML/Twig.pm:681 
_children                              1 blib/lib/XML/Twig.pm:3202
_children                           3993 blib/lib/XML/Twig.pm:5445
_comment_elt_handler                1753 blib/lib/XML/Twig.pm:2212
_comment_text_handler               1879 blib/lib/XML/Twig.pm:2218
_croak                                42 blib/lib/XML/Twig.pm:2475
_croak_and_doublecheck_xpath           2 blib/lib/XML/Twig.pm:6267
_del_extra_data_in_pcdata              3 blib/lib/XML/Twig.pm:4738
_del_flushed                           1 blib/lib/XML/Twig.pm:6306
_descendants                          43 blib/lib/XML/Twig.pm:5955
_disallow_use                          5 blib/lib/XML/Twig.pm:1011
_dump                                  5 blib/lib/XML/Twig.pm:4130
_dump                                  1 blib/lib/XML/Twig.pm:4307
_dump                                 49 blib/lib/XML/Twig.pm:8837
_dump_extra_data                      14 blib/lib/XML/Twig.pm:8877
_encoding_filter                      16 blib/lib/XML/Twig.pm:3991
_encoding_from_meta                   21 blib/lib/XML/Twig.pm:930 
_end_prefix_mapping                   43 blib/lib/XML/Twig.pm:8299
_end_tag_data_SAX1                    13 blib/lib/XML/Twig.pm:8234
_end_tag_data_SAX2                    30 blib/lib/XML/Twig.pm:8307
_extra_data_before_end_tag          5759 blib/lib/XML/Twig.pm:4742
_extra_data_in_pcdata               2308 blib/lib/XML/Twig.pm:4736
_fill_default_atts                    48 blib/lib/XML/Twig.pm:1866
_first_child                        4061 blib/lib/XML/Twig.pm:5191
_first_n                             106 blib/lib/XML/Twig.pm:1036
_fix_xml                              27 blib/lib/XML/Twig.pm:871 
_flush                              1689 blib/lib/XML/Twig.pm:7789
_flush_toSAX                           6 blib/lib/XML/Twig.pm:3892
_flushed                            2200 blib/lib/XML/Twig.pm:6304
_following_elt                         7 blib/lib/XML/Twig.pm:5683
_gen_mark                             83 blib/lib/XML/Twig.pm:8007
_handler                            3705 blib/lib/XML/Twig.pm:2005
_html2xml                             28 blib/lib/XML/Twig.pm:849 
_indent_xhtml                          1 blib/lib/XML/Twig.pm:965 
_inherit_att_through_cut              64 blib/lib/XML/Twig.pm:5545
_insert_pcdata                      6377 blib/lib/XML/Twig.pm:2367
_install_cond                        314 blib/lib/XML/Twig.pm:5028
_install_replace_sub                  13 blib/lib/XML/Twig.pm:7096
_install_xpath                       167 blib/lib/XML/Twig.pm:6136
_is_fh                              3593 blib/lib/XML/Twig.pm:1184
_is_private                            2 blib/lib/XML/Twig.pm:8150
_is_private_name                       4 blib/lib/XML/Twig.pm:8151
_is_string                            23 blib/lib/XML/Twig.pm:7086
_is_well_formed_xml                   18 blib/lib/XML/Twig.pm:831 
_join_n                             1633 blib/lib/XML/Twig.pm:1429
_keep_encoding                        81 blib/lib/XML/Twig.pm:7458
_key_attr                            638 blib/lib/XML/Twig.pm:6825
_last_child                           40 blib/lib/XML/Twig.pm:5192
_last_descendant                      41 blib/lib/XML/Twig.pm:5648
_leading_cpi                        2271 blib/lib/XML/Twig.pm:2858
_level_in_stack                       30 blib/lib/XML/Twig.pm:3767
_local_name                          120 blib/lib/XML/Twig.pm:4556
_match_expr                           22 blib/lib/XML/Twig.pm:8678
_match_extra_data                     10 blib/lib/XML/Twig.pm:4797
_match_extra_data_chars                4 blib/lib/XML/Twig.pm:4789
_match_extra_data_words                6 blib/lib/XML/Twig.pm:4781
_match_tag                            13 blib/lib/XML/Twig.pm:8685
_move_extra_data_after_erase          80 blib/lib/XML/Twig.pm:6443
_next_sibling                         44 blib/lib/XML/Twig.pm:5193
_next_siblings                        76 blib/lib/XML/Twig.pm:5196
_normalize_args                     7340 blib/lib/XML/Twig.pm:1175
_normalize_space                      57 blib/lib/XML/Twig.pm:6854
_ns_info                              28 blib/lib/XML/Twig.pm:1844
_ns_prefix                           125 blib/lib/XML/Twig.pm:4547
_op                                   82 blib/lib/XML/Twig.pm:5150
_parent                              115 blib/lib/XML/Twig.pm:5195
_parse_as_xml_or_html                 10 blib/lib/XML/Twig.pm:817 
_parse_inplace                         6 blib/lib/XML/Twig.pm:705 
_parse_predicate_in_handler          169 blib/lib/XML/Twig.pm:1435
_parse_predicate_in_step             107 blib/lib/XML/Twig.pm:5108
_parse_start_tag                    1338 blib/lib/XML/Twig.pm:1888
_parse_xpath_handler                 512 blib/lib/XML/Twig.pm:1297
_parseurl                             20 blib/lib/XML/Twig.pm:1090
_pass_url_content                      4 blib/lib/XML/Twig.pm:1130
_pi_elt_handlers                    1463 blib/lib/XML/Twig.pm:2196
_pi_text_handler                    1503 blib/lib/XML/Twig.pm:2203
_pos_offset                           10 blib/lib/XML/Twig.pm:4844
_preceding_elt                         7 blib/lib/XML/Twig.pm:5711
_prefix_extra_data_before_end_tag      9 blib/lib/XML/Twig.pm:4746
_prev_sibling                         76 blib/lib/XML/Twig.pm:5194
_prev_siblings                        89 blib/lib/XML/Twig.pm:5197
_prolog_toSAX                          7 blib/lib/XML/Twig.pm:3941
_protect_extra_data                   88 blib/lib/XML/Twig.pm:8013
_push_extra_data_in_pcdata           111 blib/lib/XML/Twig.pm:4740
_quoted_val                          113 blib/lib/XML/Twig.pm:4302
_replace_ns                           48 blib/lib/XML/Twig.pm:1791
_replace_prefix                      125 blib/lib/XML/Twig.pm:2031
_replace_var                          27 blib/lib/XML/Twig.pm:7089
_replace_vars_in_text                117 blib/lib/XML/Twig.pm:6873
_reset_handlers                      296 blib/lib/XML/Twig.pm:1493
_reset_twig                            5 blib/lib/XML/Twig.pm:1634
_restore_original_prefix              33 blib/lib/XML/Twig.pm:7721
_self                                  6 blib/lib/XML/Twig.pm:5740
_set_cdata                           214 blib/lib/XML/Twig.pm:4949
_set_comment                        3518 blib/lib/XML/Twig.pm:4930
_set_extra_data_before_end_tag       324 blib/lib/XML/Twig.pm:4743
_set_extra_data_in_pcdata             12 blib/lib/XML/Twig.pm:4737
_set_fh_to_selected_fh              2767 blib/lib/XML/Twig.pm:3792
_set_fh_to_twig_output_fh           2805 blib/lib/XML/Twig.pm:3779
_set_flushed                         107 blib/lib/XML/Twig.pm:6305
_set_handler                         552 blib/lib/XML/Twig.pm:1187
_set_handlers                        296 blib/lib/XML/Twig.pm:1502
_set_id                              614 blib/lib/XML/Twig.pm:5388
_set_level_handler                   518 blib/lib/XML/Twig.pm:1266
_set_pcdata                        13051 blib/lib/XML/Twig.pm:4755
_set_pi                             2934 blib/lib/XML/Twig.pm:4909
_set_pi_handler                      527 blib/lib/XML/Twig.pm:1250
_set_regexp_handler                  515 blib/lib/XML/Twig.pm:1281
_set_special_handler                 552 blib/lib/XML/Twig.pm:1208
_set_xpath_handler                   512 blib/lib/XML/Twig.pm:1218
_short_text                           27 blib/lib/XML/Twig.pm:8901
_simplify                            762 blib/lib/XML/Twig.pm:6718
_slurp                                17 blib/lib/XML/Twig.pm:1066
_slurp_fh                              1 blib/lib/XML/Twig.pm:1076
_slurp_uri                            10 blib/lib/XML/Twig.pm:1049
_space_policy                        845 blib/lib/XML/Twig.pm:2387
_split                                32 blib/lib/XML/Twig.pm:6942
_sprint                             9295 blib/lib/XML/Twig.pm:7924
_start_prefix_mapping                 43 blib/lib/XML/Twig.pm:8280
_start_tag_data_SAX1                  15 blib/lib/XML/Twig.pm:8222
_start_tag_data_SAX2                  32 blib/lib/XML/Twig.pm:8240
_store_var                            68 blib/lib/XML/Twig.pm:6887
_stringify_struct                     13 blib/lib/XML/Twig.pm:8631
_text_with_vars                      475 blib/lib/XML/Twig.pm:6841
_toSAX                                 5 blib/lib/XML/Twig.pm:3866
_toSAX                                72 blib/lib/XML/Twig.pm:8177
_to_utf8                              16 blib/lib/XML/Twig.pm:946 
_trailing_cpi                       2262 blib/lib/XML/Twig.pm:2864
_trailing_cpi_text                  2262 blib/lib/XML/Twig.pm:2870
_trigger_tdh                           4 blib/lib/XML/Twig.pm:1988
_try_moving_extra_data                12 blib/lib/XML/Twig.pm:4759
_twig_attlist                         37 blib/lib/XML/Twig.pm:2558
_twig_cdataend                        95 blib/lib/XML/Twig.pm:2166
_twig_cdatastart                      95 blib/lib/XML/Twig.pm:2122
_twig_char                         15976 blib/lib/XML/Twig.pm:2054
_twig_comment                       3637 blib/lib/XML/Twig.pm:2231
_twig_default                        333 blib/lib/XML/Twig.pm:2594
_twig_doctype                         77 blib/lib/XML/Twig.pm:2494
_twig_doctype_fin_print               16 blib/lib/XML/Twig.pm:1168
_twig_element                         44 blib/lib/XML/Twig.pm:2536
_twig_end                          10272 blib/lib/XML/Twig.pm:1912
_twig_end_check_roots                295 blib/lib/XML/Twig.pm:3617
_twig_entity                          68 blib/lib/XML/Twig.pm:2402
_twig_extern_ent                       7 blib/lib/XML/Twig.pm:2454
_twig_final                         2767 blib/lib/XML/Twig.pm:2332
_twig_ignore_end                     110 blib/lib/XML/Twig.pm:3693
_twig_ignore_start                    48 blib/lib/XML/Twig.pm:3680
_twig_init                          2780 blib/lib/XML/Twig.pm:1599
_twig_insert_ent                      27 blib/lib/XML/Twig.pm:2628
_twig_pi                            2972 blib/lib/XML/Twig.pm:2245
_twig_pi_check_roots                  19 blib/lib/XML/Twig.pm:3652
_twig_pi_comment                    6609 blib/lib/XML/Twig.pm:2260
_twig_print                          474 blib/lib/XML/Twig.pm:3458
_twig_print_check_doctype             15 blib/lib/XML/Twig.pm:3441
_twig_print_doctype                   11 blib/lib/XML/Twig.pm:3525
_twig_print_end_original              10 blib/lib/XML/Twig.pm:3554
_twig_print_entity                     6 blib/lib/XML/Twig.pm:3471
_twig_print_original                  41 blib/lib/XML/Twig.pm:3496
_twig_print_original_check_doctype     3 blib/lib/XML/Twig.pm:3481
_twig_print_original_default           2 blib/lib/XML/Twig.pm:3546
_twig_print_original_doctype           5 blib/lib/XML/Twig.pm:3505
_twig_start                        10367 blib/lib/XML/Twig.pm:1676
_twig_start_check_roots              373 blib/lib/XML/Twig.pm:3561
_twig_stop_storing_internal_dtd       76 blib/lib/XML/Twig.pm:1154
_twig_store_internal_dtd             160 blib/lib/XML/Twig.pm:1145
_twig_xmldecl                        102 blib/lib/XML/Twig.pm:2483
_unique_elts                         172 blib/lib/XML/Twig.pm:3162
_unprotect_extra_data                 63 blib/lib/XML/Twig.pm:8019
_unshift_extra_data_in_pcdata         14 blib/lib/XML/Twig.pm:4739
_use                                2964 blib/lib/XML/Twig.pm:1021
_utf8_ify                             77 blib/lib/XML/Twig.pm:7016
_weakrefs                              1 blib/lib/XML/Twig.pm:4127
_wrap_range                            9 blib/lib/XML/Twig.pm:8642
_wrap_text                             5 blib/lib/XML/Twig.pm:7906
_xml_parser_encodings                  2 blib/lib/XML/Twig.pm:915 
_xmldecl_toSAX                         7 blib/lib/XML/Twig.pm:3947
add                                   74 blib/lib/XML/Twig.pm:4174
add_att_to_class                       2 blib/lib/XML/Twig.pm:5277
add_id                                40 blib/lib/XML/Twig.pm:5406
add_new_ent                            5 blib/lib/XML/Twig.pm:4158
add_options                            1 blib/lib/XML/Twig.pm:1135
add_stylesheet                         2 blib/lib/XML/Twig.pm:995 
add_tag_to_class                       2 blib/lib/XML/Twig.pm:5282
add_to_class                           6 blib/lib/XML/Twig.pm:5268
after                                  3 blib/lib/XML/Twig.pm:8769
all_children_are                       3 blib/lib/XML/Twig.pm:5494
ancestors                           1017 blib/lib/XML/Twig.pm:5502
ancestors_or_self                     12 blib/lib/XML/Twig.pm:5512
append_cdata                           1 blib/lib/XML/Twig.pm:4955
append_extra_data                      1 blib/lib/XML/Twig.pm:4876
append_pcdata                          3 blib/lib/XML/Twig.pm:4867
att                                  404 blib/lib/XML/Twig.pm:5341
att_names                            562 blib/lib/XML/Twig.pm:5318
att_nb                                14 blib/lib/XML/Twig.pm:6863
att_to_class                           2 blib/lib/XML/Twig.pm:5276
att_to_field                           2 blib/lib/XML/Twig.pm:8705
att_xml_string                         1 blib/lib/XML/Twig.pm:8034
atts                                1684 blib/lib/XML/Twig.pm:5317
before                                 6 blib/lib/XML/Twig.pm:8764
cdata                                 47 blib/lib/XML/Twig.pm:4958
cdata_string                          50 blib/lib/XML/Twig.pm:8024
change_att_name                        2 blib/lib/XML/Twig.pm:5358
change_gi                              4 blib/lib/XML/Twig.pm:3248
child                                  2 blib/lib/XML/Twig.pm:3207
child                                 43 blib/lib/XML/Twig.pm:6077
child_matches                          2 blib/lib/XML/Twig.pm:5820
child_text                             2 blib/lib/XML/Twig.pm:5808
child_trimmed_text                     2 blib/lib/XML/Twig.pm:5814
children                              82 blib/lib/XML/Twig.pm:3194
children                             146 blib/lib/XML/Twig.pm:5434
children_copy                          1 blib/lib/XML/Twig.pm:5456
children_count                       768 blib/lib/XML/Twig.pm:5468
children_text                          3 blib/lib/XML/Twig.pm:5480
children_trimmed_text                  2 blib/lib/XML/Twig.pm:5487
class                                 45 blib/lib/XML/Twig.pm:5263
closed                                15 blib/lib/XML/Twig.pm:4718
cmp                                  830 blib/lib/XML/Twig.pm:8799
comment                                3 blib/lib/XML/Twig.pm:4931
comment_string                      1764 blib/lib/XML/Twig.pm:4932
contains_a_single                    156 blib/lib/XML/Twig.pm:4978
contains_only                          5 blib/lib/XML/Twig.pm:4970
contains_only_text                    42 blib/lib/XML/Twig.pm:4962
contains_text                        186 blib/lib/XML/Twig.pm:8313
copy                                  61 blib/lib/XML/Twig.pm:7164
create_accessors                       3 blib/lib/XML/Twig.pm:3105
current_ns_prefixes                    3 blib/lib/XML/Twig.pm:5560
cut                                 1318 blib/lib/XML/Twig.pm:6309
cut_children                          16 blib/lib/XML/Twig.pm:6358
data                                   5 blib/lib/XML/Twig.pm:4897
del_att                               44 blib/lib/XML/Twig.pm:5343
del_atts                               3 blib/lib/XML/Twig.pm:5319
del_id                                15 blib/lib/XML/Twig.pm:5418
del_twig_current                       1 blib/lib/XML/Twig.pm:5374
delete                                 4 blib/lib/XML/Twig.pm:4187
delete                              1191 blib/lib/XML/Twig.pm:7211
descendants                           79 blib/lib/XML/Twig.pm:3213
descendants                          203 blib/lib/XML/Twig.pm:5995
descendants_or_self                   43 blib/lib/XML/Twig.pm:6048
dispose                                3 blib/lib/XML/Twig.pm:3411
doctype                             2271 blib/lib/XML/Twig.pm:2798
doctype_name                           4 blib/lib/XML/Twig.pm:2723
dtd                                    7 blib/lib/XML/Twig.pm:2748
dtd_print                              3 blib/lib/XML/Twig.pm:3290
dtd_text                               4 blib/lib/XML/Twig.pm:3260
elt_id                                65 blib/lib/XML/Twig.pm:3244
encode_convert                        18 blib/lib/XML/Twig.pm:4114
encoding                               5 blib/lib/XML/Twig.pm:3802
end_tag                             4364 blib/lib/XML/Twig.pm:7645
ent                                   16 blib/lib/XML/Twig.pm:4181
ent                                    2 blib/lib/XML/Twig.pm:4935
ent_name                              12 blib/lib/XML/Twig.pm:4936
ent_string                            44 blib/lib/XML/Twig.pm:8067
entity                                14 blib/lib/XML/Twig.pm:2775
entity_list                          157 blib/lib/XML/Twig.pm:2763
entity_names                           6 blib/lib/XML/Twig.pm:2769
entity_names                           6 blib/lib/XML/Twig.pm:4222
erase                                 82 blib/lib/XML/Twig.pm:6366
extra_data                           157 blib/lib/XML/Twig.pm:4884
field_to_att                           3 blib/lib/XML/Twig.pm:8696
findvalue                             12 blib/lib/XML/Twig.pm:3170
findvalue                             13 blib/lib/XML/Twig.pm:6295
finish                                 1 blib/lib/XML/Twig.pm:3324
finish_now                             6 blib/lib/XML/Twig.pm:695 
finish_print                           6 blib/lib/XML/Twig.pm:3330
first_child                          532 blib/lib/XML/Twig.pm:5182
first_child_matches                    3 blib/lib/XML/Twig.pm:5784
first_child_text                      13 blib/lib/XML/Twig.pm:5767
first_child_trimmed_text               4 blib/lib/XML/Twig.pm:5778
first_descendant                      20 blib/lib/XML/Twig.pm:5634
first_elt                             87 blib/lib/XML/Twig.pm:3132
flush                                909 blib/lib/XML/Twig.pm:2912
flush                                 14 blib/lib/XML/Twig.pm:7778
flush_toSAX1                           3 blib/lib/XML/Twig.pm:3880
flush_toSAX2                           3 blib/lib/XML/Twig.pm:3886
flush_up_to                           18 blib/lib/XML/Twig.pm:3002
following_elt                          7 blib/lib/XML/Twig.pm:5690
following_elts                         6 blib/lib/XML/Twig.pm:5697
former_next_sibling                    4 blib/lib/XML/Twig.pm:6353
former_parent                         27 blib/lib/XML/Twig.pm:6355
former_prev_sibling                    3 blib/lib/XML/Twig.pm:6354
ge                                     2 blib/lib/XML/Twig.pm:8792
getChildNodes                        167 blib/lib/XML/Twig.pm:4124
getChildNodes                       1582 blib/lib/XML/Twig.pm:6302
getElementById                         1 blib/lib/XML/Twig.pm:6301
getParentNode                         17 blib/lib/XML/Twig.pm:4123
getRootNode                          122 blib/lib/XML/Twig.pm:4122
get_type                               6 blib/lib/XML/Twig.pm:4638
get_xpath                            150 blib/lib/XML/Twig.pm:3151
get_xpath                            173 blib/lib/XML/Twig.pm:6285
gi                                  7053 blib/lib/XML/Twig.pm:4533
global_state                           1 blib/lib/XML/Twig.pm:3405
global_state                          11 blib/lib/XML/Twig.pm:7300
gt                                     2 blib/lib/XML/Twig.pm:8786
has_no_atts                            3 blib/lib/XML/Twig.pm:6868
html_encode                            5 blib/lib/XML/Twig.pm:4017
iconv_convert                          4 blib/lib/XML/Twig.pm:4093
id                                   747 blib/lib/XML/Twig.pm:5395
ignore                                49 blib/lib/XML/Twig.pm:3734
ignore                                30 blib/lib/XML/Twig.pm:7235
in                                  2475 blib/lib/XML/Twig.pm:5754
in_class                              14 blib/lib/XML/Twig.pm:5298
in_context                            18 blib/lib/XML/Twig.pm:5943
index                                 10 blib/lib/XML/Twig.pm:3187
inherit_att                         4843 blib/lib/XML/Twig.pm:5531
init_global_state                      5 blib/lib/XML/Twig.pm:7336
insert                                 7 blib/lib/XML/Twig.pm:8421
insert_new_elt                        95 blib/lib/XML/Twig.pm:8448
internal_subset                        4 blib/lib/XML/Twig.pm:2741
is_asis                               64 blib/lib/XML/Twig.pm:4715
is_cdata                               1 blib/lib/XML/Twig.pm:4658
is_comment                             5 blib/lib/XML/Twig.pm:4668
is_elt                              1727 blib/lib/XML/Twig.pm:4645
is_empty                               5 blib/lib/XML/Twig.pm:4684
is_ent                                 1 blib/lib/XML/Twig.pm:4673
is_first_child                         9 blib/lib/XML/Twig.pm:5917
is_last_child                          9 blib/lib/XML/Twig.pm:5924
is_pcdata                           1791 blib/lib/XML/Twig.pm:4653
is_pi                                  9 blib/lib/XML/Twig.pm:4663
is_text                             2005 blib/lib/XML/Twig.pm:4679
keep_atts_order                        2 blib/lib/XML/Twig.pm:3386
keep_atts_order                    10471 blib/lib/XML/Twig.pm:7521
last_child                            53 blib/lib/XML/Twig.pm:5225
last_child_matches                     6 blib/lib/XML/Twig.pm:5802
last_child_text                        3 blib/lib/XML/Twig.pm:5790
last_child_trimmed_text                2 blib/lib/XML/Twig.pm:5796
last_descendant                       38 blib/lib/XML/Twig.pm:5638
last_elt                               7 blib/lib/XML/Twig.pm:3139
latin1                                 2 blib/lib/XML/Twig.pm:3978
le                                     2 blib/lib/XML/Twig.pm:8780
level                                349 blib/lib/XML/Twig.pm:5934
list                                   5 blib/lib/XML/Twig.pm:4228
local_name                           107 blib/lib/XML/Twig.pm:4536
lt                                     2 blib/lib/XML/Twig.pm:8774
mark                                  26 blib/lib/XML/Twig.pm:6924
merge                                  2 blib/lib/XML/Twig.pm:7150
merge_text                            69 blib/lib/XML/Twig.pm:7123
model                                  3 blib/lib/XML/Twig.pm:2754
move                                   6 blib/lib/XML/Twig.pm:8554
move_att_to_class                      1 blib/lib/XML/Twig.pm:5278
name                                   8 blib/lib/XML/Twig.pm:4257
namespace                             70 blib/lib/XML/Twig.pm:4568
ndata                                  2 blib/lib/XML/Twig.pm:4261
new                                 2776 blib/lib/XML/Twig.pm:382 
new                                 2759 blib/lib/XML/Twig.pm:4149
new                                   80 blib/lib/XML/Twig.pm:4240
new                                22162 blib/lib/XML/Twig.pm:4416
next_elt                             412 blib/lib/XML/Twig.pm:5582
next_elt_matches                       3 blib/lib/XML/Twig.pm:5893
next_elt_text                          2 blib/lib/XML/Twig.pm:5881
next_elt_trimmed_text                  2 blib/lib/XML/Twig.pm:5887
next_n_elt                             4 blib/lib/XML/Twig.pm:3145
next_n_elt                             7 blib/lib/XML/Twig.pm:5745
next_sibling                         490 blib/lib/XML/Twig.pm:5253
next_sibling_matches                   2 blib/lib/XML/Twig.pm:5857
next_sibling_text                      3 blib/lib/XML/Twig.pm:5845
next_sibling_trimmed_text              2 blib/lib/XML/Twig.pm:5851
next_siblings                          6 blib/lib/XML/Twig.pm:6110
normalize                              1 blib/lib/XML/Twig.pm:3099
normalize                              6 blib/lib/XML/Twig.pm:8157
nparse                              1859 blib/lib/XML/Twig.pm:838 
nparse_e                               5 blib/lib/XML/Twig.pm:844 
nparse_pp                              1 blib/lib/XML/Twig.pm:843 
nparse_ppe                             1 blib/lib/XML/Twig.pm:845 
ns_prefix                             79 blib/lib/XML/Twig.pm:4541
output_encoding                        2 blib/lib/XML/Twig.pm:3813
output_filter                         19 blib/lib/XML/Twig.pm:3349
output_filter                        119 blib/lib/XML/Twig.pm:7467
output_text_filter                     2 blib/lib/XML/Twig.pm:3352
output_text_filter                     2 blib/lib/XML/Twig.pm:7468
param                                  2 blib/lib/XML/Twig.pm:4262
parent                                41 blib/lib/XML/Twig.pm:5170
parent_matches                         8 blib/lib/XML/Twig.pm:5911
parent_text                            4 blib/lib/XML/Twig.pm:5899
parent_trimmed_text                    2 blib/lib/XML/Twig.pm:5905
parse                                 22 blib/lib/XML/Twig.pm:4480
parse                               2815 blib/lib/XML/Twig.pm:658 
parse_html                            15 blib/lib/XML/Twig.pm:779 
parsefile                             27 blib/lib/XML/Twig.pm:675 
parsefile_html                         5 blib/lib/XML/Twig.pm:770 
parsefile_html_inplace                 3 blib/lib/XML/Twig.pm:702 
parsefile_inplace                      3 blib/lib/XML/Twig.pm:701 
parser                               231 blib/lib/XML/Twig.pm:2671
parseurl                              11 blib/lib/XML/Twig.pm:740 
passes                              3786 blib/lib/XML/Twig.pm:5157
paste                                503 blib/lib/XML/Twig.pm:6488
paste_after                          176 blib/lib/XML/Twig.pm:6565
paste_before                          91 blib/lib/XML/Twig.pm:6535
paste_first_child                     52 blib/lib/XML/Twig.pm:6596
paste_last_child                    3404 blib/lib/XML/Twig.pm:6614
paste_within                           2 blib/lib/XML/Twig.pm:6632
path                                  17 blib/lib/XML/Twig.pm:3316
path                                  21 blib/lib/XML/Twig.pm:8607
pcdata                                11 blib/lib/XML/Twig.pm:4872
pcdata_xml_string                   1760 blib/lib/XML/Twig.pm:7967
pi_string                           1464 blib/lib/XML/Twig.pm:4914
pos                                   17 blib/lib/XML/Twig.pm:6101
preceding_elt                          7 blib/lib/XML/Twig.pm:5718
preceding_elts                         7 blib/lib/XML/Twig.pm:5725
prefix                                16 blib/lib/XML/Twig.pm:8563
prev_elt                              37 blib/lib/XML/Twig.pm:5659
prev_elt_matches                       3 blib/lib/XML/Twig.pm:5875
prev_elt_text                          2 blib/lib/XML/Twig.pm:5863
prev_elt_trimmed_text                  2 blib/lib/XML/Twig.pm:5869
prev_sibling                          99 blib/lib/XML/Twig.pm:5241
prev_sibling_matches                   3 blib/lib/XML/Twig.pm:5839
prev_sibling_text                      2 blib/lib/XML/Twig.pm:5827
prev_sibling_trimmed_text              2 blib/lib/XML/Twig.pm:5833
prev_siblings                         24 blib/lib/XML/Twig.pm:6093
print                                 20 blib/lib/XML/Twig.pm:2887
print                                  2 blib/lib/XML/Twig.pm:4203
print                                 14 blib/lib/XML/Twig.pm:4266
print                                 43 blib/lib/XML/Twig.pm:7740
print_prolog                         886 blib/lib/XML/Twig.pm:2782
print_to_file                          2 blib/lib/XML/Twig.pm:2875
prolog                              2272 blib/lib/XML/Twig.pm:2789
pubid                                  2 blib/lib/XML/Twig.pm:4260
public_id                              4 blib/lib/XML/Twig.pm:2735
purge                                 10 blib/lib/XML/Twig.pm:3052
purge                                  4 blib/lib/XML/Twig.pm:7783
purge_up_to                            7 blib/lib/XML/Twig.pm:3091
regexp2latin1                          1 blib/lib/XML/Twig.pm:4007
remove_cdata                           2 blib/lib/XML/Twig.pm:8136
replace                                6 blib/lib/XML/Twig.pm:8518
replace_with                           2 blib/lib/XML/Twig.pm:8543
reset_cond_cache                       1 blib/lib/XML/Twig.pm:5024
restore_global_state                  16 blib/lib/XML/Twig.pm:3400
root                                4732 blib/lib/XML/Twig.pm:3096
root                                1231 blib/lib/XML/Twig.pm:4987
safe_encode                           19 blib/lib/XML/Twig.pm:4022
safe_encode_hex                       19 blib/lib/XML/Twig.pm:4034
safe_parse                             9 blib/lib/XML/Twig.pm:1621
safe_parse_html                        1 blib/lib/XML/Twig.pm:764 
safe_parsefile                         3 blib/lib/XML/Twig.pm:1627
safe_parsefile_html                    1 blib/lib/XML/Twig.pm:750 
safe_parseurl                          9 blib/lib/XML/Twig.pm:745 
safe_parseurl_html                     1 blib/lib/XML/Twig.pm:756 
save_global_state                     10 blib/lib/XML/Twig.pm:3395
setCharHandler                         1 blib/lib/XML/Twig.pm:1487
setEndTagHandler                       2 blib/lib/XML/Twig.pm:1553
setEndTagHandlers                     10 blib/lib/XML/Twig.pm:1559
setIgnoreEltsHandler                   1 blib/lib/XML/Twig.pm:1539
setIgnoreEltsHandlers                  4 blib/lib/XML/Twig.pm:1545
setStartTagHandler                     3 blib/lib/XML/Twig.pm:1525
setStartTagHandlers                   26 blib/lib/XML/Twig.pm:1531
setTwigHandler                        63 blib/lib/XML/Twig.pm:1511
setTwigHandlers                      193 blib/lib/XML/Twig.pm:1517
setTwigRoots                          63 blib/lib/XML/Twig.pm:1568
set_asis                              16 blib/lib/XML/Twig.pm:4694
set_att                               93 blib/lib/XML/Twig.pm:5323
set_atts                           10439 blib/lib/XML/Twig.pm:5308
set_cdata                              2 blib/lib/XML/Twig.pm:4939
set_class                             13 blib/lib/XML/Twig.pm:5264
set_comment                            7 blib/lib/XML/Twig.pm:4922
set_content                          119 blib/lib/XML/Twig.pm:8359
set_data                               5 blib/lib/XML/Twig.pm:4894
set_do_not_escape_amp_in_atts       2770 blib/lib/XML/Twig.pm:3389
set_do_not_escape_amp_in_atts       2770 blib/lib/XML/Twig.pm:7461
set_doctype                            4 blib/lib/XML/Twig.pm:2713
set_empty                              1 blib/lib/XML/Twig.pm:4687
set_empty_tag_style                   85 blib/lib/XML/Twig.pm:3371
set_empty_tag_style                   95 blib/lib/XML/Twig.pm:7383
set_encoding                           4 blib/lib/XML/Twig.pm:3805
set_ent                                1 blib/lib/XML/Twig.pm:4934
set_expand_external_entities        2771 blib/lib/XML/Twig.pm:3234
set_expand_external_entities        2771 blib/lib/XML/Twig.pm:7507
set_extra_data                       695 blib/lib/XML/Twig.pm:4881
set_field                              3 blib/lib/XML/Twig.pm:5202
set_first_child                       42 blib/lib/XML/Twig.pm:5177
set_gi                             22184 blib/lib/XML/Twig.pm:4523
set_global_state                       1 blib/lib/XML/Twig.pm:3408
set_global_state                      22 blib/lib/XML/Twig.pm:7318
set_id                                51 blib/lib/XML/Twig.pm:5379
set_id_seed                            2 blib/lib/XML/Twig.pm:3180
set_id_seed                            2 blib/lib/XML/Twig.pm:5403
set_indent                             4 blib/lib/XML/Twig.pm:3380
set_indent                             5 blib/lib/XML/Twig.pm:7418
set_inner_html                         4 blib/lib/XML/Twig.pm:4504
set_inner_xml                          2 blib/lib/XML/Twig.pm:4495
set_input_filter                       4 blib/lib/XML/Twig.pm:3356
set_keep_atts_order                 2760 blib/lib/XML/Twig.pm:3383
set_keep_atts_order                 2761 blib/lib/XML/Twig.pm:7514
set_keep_encoding                   2763 blib/lib/XML/Twig.pm:3227
set_keep_encoding                   2764 blib/lib/XML/Twig.pm:7433
set_last_child                        29 blib/lib/XML/Twig.pm:5219
set_not_asis                           1 blib/lib/XML/Twig.pm:4708
set_not_empty                          1 blib/lib/XML/Twig.pm:4690
set_output_encoding                   18 blib/lib/XML/Twig.pm:3816
set_output_filter                   2783 blib/lib/XML/Twig.pm:3350
set_output_filter                   2783 blib/lib/XML/Twig.pm:7471
set_output_text_filter              2769 blib/lib/XML/Twig.pm:3353
set_output_text_filter              2769 blib/lib/XML/Twig.pm:7489
set_pcdata                           330 blib/lib/XML/Twig.pm:4726
set_pi                                 1 blib/lib/XML/Twig.pm:4900
set_pretty_print                      89 blib/lib/XML/Twig.pm:3374
set_pretty_print                    1661 blib/lib/XML/Twig.pm:7360
set_quote                              4 blib/lib/XML/Twig.pm:3377
set_quote                              4 blib/lib/XML/Twig.pm:7402
set_remove_cdata                    2760 blib/lib/XML/Twig.pm:3347
set_remove_cdata                    2760 blib/lib/XML/Twig.pm:7410
set_root                            2780 blib/lib/XML/Twig.pm:1903
set_standalone                         1 blib/lib/XML/Twig.pm:3840
set_tag_class                          1 blib/lib/XML/Twig.pm:5283
set_target                             3 blib/lib/XML/Twig.pm:4887
set_text                             220 blib/lib/XML/Twig.pm:8327
set_twig_current                      47 blib/lib/XML/Twig.pm:5373
set_wrap                               9 blib/lib/XML/Twig.pm:7425
set_xml_version                        1 blib/lib/XML/Twig.pm:3830
sibling                                9 blib/lib/XML/Twig.pm:6055
sibling_text                           3 blib/lib/XML/Twig.pm:6071
simplify                               2 blib/lib/XML/Twig.pm:3221
simplify                             121 blib/lib/XML/Twig.pm:6642
sort_children                          5 blib/lib/XML/Twig.pm:8737
sort_children_on_att                   1 blib/lib/XML/Twig.pm:8722
sort_children_on_field                 2 blib/lib/XML/Twig.pm:8715
sort_children_on_value                 1 blib/lib/XML/Twig.pm:8729
split                                  6 blib/lib/XML/Twig.pm:6911
split_at                              84 blib/lib/XML/Twig.pm:6896
sprint                              1365 blib/lib/XML/Twig.pm:3017
sprint                                 3 blib/lib/XML/Twig.pm:4274
sprint                              3104 blib/lib/XML/Twig.pm:7878
standalone                             2 blib/lib/XML/Twig.pm:3837
start_tag                           4415 blib/lib/XML/Twig.pm:7527
strip_att                             13 blib/lib/XML/Twig.pm:5352
subs_text                             17 blib/lib/XML/Twig.pm:3222
subs_text                             23 blib/lib/XML/Twig.pm:7029
suffix                                12 blib/lib/XML/Twig.pm:8586
sysid                                  3 blib/lib/XML/Twig.pm:4259
system_id                              4 blib/lib/XML/Twig.pm:2729
tag_to_class                           2 blib/lib/XML/Twig.pm:5281
tag_to_div                             2 blib/lib/XML/Twig.pm:5292
tag_to_span                            2 blib/lib/XML/Twig.pm:5286
target                                 1 blib/lib/XML/Twig.pm:4891
text                                  16 blib/lib/XML/Twig.pm:4216
text                                 111 blib/lib/XML/Twig.pm:4280
text                                2801 blib/lib/XML/Twig.pm:8082
text_only                              4 blib/lib/XML/Twig.pm:8107
toSAX1                                 2 blib/lib/XML/Twig.pm:3851
toSAX1                                 2 blib/lib/XML/Twig.pm:8171
toSAX2                                 5 blib/lib/XML/Twig.pm:3858
toSAX2                                 2 blib/lib/XML/Twig.pm:8174
trim                                  18 blib/lib/XML/Twig.pm:3223
trim                                  18 blib/lib/XML/Twig.pm:8119
trimmed_text                          14 blib/lib/XML/Twig.pm:8110
twig                                1209 blib/lib/XML/Twig.pm:4999
unicode_convert                        1 blib/lib/XML/Twig.pm:4076
val                                    2 blib/lib/XML/Twig.pm:4258
wrap_children                         13 blib/lib/XML/Twig.pm:8666
wrap_in                               16 blib/lib/XML/Twig.pm:8469
xml_string                          1558 blib/lib/XML/Twig.pm:7962
xml_text                              26 blib/lib/XML/Twig.pm:7845
xml_text_only                          1 blib/lib/XML/Twig.pm:7870
xml_version                            7 blib/lib/XML/Twig.pm:3827
xmldecl                             2271 blib/lib/XML/Twig.pm:2675
xparse                              1859 blib/lib/XML/Twig.pm:788 
xpath                                  6 blib/lib/XML/Twig.pm:8613

Uncovered Subroutines
---------------------

Subroutine                         Count Location                 
---------------------------------- ----- -------------------------
_current_ns_prefix_map                 0 blib/lib/XML/Twig.pm:4591
_del_extra_data_before_end_tag         0 blib/lib/XML/Twig.pm:4744
_pretty_print                          0 blib/lib/XML/Twig.pm:7375
_pretty_print_styles                   0 blib/lib/XML/Twig.pm:1140
_pretty_print_styles                   0 blib/lib/XML/Twig.pm:7399
_root_through_cut                      0 blib/lib/XML/Twig.pm:4993
_twig_through_cut                      0 blib/lib/XML/Twig.pm:5005
att_exists                             0 blib/lib/XML/Twig.pm:5348
declare_missing_ns                     0 blib/lib/XML/Twig.pm:4576
do_not_escape_gt                       0 blib/lib/XML/Twig.pm:3240
do_not_escape_gt                       0 blib/lib/XML/Twig.pm:7447
escape_gt                              0 blib/lib/XML/Twig.pm:3237
escape_gt                              0 blib/lib/XML/Twig.pm:7453
fields                                 0 blib/lib/XML/Twig.pm:5773
lc_attnames                            0 blib/lib/XML/Twig.pm:5367
set_next_sibling                       0 blib/lib/XML/Twig.pm:5250
set_ns_as_default                      0 blib/lib/XML/Twig.pm:4614
set_ns_decl                            0 blib/lib/XML/Twig.pm:4607
set_parent                             0 blib/lib/XML/Twig.pm:5165
set_prev_sibling                       0 blib/lib/XML/Twig.pm:5236
set_replaced_ents                      0 blib/lib/XML/Twig.pm:7440


blib/lib/XML/Twig/XPath.pm

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     # $Id: /xmltwig/trunk/Twig/XPath.pm 32 2008-01-18T13:11:52.128782Z mrodrigu  $
2                                                     package XML::Twig::XPath;
3             36                   36           188   use strict;
              36                                 59   
              36                                158   
4             36                   36           387   use XML::Twig;
              36                                107   
              36                                525   
5                                                     
6                                                     my $XPATH;        # XPath engine (XML::XPath or XML::XPathEngine);
7                                                     my $XPATH_NUMBER; # <$XPATH>::Number, the XPath number class  
8                                                     BEGIN 
9             36                   36           238     { foreach my $xpath_engine ( qw( XML::XPathEngine XML::XPath) )
10    ***     36     50                         179         { if(  XML::Twig::_use( $xpath_engine) ) { $XPATH= $xpath_engine; last; } }
              36                                123   
              36                                123   
11    ***     36     50                         306       unless( $XPATH) { die "cannot use XML::Twig::XPath: neither XML::XPathEngine 0.09+ nor XML::XPath are available"; }
      ***      0                                  0   
12            36                                157       $XPATH_NUMBER= "${XPATH}::Number";
13                                                      }
14                                                    
15                                                    
16            36                   36           297   use vars qw($VERSION);
              36                                 62   
              36                                213   
17                                                    $VERSION="0.02";
18                                                    
19                                                    BEGIN
20            36                   36           132   { package XML::XPath::NodeSet;
21            36                   36           273     no warnings; # to avoid the "Subroutine sort redefined" message 
              36                                 68   
              36                                192   
22                                                      # replace the native sort routine by a Twig'd one
23                                                      sub sort 
24    ***      0                    0             0       { my $self = CORE::shift;
25    ***      0                                  0         @$self = CORE::sort { $a->node_cmp( $b) } @$self;
      ***      0                                  0   
26    ***      0                                  0         return $self;
27                                                        }
28                                                    
29                                                      package XML::XPathEngine::NodeSet;
30            36                   36           265     no warnings; # to avoid the "Subroutine sort redefined" message 
              36                                 85   
              36                                429   
31                                                      # replace the native sort routine by a Twig'd one
32                                                      sub sort 
33           145                  145         28888       { my $self = CORE::shift;
34           145                                445         @$self = CORE::sort { $a->node_cmp( $b) } @$self;
             538                               2240   
35           145                               1192         return $self;
36                                                        }
37                                                    }
38                                                    
39                                                    package XML::Twig::XPath;
40                                                    
41            36                   36           254   use base 'XML::Twig';
              36                                 67   
              36                                321   
42                                                    
43    ***      1                    1      0     11   sub to_number { return $XPATH_NUMBER->new( $_[0]->root->text); }
44                                                    
45                                                    sub new
46            61                   61      1   7400     { my $class= shift;
47            61                                585       my $t= XML::Twig->new( elt_class => 'XML::Twig::XPath::Elt', @_);
48            61                                459       $t->{twig_xp}= $XPATH->new();
49            61                               6982       bless $t, $class;
50            61                                568       return $t;
51                                                      }
52                                                    
53                                                    
54    ***      5                    5      0    423   sub set_namespace         { my $t= shift; $t->{twig_xp}->set_namespace( @_); }
               5                                 27   
55    ***      2                    2      0    523   sub set_strict_namespaces { my $t= shift; $t->{twig_xp}->set_strict_namespaces( @_); }
               2                                 11   
56                                                    
57    ***      4    100             4      0     31   sub node_cmp($$)          { return $_[1] == $_[0] ? 0 : -1; } # document is before anything but itself
58                                                    
59            14                   14      1    375   sub isElementNode   { 0 }
60    ***      1                    1      0      4   sub isAttributeNode { 0 }
61             1                    1      1      4   sub isTextNode      { 0 }
62             1                    1      1      4   sub isProcessingInstructionNode { 0 }
63             1                    1      1      5   sub isPINode        { 0 }
64             1                    1      1      4   sub isCommentNode   { 0 }
65    ***      1                    1      0      3   sub isNamespaceNode { 0 }
66    ***      2                    2      0    137   sub getAttributes   { [] }
67    ***      1                    1      0      5   sub getValue { return $_[0]->root->text; }
68                                                    
69            84                   84      1   2537   sub findnodes           { my( $t, $path)= @_; return $t->{twig_xp}->findnodes(           $path, $t); }
              84                                563   
70             1                    1      1      5   sub findnodes_as_string { my( $t, $path)= @_; return $t->{twig_xp}->findnodes_as_string( $path, $t); }
               1                                  7   
71            17                   17      1    907   sub findvalue           { my( $t, $path)= @_; return $t->{twig_xp}->findvalue(           $path, $t); }
              17                                107   
72    ***      1                    1      0      5   sub exists              { my( $t, $path)= @_; return $t->{twig_xp}->exists(              $path, $t); }
               1                                  6   
73    ***      4                    4      0    103   sub find                { my( $t, $path)= @_; return $t->{twig_xp}->find(                $path, $t); }
               4                                 29   
74    ***      1            33      1      0      5   sub matches             { my( $t, $path, $node)= @_; $node ||= $t; return $t->{twig_xp}->matches( $node, $path, $t) || 0; }
      ***      1            50                    5   
               1                                  6   
75                                                    
76                                                    1;
77                                                    
78                                                    # adds the appropriate methods to XML::Twig::Elt so XML::XPath can be used as the XPath engine
79                                                    package XML::Twig::XPath::Elt;
80            36                   36           300   use base 'XML::Twig::Elt';
              36                                 77   
              36                                217   
81                                                    
82                                                    *getLocalName= *XML::Twig::Elt::local_name;
83                                                    *getValue    = *XML::Twig::Elt::text;
84    ***      4                    4      0     17   sub isAttributeNode { 0 }
85    ***      4                    4      0     17   sub isNamespaceNode { 0 }
86                                                    
87    ***      3                    3      0     23   sub to_number { return $XPATH_NUMBER->new( $_[0]->text); }
88                                                    
89                                                    sub getAttributes
90    ***    126                  126      0  15736     { my $elt= shift;
91           126                                567       my $atts= $elt->atts;
92                                                        # alternate, faster but less clean, way
93           126                                924       my @atts= map { bless( { name => $_, value => $atts->{$_}, elt => $elt }, 
             123                               1392   
94                                                                               'XML::Twig::XPath::Attribute') 
95                                                                      }
96                                                                       sort keys %$atts; 
97                                                        # my @atts= map { XML::Twig::XPath::Attribute->new( $elt, $_) } sort keys %$atts; 
98           126    100                         903       return wantarray ? @atts : \@atts;
99                                                      }
100                                                   
101                                                   sub getNamespace
102           14                   14           847     { my $elt= shift;
103   ***     14            66                  109       my $prefix= shift() || $elt->ns_prefix;
104   ***     14     50                          63       if( my $expanded= $elt->namespace( $prefix))
105           14                                 57         { return XML::Twig::XPath::Namespace->new( $prefix, $expanded); }
106                                                       else
107   ***      0                                  0         { return XML::Twig::XPath::Namespace->new( $prefix, ''); }
108                                                     }
109                                                   
110                                                   sub node_cmp($$) 
111   ***    507                  507      0   1652     { my( $a, $b)= @_;
112          507    100                        3030       if( UNIVERSAL::isa( $b, 'XML::Twig::XPath::Elt')) 
                    100                               
                    100                               
113                                                         { # 2 elts, compare them
114          471                               1964           return $a->cmp( $b);
115                                                         }
116                                                       elsif( UNIVERSAL::isa( $b, 'XML::Twig::XPath::Attribute'))
117                                                         { # elt <=> att, compare the elt to the att->{elt}
118                                                           # if the elt is the att->{elt} (cmp return 0) then -1, elt is before att
119           34           100                  156           return ($a->cmp( $b->{elt}) ) || -1 ;
120                                                         }
121                                                       elsif( UNIVERSAL::isa( $b, 'XML::Twig::XPath'))
122                                                         { # elt <=> document, elt is after document
123            1                                  2           return 1;
124                                                         } 
125                                                       else
126            1                                  3         { die "unknown node type ", ref( $b); }
127                                                     }
128                                                   
129                                                   sub getParentNode
130   ***    115            66    115          3190     { return $_[0]->_parent 
131                                                           || $_[0]->twig;
132                                                     }
133                                                     
134            5                    5      1     31   sub findnodes           { my( $elt, $path)= @_; return $elt->twig->{twig_xp}->findnodes(           $path, $elt); }
               5                                102   
135            2                    2      1      8   sub findnodes_as_string { my( $elt, $path)= @_; return $elt->twig->{twig_xp}->findnodes_as_string( $path, $elt); }
               2                                 10   
136            9                    9      1   1178   sub findvalue           { my( $elt, $path)= @_; return $elt->twig->{twig_xp}->findvalue(           $path, $elt); }
               9                                 54   
137   ***      1                    1      0      4   sub exists              { my( $elt, $path)= @_; return $elt->twig->{twig_xp}->exists(              $path, $elt); }
               1                                  5   
138   ***      1                    1      0      4   sub find                { my( $elt, $path)= @_; return $elt->twig->{twig_xp}->find(                $path, $elt); }
               1                                  5   
139   ***      7           100      7      0     29   sub matches             { my( $elt, $path)= @_; return $elt->twig->{twig_xp}->matches( $elt, $path, $elt->getParentNode) || 0; }
               7                                 35   
140                                                   
141                                                   
142                                                   1;
143                                                   
144                                                   # this package is only used to allow XML::XPath as the XPath engine, otherwise
145                                                   # attributes are just attached to their parent element and are not considered objects
146                                                   
147                                                   package XML::Twig::XPath::Attribute;
148                                                   
149                                                   sub new
150            1                    1      1      6     { my( $class, $elt, $att)= @_;
151            1                                  8       return bless { name => $att, value => $elt->att( $att), elt => $elt }, $class;
152                                                     }
153                                                   
154   ***      1                    1      0      7   sub getValue     { return $_[0]->{value}; }
155           97                   97          3751   sub getName      { return $_[0]->{name} ; }
156           31                   31          1699   sub getLocalName { (my $name= $_[0]->{name}) =~ s{^.*:}{}; $name; }
              31                                283   
157           56                   56          8426   sub string_value { return $_[0]->{value}; }
158   ***      3                    3      0    344   sub to_number    { return $XPATH_NUMBER->new( $_[0]->{value}); }
159            1                    1      1      4   sub isElementNode   { 0 }
160   ***      1                    1      0      4   sub isAttributeNode { 1 }
161   ***      1                    1      0      4   sub isNamespaceNode { 0 }
162            1                    1      1      4   sub isTextNode      { 0 }
163            1                    1      1      3   sub isProcessingInstructionNode { 0 }
164            1                    1      1      4   sub isPINode        { 0 }
165            1                    1      1      4   sub isCommentNode   { 0 }
166           11                   11           161   sub toString { return qq{$_[0]->{name}="$_[0]->{value}"}; }
167                                                   
168                                                   sub getNamespace
169   ***      0                    0             0     { my $att= shift;
170   ***      0                                  0       my $prefix= shift();
171   ***      0      0                           0       if( ! defined( $prefix))
172   ***      0      0                           0         { if($att->{name}=~ m{^(.*):}) { $prefix= $1; }
      ***      0                                  0   
173   ***      0                                  0           else                         { $prefix='';  }
174                                                         }
175                                                   
176   ***      0      0                           0       if( my $expanded= $att->{elt}->namespace( $prefix))
177   ***      0                                  0         { return XML::Twig::XPath::Namespace->new( $prefix, $expanded); }
178                                                     }
179                                                   
180                                                   sub node_cmp($$) 
181   ***     40                   40      0    169     { my( $a, $b)= @_;
182           40    100                         347       if( UNIVERSAL::isa( $b, 'XML::Twig::XPath::Attribute')) 
                    100                               
                    100                               
183                                                         { # 2 attributes, compare their elements, then their name 
184           17           100                   95           return ($a->{elt}->cmp( $b->{elt}) ) || ($a->{name} cmp $b->{name});
185                                                         }
186                                                       elsif( UNIVERSAL::isa( $b, 'XML::Twig::XPath::Elt'))
187                                                         { # att <=> elt : compare the att->elt and the elt
188                                                           # if att->elt is the elt (cmp returns 0) then 1 (elt is before att)
189           20           100                  104           return ($a->{elt}->cmp( $b) ) || 1 ;
190                                                         }
191                                                       elsif( UNIVERSAL::isa( $b, 'XML::Twig::XPath'))
192                                                         { # att <=> document, att is after document 
193            2                                  9           return 1;
194                                                         }
195                                                       else
196            1                                  3         { die "unknown node type ", ref( $b); }
197                                                     }
198                                                   
199                                                   *cmp=*node_cmp;
200                                                     
201                                                   1;
202                                                   
203                                                   package XML::Twig::XPath::Namespace;
204                                                   
205                                                   sub new
206           15                   15      1     73     { my( $class, $prefix, $expanded)= @_;
207           15                                174       bless { prefix => $prefix, expanded => $expanded }, $class;
208                                                     }
209                                                   
210   ***      1                    1      0      6   sub isNamespaceNode { 1; }
211                                                   
212            1                    1             7   sub getPrefix   { $_[0]->{prefix};   }
213            1                    1             6   sub getExpanded { $_[0]->{expanded}; }
214   ***     15                   15      0     87   sub getValue    { $_[0]->{expanded}; }
215            1                    1             6   sub getData     { $_[0]->{expanded}; }
216                                                   
217                                                   1
218                                                   


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
10    ***     50     36      0   if (XML::Twig::_use($xpath_engine))
11    ***     50      0     36   unless ($XPATH)
57           100      1      3   $_[1] == $_[0] ? :
98           100      2    124   wantarray ? :
104   ***     50     14      0   if (my $expanded = $elt->namespace($prefix)) { }
112          100    471     36   if (UNIVERSAL::isa($b, 'XML::Twig::XPath::Elt')) { }
             100     34      2   elsif (UNIVERSAL::isa($b, 'XML::Twig::XPath::Attribute')) { }
             100      1      1   elsif (UNIVERSAL::isa($b, 'XML::Twig::XPath')) { }
171   ***      0      0      0   if (not defined $prefix)
172   ***      0      0      0   if ($$att{'name'} =~ /^(.*):/) { }
176   ***      0      0      0   if (my $expanded = $$att{'elt'}->namespace($prefix))
182          100     17     23   if (UNIVERSAL::isa($b, 'XML::Twig::XPath::Attribute')) { }
             100     20      3   elsif (UNIVERSAL::isa($b, 'XML::Twig::XPath::Elt')) { }
             100      2      1   elsif (UNIVERSAL::isa($b, 'XML::Twig::XPath')) { }


Conditions
----------

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
74    ***     50      1      0   $$t{'twig_xp'}->matches($node, $path, $t) || 0
119          100      9     25   $a->cmp($$b{'elt'}) || -1
139          100      3      4   $elt->twig->{'twig_xp'}->matches($elt, $path, $elt->getParentNode) || 0
189          100     19      1   $$a{'elt'}->cmp($b) || 1

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
74    ***     33      1      0      0   $node ||= $t
103   ***     66      0      8      6   shift @_ || $elt->ns_prefix
130   ***     66     86     29      0   $_[0]->_parent || $_[0]->twig
184          100      7      9      1   $$a{'elt'}->cmp($$b{'elt'}) || $$a{'name'} cmp $$b{'name'}


Covered Subroutines
-------------------

Subroutine                  Count Pod Location                      
--------------------------- ----- --- ------------------------------
BEGIN                          36     blib/lib/XML/Twig/XPath.pm:16 
BEGIN                          36     blib/lib/XML/Twig/XPath.pm:20 
BEGIN                          36     blib/lib/XML/Twig/XPath.pm:21 
BEGIN                          36     blib/lib/XML/Twig/XPath.pm:3  
BEGIN                          36     blib/lib/XML/Twig/XPath.pm:30 
BEGIN                          36     blib/lib/XML/Twig/XPath.pm:4  
BEGIN                          36     blib/lib/XML/Twig/XPath.pm:41 
BEGIN                          36     blib/lib/XML/Twig/XPath.pm:80 
BEGIN                          36     blib/lib/XML/Twig/XPath.pm:9  
exists                          1   0 blib/lib/XML/Twig/XPath.pm:137
exists                          1   0 blib/lib/XML/Twig/XPath.pm:72 
find                            1   0 blib/lib/XML/Twig/XPath.pm:138
find                            4   0 blib/lib/XML/Twig/XPath.pm:73 
findnodes                       5   1 blib/lib/XML/Twig/XPath.pm:134
findnodes                      84   1 blib/lib/XML/Twig/XPath.pm:69 
findnodes_as_string             2   1 blib/lib/XML/Twig/XPath.pm:135
findnodes_as_string             1   1 blib/lib/XML/Twig/XPath.pm:70 
findvalue                       9   1 blib/lib/XML/Twig/XPath.pm:136
findvalue                      17   1 blib/lib/XML/Twig/XPath.pm:71 
getAttributes                   2   0 blib/lib/XML/Twig/XPath.pm:66 
getAttributes                 126   0 blib/lib/XML/Twig/XPath.pm:90 
getData                         1     blib/lib/XML/Twig/XPath.pm:215
getExpanded                     1     blib/lib/XML/Twig/XPath.pm:213
getLocalName                   31     blib/lib/XML/Twig/XPath.pm:156
getName                        97     blib/lib/XML/Twig/XPath.pm:155
getNamespace                   14     blib/lib/XML/Twig/XPath.pm:102
getParentNode                 115     blib/lib/XML/Twig/XPath.pm:130
getPrefix                       1     blib/lib/XML/Twig/XPath.pm:212
getValue                        1   0 blib/lib/XML/Twig/XPath.pm:154
getValue                       15   0 blib/lib/XML/Twig/XPath.pm:214
getValue                        1   0 blib/lib/XML/Twig/XPath.pm:67 
isAttributeNode                 1   0 blib/lib/XML/Twig/XPath.pm:160
isAttributeNode                 1   0 blib/lib/XML/Twig/XPath.pm:60 
isAttributeNode                 4   0 blib/lib/XML/Twig/XPath.pm:84 
isCommentNode                   1   1 blib/lib/XML/Twig/XPath.pm:165
isCommentNode                   1   1 blib/lib/XML/Twig/XPath.pm:64 
isElementNode                   1   1 blib/lib/XML/Twig/XPath.pm:159
isElementNode                  14   1 blib/lib/XML/Twig/XPath.pm:59 
isNamespaceNode                 1   0 blib/lib/XML/Twig/XPath.pm:161
isNamespaceNode                 1   0 blib/lib/XML/Twig/XPath.pm:210
isNamespaceNode                 1   0 blib/lib/XML/Twig/XPath.pm:65 
isNamespaceNode                 4   0 blib/lib/XML/Twig/XPath.pm:85 
isPINode                        1   1 blib/lib/XML/Twig/XPath.pm:164
isPINode                        1   1 blib/lib/XML/Twig/XPath.pm:63 
isProcessingInstructionNode     1   1 blib/lib/XML/Twig/XPath.pm:163
isProcessingInstructionNode     1   1 blib/lib/XML/Twig/XPath.pm:62 
isTextNode                      1   1 blib/lib/XML/Twig/XPath.pm:162
isTextNode                      1   1 blib/lib/XML/Twig/XPath.pm:61 
matches                         7   0 blib/lib/XML/Twig/XPath.pm:139
matches                         1   0 blib/lib/XML/Twig/XPath.pm:74 
new                             1   1 blib/lib/XML/Twig/XPath.pm:150
new                            15   1 blib/lib/XML/Twig/XPath.pm:206
new                            61   1 blib/lib/XML/Twig/XPath.pm:46 
node_cmp                      507   0 blib/lib/XML/Twig/XPath.pm:111
node_cmp                       40   0 blib/lib/XML/Twig/XPath.pm:181
node_cmp                        4   0 blib/lib/XML/Twig/XPath.pm:57 
set_namespace                   5   0 blib/lib/XML/Twig/XPath.pm:54 
set_strict_namespaces           2   0 blib/lib/XML/Twig/XPath.pm:55 
sort                          145     blib/lib/XML/Twig/XPath.pm:33 
string_value                   56     blib/lib/XML/Twig/XPath.pm:157
toString                       11     blib/lib/XML/Twig/XPath.pm:166
to_number                       3   0 blib/lib/XML/Twig/XPath.pm:158
to_number                       1   0 blib/lib/XML/Twig/XPath.pm:43 
to_number                       3   0 blib/lib/XML/Twig/XPath.pm:87 

Uncovered Subroutines
---------------------

Subroutine                  Count Pod Location                      
--------------------------- ----- --- ------------------------------
getNamespace                    0     blib/lib/XML/Twig/XPath.pm:169
sort                            0     blib/lib/XML/Twig/XPath.pm:24 


